<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.0.0">
<title data-rh="true">Blog | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-test-site.com/wiki/en/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-test-site.com/wiki/en/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-test-site.com/wiki/en/blog/page/3"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" property="og:locale:alternate" content="ko"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" property="og:title" content="Blog | My Site"><meta data-rh="true" name="description" content="Blog"><meta data-rh="true" property="og:description" content="Blog"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="icon" href="/wiki/en/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://your-docusaurus-test-site.com/wiki/en/blog/page/3"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/wiki/blog/page/3" hreflang="ko"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/wiki/en/blog/page/3" hreflang="en"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/wiki/blog/page/3" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/wiki/en/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/wiki/en/blog/atom.xml" title="My Site Atom Feed"><link rel="stylesheet" href="/wiki/en/assets/css/styles.a30419b5.css">
<script src="/wiki/en/assets/js/runtime~main.ed64e0e1.js" defer="defer"></script>
<script src="/wiki/en/assets/js/main.2608a6a3.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/wiki/en/"><div class="navbar__logo"><img src="/wiki/en/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/wiki/en/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">My Site</b></a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>English</a><ul class="dropdown__menu"><li><a href="/wiki/blog/page/3" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="ko">한국어</a></li><li><a href="/wiki/en/blog/page/3" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="en">English</a></li></ul></div><a class="navbar__item navbar__link" href="/wiki/en/docs/intro">Tutorial</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/wiki/en/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/AndrewDongminYoo/wiki" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/en/blog/front-backend-developer-roadmap">프론트+백엔드 개발자 로드맵</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/en/blog/static-property-in-java-class">Static Property in Java Class</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/en/blog/four-mainstream-d-bs-and-features">가장 많이 사용되는 주류 DB 4가지와 특징</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/en/blog/generate-unicode-emoji-regular-expression">Generate Unicode emoji regular expression</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/en/blog/redirection-of-the-website">웹사이트의 리다이렉팅 방식</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="https://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="index.ts뿐만 아니라 React Native Turbo 모듈 개발에서 생성된 모든 타입스크립트 파일을 내보내는 방법"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/en/blog/export-all-d-ts-files-in-turbo-module">터보 모듈의 모든 d.ts 파일 내보내기</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-04-16T00:00:00.000Z" itemprop="datePublished">April 16, 2023</time> · <!-- -->7 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="indexts뿐만-아니라-react-native-turbo-모듈-개발에서-생성된-모든-타입스크립트-파일을-내보내는-방법">index.ts뿐만 아니라 React Native Turbo 모듈 개발에서 생성된 모든 타입스크립트 파일을 내보내는 방법</h2>
<p>React Native 터보 모듈을 사용하면 별도의 스레드에서 실행되는 네이티브 모듈을 생성할 수 있어 성능과 안정성이 향상됩니다. TypeScript로 터보 모듈을 개발할 때 애플리케이션의 다른 부분에서 사용하기 위해 내보내야 하는 함수와 클래스가 다른 여러 파일이 있는 것이 일반적입니다.
Turbo 모듈의 모든 TypeScript 파일을 내보내려면 index.ts 파일을 다른 파일에서 필요한 모든 컴포넌트를 내보내기 위한 시작점으로 사용할 수 있습니다. index.ts 파일에서 다른 TypeScript 파일에서 컴포넌트를 가져온 다음 export 키워드를 사용하여 다시 내보낼 수 있습니다.
다음은 터보 모듈의 여러 TypeScript 파일에서 컴포넌트를 내보내는 방법의 예시입니다:</p>
<pre><code class="language-ts">// components.ts 파일
export const Component1 = () =&gt; {
  // 컴포넌트 로직
};
export const Component2 = () =&gt; {
  // // 컴포넌트 로직 }.
  // 컴포넌트 로직
};
// utils.ts 파일을 생성합니다:
export const Utils = {
  // 유틸리티 함수
};
// index.ts 파일:
export { Component1, Component2 } from &quot;./components&quot;;
export { Utils } from &quot;./utils&quot;;
</code></pre>
<p>이 예제에서는 components.ts 파일에서 Component1과 Component2를 내보내고, utils.ts 파일에서 Utils를 내보내고 있습니다. 이제 이러한 컴포넌트를 가져와 애플리케이션의 다른 부분에서 사용할 수 있습니다.</p>
<p>package.json 파일에서 메인 필드를 사용하여 패키지의 진입점을 지정할 수 있습니다. 기본적으로 기본 필드를 지정하지 않으면 기본적으로 index.js 또는 index.json으로 지정됩니다.
그러나 package.json 파일을 사용하여 패키지의 각 파일을 명시적으로 내보낼 수는 없습니다.
패키지의 각 파일을 명시적으로 내보낼 수 있게 하려면 각 파일에 대한 진입점을 만든 다음 package.json 파일에서 메인 필드를 사용하여 각 진입점을 지정해야 합니다.
예를 들어 패키지에 file1.js와 file2.js라는 두 개의 파일이 있고 각 파일을 명시적으로 내보낼 수 있도록 하려고 한다고 가정해 보겠습니다. 각 파일에 대한 진입점을 만들면 됩니다:</p>
<p>file1.js:</p>
<pre><code class="language-js">exports.function1 = function() {
  // 함수 로직
}
exports.function2 = function() { // 함수 로  직 }
  // 함수 로직
}
file2.js:
exports.function3 = function() {
  // 함수 로직
}
exports.function4 = function() { // 함수 로직 }
  // 함수 로직
}
</code></pre>
<p>그런 다음 package.json 파일에서 메인 필드를 사용하여 각 진입점을 지정합니다:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;my-package&quot;,
  &quot;버전&quot;: &quot;1.0.0&quot;,
  &quot;main&quot;: {
    &quot;file1&quot;: &quot;./file1.js&quot;,
    &quot;file2&quot;: &quot;./file2.js&quot;
  }
}
</code></pre>
<p>이 구성을 사용하면 각각의 진입점을 사용하여 각 파일을 가져올 수 있습니다:</p>
<pre><code class="language-js">const file1 = require(&quot;my-package/file1&quot;);
const file2 = require(&quot;my-package/file2&quot;);
file1.function1();
file2.function3();
</code></pre>
<p>그러나 이 접근 방식은 패키지가 커짐에 따라 다루기 힘들고 유지 관리가 어려워질 수 있습니다. 일반적으로 index.js와 같은 단일 진입점을 사용하고 해당 진입점에서 패키지의 모든 함수와 클래스를 내보내는 것이 좋습니다.</p>
<p><code>json &quot;main&quot;: &quot;lib/commonjs/index&quot;, &quot;module&quot;: &quot;lib/module/index&quot;, &quot;types&quot;: &quot;lib/typescript/index.d.ts&quot;, &quot;react-native&quot;: &quot;src/index&quot;, &quot;source&quot;: &quot;src/index&quot;</code></p>
<p>현재 리포지토리의 package.json에 있는 메인 프로퍼티 값입니다. 이 모든 파일을 오브젝트로 변경하고 각각의 경로를 입력해야 하나요?</p>
<p>package.json 파일을 사용하면 메인, 모듈, 유형, 리액트 네이티브 및 소스 필드를 포함하여 패키지의 진입점과 유형을 정의하는 여러 속성을 지정할 수 있습니다.
제공한 예제에서 main, module 및 types의 값은 각각 패키지의 CommonJS, ES6 및 TypeScript 빌드에 대한 진입점을 가리키는 문자열입니다. react-native 및 source 필드도 각각 React Native   빌드 및 소스 코드의 진입점을 가리키는 문자열입니다.
이러한 값은 객체로 변경할 필요가 없습니다. 실제로 이러한 필드의 값은 일반적으로 패키지의 다른 빌드 및 소스 코드에 대한 관련 진입점을 가리키는 문자열입니다.
엔트리 포인트 또는 소스 파일의 경로를 업데이트해야 하는 경우 이러한 필드의 값을 수정하여 올바른 경로를 가리키도록 할 수 있습니다. 하지만 해당 값이 패키지의 빌드 및 유형에 맞는 올바른 엔트리 포인트 또는 소스 파일을 가리키는 유효한 문자열인지 확인해야 합니다.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="ESLint의 공식 웹사이트에서 ESLint 플러그인을 만드는 방법에 대한 가이드를 제공하고 있습니다. 이 가이드에서는 ESLint 플러그인이 무엇인지, 어떻게 추가 규칙과 구성 옵션을 추가하는지에 대한 정보가 제공됩니다."><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/en/blog/custom-es-lint-plugin-for-react-components">Custom ESLint Plugin for React Components</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-04-13T00:00:00.000Z" itemprop="datePublished">April 13, 2023</time> · <!-- -->5 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>ESLint의 공식 웹사이트에서 ESLint 플러그인을 만드는 방법에 대한 가이드를 제공하고 있습니다. 이 가이드에서는 ESLint 플러그인이 무엇인지, 어떻게 추가 규칙과 구성 옵션을 추가하는지에 대한 정보가 제공됩니다.</p>
<p>(1) <a href="https://eslint.org/docs/latest/extend/plugins">https://eslint.org/docs/latest/extend/plugins</a></p>
<p>ESLint 플러그인을 만들기 위해서는 ESLint의 공식 웹사이트에서 제공하는 가이드를 참조하시면 됩니다. 이 가이드에서는 ESLint 플러그인의 이름 규칙, 규칙 추가 방법, 환경 설정 방법 등에 대한 정보가 제공됩니다. 예를 들어, 플러그인의 이름이 <code>eslint-plugin-myplugin</code>이라면, ESLint 구성에서 규칙의 이름은 <code>myplugin/dollar-sign</code>으로 지정해야 합니다.</p>
<p>(1) <a href="https://eslint.org/docs/latest/extend/plugins">https://eslint.org/docs/latest/extend/plugins</a></p>
<p>ESLint 플러그인을 만들어 리액트 컴포넌트에 필수적으로 특정 프로퍼티를 입력하도록 강제하거나, 린터 픽스를 실행했을 때 파일의 상대적 경로와 컴포넌트가 속해 있는 함수 또는 클래스 스코프의 네임스페이스를 조합한 고유 아이디를 생성하는 기능을 구현하려면 다음과 같은 요소들이 필요합니다:</p>
<ol>
<li>ESLint 플러그인 개발에 대한 기본적인 지식: ESLint 플러그인 개발에 대한 기본적인 지식을 습득해야 합니다. ESLint의 공식 웹사이트에서 제공하는 가이드를 참조하시면 됩니다.</li>
<li>리액트 컴포넌트 구조에 대한 이해: 리액트 컴포넌트의 구조와 프로퍼티 설정 방법에 대한 이해가 필요합니다.</li>
<li>AST(Abstract Syntax Tree) 분석: ESLint는 코드를 분석하기 위해 AST(Abstract Syntax Tree)를 사용합니다. 따라서 AST 분석 방법에 대한 이해가 필요합니다.</li>
<li>자바스크립트 언어 지식: ESLint 플러그인은 자바스크립트로 작성되므로 자바스크립트 언어에 대한 지식이 필요합니다.
위의 요소들을 준비하시면 ESLint 플러그인을 만들어 원하는 기능을 구현할 수 있습니다.
AST(Abstract Syntax Tree) 분석은 코드의 구조를 이해하고 분석하는 데 사용되는 방법입니다. 코드를 분석하기 위해서는 먼저 코드를 토큰화하여 토큰 목록을 생성합니다. 이후 구문 분석(파싱) 단계에서 토큰 목록을 AST로 변환합니다. 이 과정에서 토큰들이 코드의 실제 구조를 나타내는 트리로 변환됩니다.
AST 분석을 위해서는 AST의 구조와 작동 방식에 대한 이해가 필요합니다. 또한, 코드를 분석하고자 하는 언어의 구문 규칙에 대한 지식도 필요합니다. 이러한 지식을 바탕으로 AST를 생성하고 분석하여 코드의 구조와 의미를 파악할 수 있습니다.</li>
</ol>
<p>(1) <a href="https://www.twilio.com/blog/abstract-syntax-trees">https://www.twilio.com/blog/abstract-syntax-trees</a>
(2) <a href="https://asbestos.me.go.kr/user/ha/astAnalysisPage.do?tab=tab1">https://asbestos.me.go.kr/user/ha/astAnalysisPage.do</a>
(3) <a href="https://www.synbiosis.com/application-notes/antibiotic-susceptibility-test-ast/">https://www.synbiosis.com/application-notes/antibiotic...</a></p>
<p>AST 분석을 위해서는 코드를 토큰화하고 구문 분석하여 AST를 생성하는 도구가 필요합니다. 이러한 도구로는 파서 생성기가 있습니다. 파서 생성기는 언어의 구문 규칙을 입력으로 받아 파서를 생성하는 도구입니다. 생성된 파서를 사용하여 코드를 토큰화하고 구문 분석하여 AST를 생성할 수 있습니다.
또한, AST를 시각화하고 분석하는 데 사용되는 도구도 있습니다. 이러한 도구로는 AST Explorer와 같은 웹 기반 도구가 있습니다. 이러한 도구를 사용하면 코드를 입력하여 AST를 생성하고 시각화하여 분석할 수 있습니다.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="수요 예측 및 생산 최적화"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/en/blog/cases-that-ai-can-be-used-in-the-restaurant-industry">외식업 산업에서 AI 활용할 수 있는 사례</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-04-10T00:00:00.000Z" itemprop="datePublished">April 10, 2023</time> · <!-- -->3 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="수요-예측-및-생산-최적화">수요 예측 및 생산 최적화</h2>
<ul>
<li><strong>User:</strong> 재고 부족과 대기 시간 단축으로 보다 효율적이고 정확한 서비스를 제공합니다.</li>
<li><strong>Company:</strong> 매출 증대와 낭비 감소로 수익성과 고객 충성도를 높일 수 있습니다.</li>
<li><strong>Store:</strong> 재고 관리가 개선되고 낭 비가 감소하여 수익성이 향상되고 자원 배분이 개선되는 이점을 누릴 수 있습니다.</li>
<li><strong>Society:</strong> 음식물 쓰레기 감소와 지속 가능한 비즈니스 관행으로 더 건강하고 환경 친화적인 커뮤니티를 조성할 수 있습니다.</li>
</ul>
<h2 id="재고-수준에-따른-동적-가격-책정">재고 수준에 따른 동적 가격 책정</h2>
<ul>
<li><strong>User:</strong> 실제 재고 수준과 수요를 반영한 가격으로 더 저렴하고 접근하기 쉬운 제품을 제공합니다.</li>
<li><strong>Company:</strong> 매출 증가와 폐기물 감소로 수익성이 향상되고 재고 관리가 개선됩니다.</li>
<li><strong>Store:</strong> 재고 관리가 개선되고 낭비가 감소하여 수익성이 향상되고 자원 배분이 개선되는 이점을 누릴 수 있습니다.</li>
<li><strong>Society:</strong> 음식물 쓰레기 감소와 지속 가능한 비즈니스 관행으로 더 건강하고 환경 친화적인 커뮤니티를 조성할 수 있습니다.</li>
</ul>
<h2 id="배송-경로-계산-및-가장-가까운-배송원에게-할당">배송 경로 계산 및 가장 가까운 배송원에게 할당</h2>
<ul>
<li><strong>User:</strong> 가장 가까운 배송 담당자에게 주문이 배정되고 최적화된 배송 경로를 통해 더 빠르고 안정적인 배송의 이점을 누릴 수 있습니다.</li>
<li><strong>Company:</strong> 배송 효율성이 향상되고 비용이 절감되어 수익성과 고객 만족도가 높아집니다.</li>
<li><strong>Store:</strong> 더 나은 리소스 할당과 배송 효율성 개선으로 수익성 향상과 재고 관리 개선의 이점을 누릴 수 있습니다.</li>
<li><strong>Society:</strong> 배송 시간 단축과 지속 가능한 운송 관행을 통해 더 건강하고 환경 친화적인 커뮤니티를 조성할 수 있습니다.</li>
</ul></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="LangChain 소개"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/en/blog/langchain-app-development-framework-based-on-language-model">LangChain - 언어 모델을 기반으로 한 앱개발 프레임워크</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-04-09T00:00:00.000Z" itemprop="datePublished">April 9, 2023</time> · <!-- -->13 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="langchain-소개">LangChain 소개</h2>
<p>LangChain은 언어 모델을 기반으로 한 응용 프로그램을 개발하기 위한 프레임워크입니다. 이 프레임워크는 언어 모델을 API를 통해 호출하는 것뿐만 아니라 데이터를 연결하고 환경과 상호작용하는 응용 프로그램을 개발하는 데 유용합니다.
LangChain은 모듈식 구성 요소와 사용 사례에 따라 구성 요소를 조합하여 특정 사용 사례를 가장 잘 수행할 수 있는 체인을 제공합니다.</p>
<h3 id="references">References</h3>
<p>(1) <a href="https://docs.langchain.com/docs/">🦜️🔗 LangChain | 🦜️🔗 LangChain</a>
(2) <a href="https://python.langchain.com/en/latest/index.html">Welcome to LangChain — 🦜 🔗 LangChain 0.0.134</a>
(3) <a href="https://zhuanlan.zhihu.com/p/617105505">LangChain 分享（一）：环境准备 - 知乎</a>
LangChain은 언어 모델과 작업하는 데 필요한 구성 요소에 대한 모듈식 추상화를 제공합니다. 이러한 구성 요소는 사용하기 쉽게 설계되어 있으며 LangChain 프레임워크의 나머지 부분을 사용하든 사용하지 않든 관계없이 쉽게 사용할 수 있습니다 .
LangChain은 구성 요소와 체인을 조합하여 특정 사용 사례를 가장 잘 수행할 수 있는 방식으로 작동합니다. 체인은 이러한 구성 요소를 특정 방식으로 조합하여 특정 사용 사례를 가장 잘 수행할 수 있도록 설계된 것입니다. 이러한 체인은 또한 사용자 정의가 가능하며, 높은 수준의 인터페이스를 제공하여 사용자가 쉽게 특정 사용 사례로 시작할 수 있도록 합니다.
LangChain은 또한 언어 모델을 다른 데이터 소스와 연결하고 환경과 상호작용하는 응용 프로그램을 개발하는 데 유용합니다. 이를 위해 LangChain은 모듈식 구성 요소와 사용 사례에 따라 구성 요소를 조합하여 특정 사용 사례를 가장 잘 수행할 수 있는 체인을 제공합니다.
LangChain은 다음과 같은 주요 모듈을 지원합니다: 모델 유형 및 모델 통합, 프롬프트 관리 및 최적화, 프롬프트 직렬화, 체인/에이전트 간 호출의 상태 유지를 위한 메모리, 텍스트 데이터와 결합하여 언어 모델을 더 강력하게 만들기 위한 인덱스, 단일 LLM 호출을 넘어서는 체인 및 에이전트 .
LangChain의 구성 요소 중 하나는 모델입니다. 모델은 LangChain이 지원하는 다양한 모델 유형 및 모델 통합을 포함합니다. LangChain은 이러한 모델에 대한 모듈식 추상화와 구현을 제공합니다.
LangChain의 구성 요소 중 하나는 프롬프트 관리입니다. 프롬프트 관리는 프롬프트 최적화 및 직렬화를 포함합니다. 프롬프트는 언어 모델에 입력으로 제공되는 텍스트로, 언어 모델이 생성하는 출력을 제어하는 데 사용됩니다. LangChain은 프롬프트 관리를 위한 모듈식 추상화를 제공하며, 이러한 추상화의 구현을 제공합니다.
LangChain은 또한 메모리 구성 요소를 제공합니다. 메모리는 체인/에이전트 간 호출의 상태를 유지하는 데 사용됩니다. LangChain은 메모리에 대한 표준 인터페이스와 메모리 구현의 컬렉션을 제공하며, 메모리를 사용하는 체인/에이전트의 예제도 제공합니다.
LangChain의 구성 요소 중 하나는 인덱스입니다. 인덱스는 언어 모델을 자체 텍스트 데이터와 결합하여 더 강력하게 만들기 위한 모듈입니다. LangChain은 이를 위한 모듈식 추상화와 구현을 제공합니다.
LangChain은 또한 체인 구성 요소를 제공합니다. 체인은 단일 LLM 호출을 넘어서는 것으로, LLM 또는 다른 유틸리티에 대한 호출 시퀀스입니다. LangChain은 체인에 대한 표준 인터페이스와 다른 도구와의 통합을 제공하며, 일반적인 응용 프로그램에 대한 엔드-투-엔드 체인도 제공합니다.
LangChain의 구성 요소 중 하나는 에이전트입니다. 에이전트는 LLM이 어떤 액션을 취할지 결정하고, 해당 액션을 취하고, 관찰을 보고, 완료될 때까지 반복하는 것을 포함합니다. LangChain은 에이전트에 대한 표준 인터페이스와 선택할 수 있는 에이전트를 제공하며, 엔드-투-엔드 에이전트의 예제도 제공합니다.
LangChain의 구성 요소 중 하나는 평가입니다. 생성 모델은 전통적인 지표로 평가하기 어렵습니다. 이를 평가하는 새로운 방법 중 하나는 언어 모델 자체를 사용하여 평가하는 것입니다. LangChain은 이를 위한 프롬프트/체인을 제공합니다.
LangChain은 Benchmark가 이끄는 1000만 달러의 시드 라운드를 발표했습니다. LangChain은 오픈 소스 프로젝트로 시작되었으며, 이제 GitHub에서 20K 이상의 스타와 10K 이상의 활성 Discord 멤버, Twitter에서 30K 이상의 팔로워를 보유하고 있습니다.</p>
<h3 id="references-1">References</h3>
<p>(1) <a href="https://blog.langchain.dev/announcing-our-10m-seed-round-led-by-benchmark/">Announcing our $10M seed round led by Benchmark</a>
(2) <a href="https://pypi.org/project/langchain/">langchain · PyPI</a>
(3) <a href="https://python.langchain.com/en/latest/index.html">Welcome to LangChain — 🦜🔗 LangChain 0.0.134</a>
LangChain은 언어 모델을 기반으로 한 응용 프로그램을 개발하는 데 사용할 수 있습니다. 이러한 응용 프로그램은 다양한 분야에서 사용될 수 있습니다. 예를 들어, LangChain은 개인 비서, 질문 응답, 챗봇, 테이블 형식의 데이터 쿼리 및 API와 상호작용하는 응용 프로그램 개발에 사용될 수 있습니다.
LangChain은 Python 및 JavaScript와 같은 다양한 언어로 구현되어 있습니다. 따라서 파이썬과 타입스크립트를 사용하는 개발자는 LangChain을 시작할 수 있습니다.</p>
<p>LangChain의 언어별 섹션에서는 해당 언어로 구성 요소 및 사용 사례를 사용하는 방법에 대한 정보를 제공합니다. 이러한 섹션에서는 언어별로 구성 요소 및 사용 사례를 사용하는 방법에 대한 자세한 정보를 찾을 수 있습니다.
LangChain은 다양한 언어로 구현되어 있으며, 이러한 언어별 섹션에서는 해당 언어로 구성 요소 및 사용 사례를 사용하는 방법에 대한 정보를 제공합니다. 현재까지는 Python과 JavaScript만 지원합니다.
LangChain은 챗봇을 만드는 데 사용될 수 있습니다. 언어 모델은 텍스트를 생성하는 데 뛰어나므로 챗봇을 만드는 데 이상적입니다. LangChain은 이러한 기능을 지원하는 구성 요소와 체인을 제공합니다.
LangChain은 또한 개인 비서와 같은 다른 사용 사례도 지원합니다. 이 경우 LangChain은 액션을 취하고, 상호작용을 기억하고, 데이터에 대한 지식이 필요한 개인 비서를 만드는 데 사용될 수 있습니다. LangChain은 이러한 기능을 지원하는 구성 요소와 체인을 제공합니다.
LangChain은 또한 질문 응답과 같은 다른 사용 사례도 지원합니다. 이 경우 LangChain은 특정 문서에 대한 질문에 대한 답변을 생성하는 데 사용될 수 있습니다. 이러한 답변은 해당 문서의 정보만을 사용하여 구성됩니다.
LangChain은 특정 문서에 대한 질문에 대한 답변을 생성하는 데 사용될 수 있습니다. 이 경우 LangChain은 해당 문서의 정보만을 사용하여 답변을 구성합니다. 그러나 LangChain은 여러 문서를 학습하여 모든 FAQ를 반환하는 것은 아닙니다.
LangChain은 언어 모델을 기반으로 한 응용 프로그램을 개발하기 위한 프레임워크입니다. 이 프레임워크는 언어 모델을 API를 통해 호출하는 것뿐만 아니라 데이터를 연결하고 환경과 상호작용하는 응용 프로그램을 개발하는 데 유용합니다.</p>
<p>그러나 LangChain 자체는 AI 모델을 공식적으로 제공하지 않으며, 외부 언어 모델의 API를 사용하여 응용 프로그램을 개발하는 데 사용될 수 있습니다. LangChain은 이러한 언어 모델을 API를 통해 호출하는 것뿐만 아니라 데이터를 연결하고 환경과 상호작용하는 응용 프로그램을 개발하는 데 유용합니다.
LangChain은 이러한 언어 모델과 작업하는 데 필요한 구성 요소에 대한 모듈식 추상화를 제공합니다. 이러한 구성 요소는 사용하기 쉽게 설계되어 있으며 LangChain 프레임워크의 나머지 부분을 사용하든 사용하지 않든 관계없이 쉽게 사용할 수 있습니다.
LLM(Large Language Model)만으로는 어플리케이션을 만들기가 어렵습니다. 하지만 LangChain에서 제공하는 다양한 기능을 활용하면 강력한 어플리케이션을 만들 수 있습니다. 이번 리뷰에서는 Microsoft가 Github에 공유한 VisualChatGPT와 LangChain이 적용된 여러 사례를 보면서 어떻게 활용할 수 있을 지 알아보겠습니다.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content=".NET과 Multi-platform App UI"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/en/blog/microsoft-maui">microsoft의 MAUI</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-04-07T00:00:00.000Z" itemprop="datePublished">April 7, 2023</time> · <!-- -->25 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="net과-multi-platform-app-ui">.NET과 Multi-platform App UI</h2>
<p>.NET Multi-platform App UI (.NET MAUI)는 C#과 XAML을 사용하여 네이티브 모바일 및 데스크탑 앱을 만들기 위한 크로스 플랫폼 프레임워크입니다. .NET MAUI를 사용하면 Android, iOS, macOS 및 Windows에서 단일 공유 코드베이스에서 실행할 수 있는 앱을 개발할 수 있습니다. .NET MAUI는 오픈 소스이며 Xamarin.Forms의 진화이며 모바일에서 데스크탑 시나리오로 확장되고 성능 및 확장성을 위해 UI 컨트롤이 처음부터 다시 구축되었습니다.
.NET MAUI를 사용하면 하나의 프로젝트를 사용하여 멀티 플랫폼 앱을 만들 수 있지만 필요한 경우 플랫폼별 소스 코드와 리소스를 추가할 수 있습니다. .NET MAUI의 주요 목표 중 하나는 앱 로직과 UI 레이아웃을 가능한 한 많이 단일 코드베이스에서 구현할 수 있도록 하는 것입니다.</p>
<h3 id="references">References</h3>
<ol>
<li><a href="https://learn.microsoft.com/en-us/dotnet/maui/what-is-maui?view=net-maui-7.0">What is .NET MAUI? - .NET MAUI | Microsoft Learn</a></li>
<li><a href="https://dotnet.microsoft.com/en-us/apps/maui">.NET Multi-platform App UI (.NET MAUI) | .NET</a></li>
<li><a href="https://learn.microsoft.com/es-es/dotnet/maui/what-is-maui?view=net-maui-7.0">¿Qué es .NET MAUI? - .NET MAUI | Microsoft Learn</a></li>
<li><a href="https://dotnet.microsoft.com/es-es/apps/maui">Interfaz de usuario de aplicaciones multiplataforma (.NET MAUI) de .NET | .NET</a></li>
</ol>
<h2 id="maui는-c과-같은-단일-언어로만-만들  어집니까">MAUI는 C#과 같은 단일 언어로만 만들어집니까?</h2>
<p>.NET MAUI는 C#과 XAML을 사용하여 앱을 만들 수 있습니다. 이를 통해 개발자는 단일 공유 코드베이스에서 Android, iOS, macOS 및 Windows에서 실행할 수 있는 앱을 개발할 수 있습니다 .
MAUI는 기존의 크로스플랫폼 애플리케이션 개발 도구들과 열려있는 호환을 제공합니까?
.NET MAUI는 다른 크로스 플랫폼 애플리케이션 개발 도구와의 호환성에 대한 정보를 찾지 못했습니다. 하지만 .NET MAUI는 Windows, macOS, iOS 및 Android에서 네이티브 앱을 구축하기 위한 최신 기술을 사용하여 이들을 .NET 기반의 일반 프레임워크로 추상화합니다.</p>
<h3 id="references-1">References</h3>
<ol>
<li><a href="https://dotnet.microsoft.com/en-us/apps/maui">.NET Multi-platform App UI (.NET MAUI) | .NET</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/maui/get-started/installation?view=net-maui-7.0">Install Visual Studio 2022 to develop cross-platform apps using .NET MAUI - .NET MAUI ...</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/single-project?view=net-maui-7.0">Target multiple platforms from .NET MAUI single project</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/maui/platform-integration/configure-multi-targeting?view=net-maui-7.0">Configure .NET MAUI multi-targeting - .NET MAUI | Microsoft Learn</a></li>
</ol>
<h2 id="concept-of-maui">Concept of MAUI</h2>
<p>&quot;MAUI(Multi-platform App UI)는 여느 크로스플랫폼에서 접하기 힘든 독보적인 컨셉을 갖추고 있습니다. 그것은 네이티브 친화적인 크로스 플랫폼을 지향한다는 것입니다. &quot;
이것이 의미하는 바를 좀 더 이해하기 쉽게 설명해 주세요.
.NET MAUI는 Windows, macOS, iOS 및 Android에서 네이티브 앱을 구축하기 위한 최신 기술을 사용하여 이들을 .NET 기반의 일반 프레임워크로 추상화합니다. 이는 개발자가 모든 디바이스 대상에 대해 단일 C# 코드베이스와 프로젝트 시스템을 사용하여 네이티브 플랫폼과 같은 느낌의 앱을 구축할 수 있음을 의미합니다 .
이것은 개발자가 하나의 코드베이스에서 여러 플랫폼에 대한 앱을 만들 수 있도록 지원하면서 각 플랫폼의 네이티브 기능과 성능을 최대한 활용할 수 있도록 지원하는 것입니다.
단일 언어로 멀티 플랫폼 애플리케이션을 개발하고자 하는 시도는 코틀린이나 오브젝티브 C++ 등이 꽤 오랫동안 공을 들이고 있는 목표 중 하나입니다. MAUI의 현재 스테이지는 마일스톤에서 어느 정도 단계에 와 있습니까? 안드로이드나 iOS 개발자들이 당장 자바 코틀린과 ObjC 스위프트 대신 닷넷을 학습하기 시작해야 할 만큼의 성능이나 탁월한 개발 경험을 제공합니까?</p>
<p>.NET MAUI는 Android, iOS, macOS 및 Windows API를 단일 API로 통합하여 여러 플랫폼에서 네이티브로 실행되는 하나의 앱을 작성할 수 있도록 합니다. 개발자의 일상적인 생산성과 애플리케이션의 성능 모두 개선하는 데 중점을 두고 있습니다. 개발자 생산성의 증가는 애플리케이션 성능의 비용으로 이루어져서는 안됩니다.
.NET 7에서 .NET MAUI의 성능은 주요한 초점입니다. Android에서 시작 성능이 향상되었으며 iOS에서는 애플리케이션 크기가 줄어들었습니다. 뷰의 렌더링 경로가 최적화되었습니다.
.NET MAUI는 현재 스테이지에서도 이미 매우 강력한 프레임워크입니다. 그러나 개발자가 자바 코틀린과 ObjC 스위프트 대신 닷넷을 학습하기 시작해야 할 만큼의 성능이나 탁월한 개발 경험을 제공하는지 여부는 개인적인 판단에 따라 다릅니다.</p>
<h3 id="references-2">References</h3>
<ol>
<li><a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-dotnet-maui/">Performance Improvements in .NET MAUI - .NET Blog</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/maui/whats-new/dotnet-7?view=net-maui-7.0">What&#x27;s new in .NET MAUI for .NET 7 - .NET MAUI | Microsoft Learn</a></li>
<li><a href="https://learn.microsoft.com/en-us/shows/one-dev-minute/how-has-dotnet-maui-been-tuned-for-performance">How has .NET MAUI been tuned for performance? | Microsoft Learn</a></li>
</ol>
<h2 id="support-of-apple-and-google">Support of Apple and Google</h2>
<p>구글이나 애플과 같은 각 플랫폼의 관리 조직들의 협조 상태는 어떠합니까? 특히 애플의 폐쇄적인 정책에 젯브레인 등이 고배를 마신 바 있어 닷넷 애플리케이션의 iOS 애플리케이션의 개발 및 배포에 애플이 얼마나 협조적인지 궁금합니다.
.NET MAUI는 iOS 앱을 개발하고 배포하는 데 필요한 Apple의 빌드 도구에 액세스해야 하므로, Visual Studio 2022는 .NET MAUI iOS 앱을 빌드하기 위해 네트워크에 연결된 Mac에 연결해야 합니다. 이를 위해 Apple의 정책과 지침을 따라야 합니다.
그러나 구글이나 애플과 같은 각 플랫폼의 관리 조직들의 협조 상태에 대한 정보를 찾지 못했습니다.</p>
<h3 id="references-3">References</h3>
<ol>
<li><a href="https://learn.microsoft.com/en-us/dotnet/maui/ios/pair-to-mac?view=net-maui-7.0">Pair to Mac for iOS development - .NET MAUI | Microsoft Learn</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/maui/ios/deployment/publish-app-store?view=net-maui-7.0">Publish a .NET MAUI iOS app for App Store distribution - .NET MAUI</a></li>
<li><a href="https://stackoverflow.com/questions/73556534/sign-in-with-apple-in-net-maui">c# - Sign in with Apple in .Net MAUI - Stack Overflow</a></li>
</ol>
<h2 id="launch-date-of-maui">Launch Date of MAUI</h2>
<p>MAUI는 본격적으로 베타테스트를 끝낸지 얼마 정도 된 도구입니까?
.NET MAUI는 현재 베타 테스트를 끝낸지 얼마 되지 않은 도구입니다. 하지만 정확한 날짜에 대한 정보를 찾지 못했습니다.</p>
<h3 id="references-4">References</h3>
<ol>
<li><a href="https://dotnet.microsoft.com/en-us/apps/maui">.NET Multi-platform App UI (.NET MAUI) | .NET</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/maui/deployment/?view=net-maui-7.0">Deployment - .NET MAUI | Microsoft Learn</a></li>
<li><a href="https://devblogs.microsoft.com/dotnet/introducing-the-net-maui-community-toolkit-preview/">Introducing the .NET MAUI Community Toolkit (Preview)</a></li>
</ol>
<h2 id="maui와-xamarinforms의-차이점">MAUI와 Xamarin.Forms의 차이점</h2>
<p>.NET MAUI는 Xamarin.Forms의 진화입니다. Xamarin.Forms는 모바일 앱 개발을 위한 크로스 플랫폼 프레임워크였습니다. .NET MAUI는 이를 확장하여 데스크탑 앱 개발도 지원하며 성능 및 확장성을 위해 UI 컨트롤이 처음부터 다시 구축되었습니다.
.NET MAUI는 단일 프로젝트 구조를 사용하여 여러 플랫폼에 대한 앱을 만들 수 있습니다. 이는 개발자가 하나의 코드베이스에서 여러 플랫폼에 대한 앱을 만들 수 있도록 지원하면서 각 플랫폼의 네이티브 기능과 성능을 최대한 활용할 수 있도록 지원하는 것입니다.
MAUI를 통해 제작되는 애플리케이션은 플러터와 같이 독립적인 UI를 구축합니까, 리액트 네이티브와 같이 플랫폼의 컨셉에 보다 친화적인 UI를 제공합니까?</p>
<p>.NET MAUI는 각 플랫폼의 네이티브 UI 컨트롤을 사용하여 앱을 구축합니다. 이는 앱이 각 플랫폼의 네이티브 느낌과 디자인 가이드라인을 따르도록 지원합니다.
.NET MAUI는 개발자가 하나의 코드베이스에서 여러 플랫폼에 대한 앱을 만들 수 있도록 지원하면서 각 플랫폼의 네이티브 기능과 성능을 최대한 활용할 수 있도록 지원하는 것입니다.
완벽하게 네이티브 친화적인 애플리케이션을 지향한다는 선언의 뜻이 이제 이해가 됩니다. 현재 MAUI로 만들어진 애플리케이션 중 iOS 대한민국 앱스토어 기준으로 사용 가능한 상업적인 애플리케이션에는 어떤 것이 있습니까? 아직 그러한 주목할 만한 앱이 없다면 101으로 제공하는 데모 애플리케이션의 링크를 제공해 주세요.
현재 대한민국 앱스토어에서 사용 가능한 상업적인 .NET MAUI 애플리케이션에 대한 정보를 찾지 못했습니다. 하지만 .NET MAUI는 새로운 프레임워크이므로 앞으로 더 많은 앱이 출시될 것으로 예상됩니다.
.NET MAUI의 공식 웹사이트에서는 .NET MAUI의 기능과 사용 방법을 보여주는 다양한 예제와 데모 애플리케이션이 제공됩니다. 이러한 예제와 데모 애플리케이션은 .NET MAUI의 공식 웹사이트에서 확인하실 수 있습니다.</p>
<h3 id="references-5">References</h3>
<ol>
<li><a href="https://learn.microsoft.com/en-us/dotnet/architecture/maui/">Enterprise Application Patterns Using .NET MAUI | Microsoft Learn</a></li>
<li><a href="https://devblogs.microsoft.com/dotnet/dotnet-maui-ebook-released/">.NET MAUI eBook Now Available - Enterprise Application Patterns</a></li>
<li><a href="https://dotnet.microsoft.com/en-us/apps/maui">.NET Multi-platform App UI (.NET MAUI) | .NET</a></li>
</ol>
<h2 id="ide-for-maui-development">IDE for MAUI Development</h2>
<p>MAUI를 사용한 개발은 어떤 IDE를 사용하는 것이 최적의 개발 경험을 제공합니까? 역시 Visual Code입니까? 어느 정도는 안드로이드 스튜디오와 XCode의 도움을 받아야 합니까?</p>
<p>.NET MAUI 앱 개발에는 Visual Studio 2022가 권장됩니다. Visual Studio 2022는 .NET MAUI 프로젝트 템플릿, 디버깅 및 배포 도구를 제공하여 개발자가 빠르게 시작할 수 있도록 지원합니다.
iOS 앱을 개발하려면 Apple의 빌드 도구에 액세스해야 하므로 Visual Studio 2022는 .NET MAUI iOS 앱을 빌드하기 위해 네트워크에  연결된 Mac에 연결해야 합니다. 이를 위해 Xcode가 설치되어 있어야 합니다.
Android 앱을 개발하려면 Android SDK와 Android Emulator가 필요합니다. 이들은 Visual Studio 2022 설치 중에 설치할 수 있습니다.</p>
<h2 id="global-share-of-maui-or-xamarinforms">Global Share of MAUI or Xamarin.Forms</h2>
<p>MAUI의 경우 아직 데이터가 많지 않을 것으로 예상되므로, 그의 전신인 Xamarin.Forms의 경우, 기존의 시장 점유율이나 개발자 선호도는 어느 정도였습니까?</p>
<p>Xamarin.Forms는 전 세계 개발자들이 사용하는 크로스 플랫폼 모바일 프레임워크 중 하나입니다. 하지만 시장 점유율이나 개발자 선호도에 대한 정확한 정보를 찾지 못했습니다.
.NET MAUI의 공식 웹사이트에서는 .NET MAUI의 기능과 사용 방법을 보여주는 다양한 예제와 데모 애플리케이션이 제공됩니다. 이러한 예제와 데모 애플리케이션은 .NET MAUI의 공식 웹사이트에서 확인하실 수 있습니다.</p>
<h3 id="references-6">References</h3>
<ol>
<li><a href="https://devblogs.microsoft.com/xamarin/persisting-settings-preferences-mobile-apps-xamarin-essentials/">Persisting Settings and Preferences in Mobile Apps with Xamarin.Essentials - Xamarin Blog</a></li>
<li><a href="https://www.statista.com/statistics/869224/worldwide-software-developer-working-hours/">Cross-platform mobile frameworks used by global developers 2021 - Statista</a></li>
<li><a href="https://learn.microsoft.com/en-us/xamarin/essentials/share">Xamarin.Essentials: Share - Xamarin | Microsoft Learn</a></li>
</ol>
<h2 id="what-is-others-saying-about-maui">What is Others saying about MAUI?</h2>
<p>답변의 레퍼런스로 대부분 마이크로소프트의 기술블로그 혹은 도큐먼트가 링크되고 있는데, 외부 기관이나 개발자 커뮤니티에서 평가하는 MAUI에 대한 평가 정보를 찾을 수 있습니까?</p>
<p>.NET MAUI는 새로운 프레임워크이므로 외부   기관이나 개발자 커뮤니티에서의 평가 정보가 제한적입니다. 하지만 일부 개발자들은 .NET MAUI가 너무 이른 시기에 출시되었다고 느끼며 기능이 미완성된 상태라고 지적하고 있습니다.
.NET MAUI는 지속적으로 개발되고 있으며 앞으로 더 많은 개선이 이루어질 것으로 예상됩니다. .NET MAUI 커뮤니티 툴킷 (Preview)와 같은 커뮤니티에서 제공하는 확장 기능도 있습니다.</p>
<h3 id="references-7">References</h3>
<ol>
<li><a href="https://visualstudiomagazine.com/articles/2022/09/29/net-maui-complaints.aspx">Did .NET MAUI Ship Too Soon? Devs Sound Off on &#x27;Massive Mistake&#x27;</a></li>
<li><a href="https://devblogs.microsoft.com/dotnet/introducing-the-net-maui-community-toolkit-preview/">Introducing the .NET MAUI Community Toolkit (Preview)</a></li>
<li><a href="https://slashdot.org/software/p/.NET-MAUI/">.NET MAUI Reviews - 2023 - Slashdot</a></li>
</ol>
<p>MAUI와 Xamarin.Forms의 관계에 대해, Xamarin의 라이프사이클이 종료되면 MAUI가 그 역할을 대신할 수 있을 정도의 슈퍼셋과 같은 관계입니까, 리부트 개념으로 새롭게 개발된 완전한 별개의 도구입니까?</p>
<p>.NET MAUI는 Xamarin.Forms의 진화입니다. Xamarin.Forms는 모바일 앱 개발을 위한 크로스 플랫폼 프레임워크였습니다. .NET MAUI는 이를 확장하여 데스크탑 앱 개발도 지원하며 성능 및 확장성을 위해 UI 컨트롤이 처음부터 다시 구축되었습니다.
.NET MAUI는 Xamarin.Forms의 코드베이스를 기반으로 하지만 새로운 기능과 개선 사항이 추가되어 완전히 새로운 프레임워크로 발전하였습니다. 따라서 .NET MAUI는 Xamarin.Forms의 슈퍼셋이라고 볼 수 있습니다.
일부에서 MAUI가 아직 실험적 단계라고 지적하는 이유는 무엇입니까? Xamarin.Forms 만으로 충분히 모바일 크로스플랫폼 개발에서 역할을 수행하고 있었다면 이러한 지적은 데스크톱 개발의 부족함에 대한 지적입니까? Xamarin.Forms부터 이어져 온 특유의 고질병입니까?</p>
<p>.NET MAUI는 새로운 프레임워크이므로 일부 개발자들은 아직 실험적 단계라고 지적할 수 있습니다. 모든 새로운 프레임워크는 초기에 버그와 문제가 발생할 수 있으며 지속적인 개선이 필요합니다.
Xamarin.Forms는 모바일 앱 개발을 위한 크로스 플랫폼 프레임워크였습니다. .NET MAUI는 이를 확장하여 데스크탑 앱 개발도 지원하며 성능 및 확장성을 위해 UI 컨트롤이 처음부터 다시 구축되었습니다. 따라서 .NET MAUI는 Xamarin.Forms의 기능을 계승하면서 데스크탑 앱 개발을 지원하는 새로운 프레임워크입니다.
MAUI의 컨셉을 중심으로 생각하면, 특히 어떤 성격의 비즈니스에서 가장 효과적으로 성능을 발휘할 수 있는 엔지니어링 도구라고 할 수 있습니까? 나는 닷넷이 빠른 성능으로 게임 개발에 많이 쓰여온 것을 알고 있습니다. 닷넷 개발자 출신이라면 누구라도 쉽게 시작할 수 있을 만한 유사한 개발경험을 제공하는지도 궁금합니다.
.NET MAUI는 다양한 종류의 비즈니스에서 사용될 수 있습니다. .NET MAUI는 개발자가 하나의 코드베이스에서 여러 플랫폼에 대한 앱을 만들 수 있도록 지원하면서 각 플랫폼의 네이티브 기능과 성능을 최대한 활용할 수 있도록 지원하는 것입니다. 따라서 .NET MAUI는 다양한 종류의 앱을 만들 수 있습니다.
.NET 개발자라면 .NET MAUI를 사용하여 앱을 개발하는 데 쉽게 시작할 수 있습니다. .NET MAUI는 C#과 XAML을 사용하여 앱을 만들 수 있으며 .NET 개발자에게 익숙한 개발 경험을 제공합니다.
XAML은 DTD나 XML과 같이 &lt;&gt;로 감싸진 태그로 작성되어 지는 언어입니까?</p>
<p>XAML은 eXtensible Application Markup Language의 약자로, XML 기반의 선언적 마크업 언어입니다. XAML은 애플리케이션의 UI를 정의하는 데 사용되며, XML과 유사한 구조를 가지고 있습니다.
XAML에서는 요소와 속성을 사용하여 UI를 정의합니다. 요소는 &lt;&gt;로 감싸진 태그로 작성되며, 속성은 태그 내부에서 이름=값 형태로 작성됩니다.
MAUI의 애플리케이션의 예제에서 XAML 코드의 예제를 보고 싶습니다. 간단한 예제를 제공할 수 있습니까?</p>
<p>간단한 .NET MAUI 애플리케이션의 XAML 코드 예제를 제공해 드리겠습니다.
다음은 간단한 &quot;Hello, World!&quot; 앱의 XAML 코드 예제입니다.</p>
<pre><code class="language-xml">&lt;ContentPage xmlns=&quot;http://schemas.microsoft.com/dotnet/2021/maui&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
             x:Class=&quot;HelloWorld.MainPage&quot;&gt;
    &lt;StackLayout&gt;
        &lt;Label Text=&quot;Welcome to .NET MAUI!&quot;
            VerticalOptions=&quot;CenterAndExpand&quot; 
            HorizontalOptions=&quot;CenterAndExpand&quot; /&gt;
    &lt;/StackLayout&gt;
&lt;/ContentPage&gt;
</code></pre>
<p>이 코드는 <code>ContentPage</code> 요소를 사용하여 페이지를 정의하고 있습니다. StackLayout<code>요소는 페이지 내부의 레이아웃을 정의하며,</code>Label` 요소는 텍스트를 표시하는 데 사용됩니다.
MAUI 개발에서 모든 UI 관련 코드는 XAML로 작성되어진다고 봐도 무방합니까?</p>
<p>.NET MAUI에서는 UI를 정의하는 데 XAML을 사용할 수 있지만 필수는 아닙니다. 개발자는 C# 코드로도 UI를 정의할 수 있습니다.
XAML은 선언적 마크업 언어로, UI를 정의하는 데 사용하기 쉽고 직관적입니다. XAML을 사용하면 디자이너와 개발자가 협업하기 쉬워지며, UI와 로직을 분리하여 코드의 가독성  이 향상됩니다.
하지만 개발자가 원한다면 C# 코드로도 UI를 정의할 수 있습니다. 이 경우에는 코드로 UI 요소를 생성하고 레이아웃을 정의해야 합니다.
따라서 .NET MAUI 개발에서 모든 UI 관련 코드가 XAML로 작성되는 것은 아닙니다. 개발자가 선택한 방법에 따라 XAML 또는 C# 코드로 UI를 정의할 수 있습니다.
위와 같은 기능의 &quot;Hello, World!&quot; 앱의 C# 코드 버전을 보여주실 수 있습니까?</p>
<p>간단한 &quot;Hello, World!&quot; 앱의 C# 코드 예제를 제공해 드리겠습니다.
다음은 MainPage.xaml.cs 파일의 코드 예제입니다.</p>
<pre><code class="language-csharp">
using Microsoft.Maui.Controls;
namespace HelloWorld
{
    public partial class MainPage : ContentPage
    {
        public MainPage()
        {
            InitializeComponent();
            var stackLayout = new StackLayout();
            var label = new Label
            {
                Text = &quot;Welcome to .NET MAUI!&quot;,
                HorizontalOptions = LayoutOptions.CenterAndExpand,
                VerticalOptions = LayoutOptions.CenterAndExpand
            };
            stackLayout.Children.Add(label);
            Content = stackLayout;
        }
    }
}
</code></pre>
<p>이 코드는 <code>ContentPage</code> 클래스를 상속받아 페이지를 정의하고 있습니다. <code>StackLayout</code> 클래스와 <code>Label</code> 클래스를 사용하여 레이아웃과 텍스트를 정의하고 있습니다.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="이미지의 URL을 브라우저에 입력하고 엔터를 눌렀을 때 일어나는 일"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/en/blog/http-request-response-format-http-request-response">HTTP 요청/응답 형식, HTTP Request/Response</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-04-06T00:00:00.000Z" itemprop="datePublished">April 6, 2023</time> · <!-- -->5 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="이미지의-url을-브라우저에-입력하고-엔터를-눌렀을-때-일어나는-일">이미지의 URL을 브라우저에 입력하고 엔터를 눌렀을 때 일어나는 일</h2>
<p>이미지의 URL을 브라우저에 입력하고 엔터를 누르면 브라우저는 해당 URL로 HTTP 요청을 보냅니다. 이 때 HTTP 요청의 header는 다음과 같은 정보를 포함합니다:</p>
<ul>
<li>Request Method : GET</li>
<li>Request URL : 입력한 URL</li>
<li>Request Headers :</li>
<li>Accept : text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,<em>/</em>;q=0.8</li>
<li>Accept-Encoding : gzip, deflate, br</li>
<li>Accept-Language : ko-KR,ko;q=0.8,en-US;q=0.5,en;q=0.3</li>
<li>Connection : keep-alive</li>
<li>Host : 입력한 URL의 호스트 이름</li>
<li>Referer : 이전 페이지의 URL (이전 페이지가 없으면 생략)</li>
<li>User-Agent : 브라우저 정보</li>
</ul>
<p>요청 헤더에는 클라이언트가 서버에게 전달하는 정보가 포함되어 있습니다.</p>
<h3 id="references">References</h3>
<ol>
<li><a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Headers">HTTP 헤더 - HTTP | MDN - Mozilla Developer</a></li>
<li><a href="https://gmlwjd9405.github.io/2019/01/28/http-header-types.html">[Network] HTTP 헤더의 종류 및 항목 - Heee&#x27;s Development Blog</a></li>
<li><a href="https://aws.amazon.com/ko/blogs/korea/what-happens-when-you-type-a-url-into-your-browser/">웹 브라우저에 URL을 입력하면 어떤 일이 생기나요? | Amazon Web ...</a>
HTTP 요청 헤더는 HTTP 요청 메시지의 일부로, 클라이언트가 서버로 보내는 요청에 대한 추가 정보를 포함합니다. HTTP 요청 헤더는 키-값 쌍 형태로 구성되며, 반드시 포함되어야 하는 정보는 없습니다. 하지만 일반적으로 HTTP 요청 헤더에는 다음과 같은 정보가 포함됩니다:</li>
</ol>
<ul>
<li>Accept : 클라이언트가 받아들일 수 있는 미디어 타입</li>
<li>Accept-Encoding : 클라이언트가 받아들일 수 있는 인코딩 방식</li>
<li>Accept-Language : 클라이언트가 받아들일 수 있는 언어</li>
<li>Connection : 클라이언트와 서버 간의 연결 유지 방법</li>
<li>Host : 요청을 보내는 호스트 이름</li>
<li>Referer : 이전 페이지의 URL (이전 페이지가 없으면 생략)</li>
<li>User-Agent : 클라이언트의 브라우저 정보</li>
</ul>
<p>요청 헤더에는 클라이언트가 서버에게 전달하는 정보가 포함되어 있습니다.</p>
<h3 id="references-1">References</h3>
<ol>
<li><a href="https://velog.io/@yunsu0928/HTTP-HTTPS">HTTP / HTTPS</a></li>
<li><a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Headers">HTTP 헤더 - HTTP | MDN - Mozilla Developer</a></li>
<li><a href="https://gmlwjd9405.github.io/2019/01/28/http-header-types.html">[Network] HTTP 헤더의 종류 및 항목 - Heee&#x27;s Development Blog</a></li>
<li><a href="https://wonit.tistory.com/310">[HTTP-Header] HTTP Request Header :: 요청 헤더</a></li>
</ol>
<p>HTTP GET  메소드로 이미지의 URL에 HTTP 요청을 보낼 때, 헤더는 다음과 같이 구성됩니다:</p>
<ul>
<li>Host : 요청을 보내는 호스트 이름</li>
<li>User-Agent : 클라이언트의 브라우저 정보</li>
<li>Accept : 클라이언트가 받아들일 수 있는 미디어 타입</li>
<li>Accept-Language : 클라이언트가 받아들일 수 있는 언어</li>
<li>Accept-Encoding : 클라이언트가 받아들일 수 있는 인코딩 방식</li>
</ul>
<p>하지만 이미지의 확장자를 알 수 없다면, Accept 헤더에 모든 미디어 타입을 포함시키는 것이 좋습니다. 예를 들어, 다음과 같은 헤더를 사용할 수 있습니다:</p>
<pre><code class="language-plaintext">Accept: */*
</code></pre>
<h3 id="references-2">References</h3>
<ol>
<li><a href="https://living-only-today.tistory.com/366">HTTP HEAD 메소드</a></li>
<li><a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Methods">HTTP 요청 메서드 - HTTP | MDN - Mozilla Developer</a></li>
<li><a href="https://zorba91.tistory.com/136">HTTP 요청 메소드 정리 :: Carry On Progamming</a></li>
<li><a href="https://an-ju-seong-coding.tistory.com/32">파이썬 requests 모듈로 HTTP 메소드(GET,POST,PUT 등)</a></li>
</ol>
<p>User-Agent 값은 브라우저와 디바이스 등 사용자 소프트웨어의 식별 정보를 담고 있는 request header의 한 종류입니다. User-Agent 값은 보통 HTTP 요청 에러가 발생했을 때 요청을 보낸 사용자 환경을 알아보기 위해 사용됩니다. 가장 보편적으로 쓰이는 User-Agent 값은 다음과 같습니다:</p>
<p>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 Edge/16.16299</p>
<p>하지만 User-Agent 값은 브라우저마다 다르게 설정될 수 있으므로, 정확한 User-Agent 값을 확인하려면 브라우저에서 navigator.userAgent 값을 확인하는 것이 좋습니다.</p>
<h3 id="references-3">References</h3>
<ol>
<li><a href="https://velog.io/@ggong/User-agent-%EC%A0%95%ED%99%95%ED%95%98%EA%B2%8C-%ED%95%B4%EC%84%9D%ED%95%98%EA%B8%B0">User-agent 정확하게 해석하기</a></li>
<li><a href="https://ohgyun.com/292">User Agent 파헤치기 (navigator.userAgent) - 꿀벌개발일지</a></li>
<li><a href="https://d2.naver.com/helloworld/6532276">User-Agent Client Hints의 도입, UA 프리징을 대비하라</a></li>
</ol></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="리액트 네이티브의 글로벌 상태 관리 라이브러리"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/en/blog/react-native-global-state-management-library">React Native 글로벌 상태 관리 라이브러리</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-04-06T00:00:00.000Z" itemprop="datePublished">April 6, 2023</time> · <!-- -->21 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="리액트-네이티브의-글로벌-상태-관리-라이브러리">리액트 네이티브의 글로벌 상태 관리 라이브러리</h2>
<p>React Native 모바일 애플리케이션에서 주로 사용되는 글로벌 상태 관리 라이브러리로는 다음과 같은 것들이 있습니다:</p>
<ol>
<li><strong>Redux</strong>: 가장 널리 사용되는 상태 관리 라이브러리 중 하나로, 전역 상태를 관리하는 중앙 저장소를 제공합니다. Redux는 단방향 데이터 흐름을 가지며, 상태 변경은 순수 함수인 리듀서를 통해 수행됩니다. Redux의 장점으로는 예측 가능한 상태 변경, 개발 도구 지원, 커뮤니티 지원 등이 있습니다. 단점으로는 초기 설정이 복잡하고, 보일러플레이트 코드가 많다는 점이 있습니다.</li>
<li><strong>MobX</strong>: 관찰 가능한 상태 트리를 사용하여 상태 관리를 수행하는 라이브러리입니다. MobX는 자동으로 상태 변경을 추적하고 필요한 컴포넌트만 리렌더링합니다. MobX의 장점으로는 간단한 API, 높은 성능 등이 있습니다. 단점으로는 디버깅이 어렵다는 점이 있습니다.</li>
<li><strong>Context API</strong>: React에 내장된 상태 관리 기능으로, 전역 상태를 관리할 수 있습니다. Context API는 중첩된 컴포넌트 구조에서 상위 컴포넌트의 상태를 하위 컴포넌트에 전달하는 데 유용합니다. Context API의 장점으로는 추가적인 라이브러리 설치가 필요 없다는 점이 있습니다. 단점으로는 복잡한 상태 관리에 적합하지 않다는 점이 있습니다.</li>
<li><strong>Recoil</strong>: Facebook에서 개발한 상태 관리 라이브러리로, Atom과 Selector라는 개념을 사용하여 상태 관리를 수행합니다. Recoil은 React의 기능과 밀접하게 연결되어 있으며, 복잡한 상태 의존성을 쉽게 관리할 수 있습니다. Recoil의 장점으로는 간단한 API, 높은 성능 등이 있습니다.</li>
<li><strong>React Query</strong>: 서버 데이터를 캐싱하고 동기화하는 데 사용되는 라이브러리입니다. React Query는 서버 데이터와 관련된 로직을 쉽게 구현할 수 있도록 도와줍니다. React Query의 장점  으로는 간단한 API, 자동 캐싱 및 리패칭 등이 있습니다.</li>
</ol>
<p>각 라이브러리마다 특징과 장단점이 다르므로 프로젝트의 요구사항에 따라 적합한 라이브러리를 선택하는 것이 좋습니다.</p>
<h3 id="references">References</h3>
<ol>
<li><a href="https://www.stevy.dev/react-state-management-guide/">리액트 상태 관리 가이드 | Stevy&#x27;s wavyLog</a></li>
<li><a href="https://dori-coding.tistory.com/entry/React-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%96%B4%EB%96%A4%EA%B1%B8-%EC%8D%A8%EC%95%BC%ED%95%A0%EA%B9%8C">[React] 상태관리 라이브러리 어떤걸 써야할까?</a></li>
<li><a href="https://wit.nts-corp.com/2020/03/23/6014">React Native UI 개발 시작하기 | WIT블로그</a></li>
<li><a href="https://velog.io/@danmin20/%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EB%AD%98-%EC%93%B8%EA%B9%8C">상태관리 라이브러리, 뭘 쓸까?</a></li>
</ol>
<h2 id="리덕스와-리코일">리덕스와 리코일</h2>
<p>Redux와 Recoil 모두 Facebook에서 개발한 상태 관리 도구입니다.
Redux는 Flux 아키텍처를 기반으로 한 상태 관리 라이브러리로, 전역 상태를 중앙 저장소에서 관리합니다. Redux는 단방향 데이터 흐름을 가지며, 상태 변경은 순수 함수인 리듀서를 통해 수행됩니다. Redux의 장점으로는 예측 가능한 상태 변경, 개발 도구 지원, 커뮤니티 지원 등이 있습니다. 단점으로는 초기 설정이 복잡하고, 보일러플레이트 코드가 많다는 점이 있습니다.
Recoil은 Facebook에서 최근 개발한 상태 관리 라이브러리로, Atom과 Selector라는 개념을 사용하여 상태 관리를 수행합니다. Recoil은 React의 기능과 밀접하게 연결되어 있으며, 복잡한 상태 의존성을 쉽게 관리할 수 있습니다. Recoil의 장점으로는 간단한 API, 높은 성능 등이 있습니다.
Redux와 Recoil의 가  장 큰 차이점은 상태 관리 방식입니다. Redux는 중앙 저장소에서 전역 상태를 관리하는 반면, Recoil은 Atom과 Selector를 사용하여 상태 관리를 수행합니다. 또한 Recoil은 React의 기능과 밀접하게 연결되어 있어서 React와의 호환성이 높습니다.</p>
<h3 id="references-1">References</h3>
<ol>
<li><a href="https://velog.io/@fltxld3/Redux-%EC%99%80-Recoil-%EB%B9%84%EA%B5%90">Redux 와 Recoil 비교</a></li>
<li><a href="https://songzerotwo.tistory.com/entry/TIL-Redux%EC%99%80-Recoil-%EB%B9%84%EA%B5%90">[TIL] Redux와 Recoil 비교</a></li>
<li><a href="https://mmsesang.tistory.com/entry/2021%EB%85%84-React-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%A0%84%EC%9F%81-Hooks-Redux-Recoil">2021년 React 상태 관리 라이브러리 전쟁 : Hooks, Redux, Recoil</a></li>
<li><a href="https://velog.io/@woals3000/Redux-vs-Recoil">Redux vs Recoil - velog</a></li>
</ol>
<h2 id="리코일의-atom과-selector">리코일의 Atom과 Selector</h2>
<p>Recoil은 Atom과 Selector라는 개념을 사용하여 상태 관리를 수행합니다. Atom은 상태의 단위로, 업데이트와 구독이 가능합니다. 컴포넌트는 Atom을 구독하고, Atom이 업데이트되면 구독한 컴포넌트만 리렌더링됩니다. Selector는 Atom이나 다른 Selector를 입력으로 받는 순수 함수로, 상태를 기반으로 데이터를 계산합니다.
Recoil은 전역 상태 관리를 위한 라이브러리로, 각 컴포넌트나 페이지 레벨에서 상태 관리를 수행할 수 있습니다. Recoil을 사용하면 전역 상태를 쉽게 관리할 수 있으며, 복잡한 상태 의존성도 쉽게 관리할 수 있습니다.
Recoil에서 Atom과 Selector는 상태 관리를 수행하는 데 사용되는 개념입니다.
Atom은 상태의 단위로, 업데이트와 구독이 가능합니다. Atom은 고유한 키를 가지며, 이 키는 전역적으로 고유해야 합니다. 컴포넌트는 Atom을 구독하고, Atom이 업데이트되면 구독한 컴포넌트만 리렌더링됩니다. Atom은 useRecoilState라는 훅을 사용하여 읽고 쓸 수 있습니다.
Selector는 Atom이나 다른 Selector를 입력으로 받는 순수 함수로, 상태를 기반으로 데이터를 계산합니다. Selector는 상위 Atom이나 Selector가 업데이트될 경우 하위 Selector도 재실행됩니다. 컴포넌트는 Atom 뿐만 아니라 Selector도 구독할 수 있으며, 구독하고 있는 Selector가 변경되면 구독한 컴포넌트도 리렌더링됩니다. Selector는 useRecoilValue라는 훅을 사용하여 조회할 수 있습니다.
간단히 말하면, Atom은 상태의 단위이며 업데이트와 구독이 가능하고, Selector는 상태를 기반으로 데이터를 계산하는 순수 함수입니다.
Recoil을 사용하여 Pedometer 데이터를 관리하는 타입스크립트 리액트 네이티브 예제는 다음과 같습니다:</p>
<pre><code class="language-tsx">import React, { useEffect } from &quot;react&quot;;
import { View, Text } from &quot;react-native&quot;;
import { atom, useRecoilState } from &quot;recoil&quot;;
import { Pedometer } from &quot;expo-sensors&quot;;
// Atom 정의
const stepsState = atom({
  key: &quot;stepsState&quot;,
  default: 0,
});
const PedometerComponent = () =&gt; {
  const [steps, setSteps] = useRecoilState(stepsState);
  useEffect(() =&gt; {
    // Pedometer 데이터 구독
    Pedometer.watchStepCount((result) =&gt; {
      setSteps(result.steps);
    });
    return () =&gt; {
      // 구독 취소
      Pedometer.stopWatchingStepCount();
    };
  }, []);
  return (
    &lt;View&gt;
            &lt;Text&gt;Steps: {steps}&lt;/Text&gt;   {&quot; &quot;}
    &lt;/View&gt;
  );
};
export default PedometerComponent;
</code></pre>
<p>위 예제에서는 <code>stepsState</code>라는 Atom을 정의하고 있습니다. 이 Atom은 걸음 수를 저장하는 데 사용됩니다.
<code>PedometerComponent</code> 컴포넌트에서는 <code>useRecoilState</code> 훅을 사용하여 <code>stepsState</code> Atom의 값을 읽고 쓸 수 있습니다. <code>useEffect</code> 훅을 사용하여 Pedometer 데이터를 구독하고, 데이터가 변경될 때마다 <code>setSteps</code> 함수를 호출하여 <code>stepsState</code> Atom의 값을 업데이트합니다.
이 예제에서는 Recoil의 상태 관리 시스템이 어떻게 작동하는지 확인할 수 있습니다. 사용자가 걸어갈 때마다 네이티브 이벤트 에밋터로부터 Pedometer 데이터를 수신하고, 변경된 데이터를 Recoil로 업데이트합니다.
Recoil의 <code>useRecoilState</code> 훅은 React의 <code>useState</code> 훅과 유사한 인터페이스를 가지고 있습니다. 그러나 Recoil의 상태 관리는 전역적으로 수행되며, 상태 변경 사항은 동일한 컴포넌트 뿐만 아니라 다른 컴포넌트에서도 적용됩니다.
Recoil을 사용하면 전역 상태를 쉽게 관리할 수 있습니다. Atom을 정의하고, 컴포넌트에서 <code>useRecoilState</code> 훅을 사용하여 Atom의 값을 읽고 쓸 수 있습니다. Atom이 업데이트되면 구독한 모든 컴포넌트가 리렌더링됩니다.
따라서 Recoil의 상태 관리는 useState와 다르게 전역적으로 수행되며, 하위 컴포넌트에 데이터를 전달하는 등의 기능도 수행할 수 있습니다.</p>
<h2 id="리코일에서-비동기-처리-수행하기">리코일에서 비동기 처리 수행하기</h2>
<p>Recoil에서 비동기 처리를 수행하는 방법은 여러 가지가 있습니다. 가장 일반적인 방법은 Selector를 사용하는 것입니다.
Selector는 Atom이나 다른 Selector를 입력으로 받는 순수 함수로, 상태를 기반으로 데이터를 계산합니다. Selector의 <code>get</code> 속성에는 계산될 함수를 정의할 수 있습니다. 이 함수에서 비동기 처리를 수행할 수 있습니다.
예를 들어, 다음과 같이 비동기 처리를 수행하는 Selector를 정의할 수 있습니다:</p>
<pre><code class="language-javascript">const currentUserIDState = atom({
  key: &quot;CurrentUserID&quot;,
  default: null,
});
const currentUserNameQuery = selector({
  key: &quot;CurrentUserName&quot;,
  get: async ({ get }) =&gt; {
    const response = await myDBQuery({
      userID: get(currentUserIDState),
    });
    return response.name;
  },
});
</code></pre>
<p>위 예제에서 <code>currentUserNameQuery</code>라는 Selector는 <code>currentUserIDState</code> Atom을 입력으로 받아서 비동기 처리를 수행합니다. <code>get</code> 함수를 사용하여 <code>currentUserIDState</code> Atom의 값을 조회하고, 이 값을 사용하여 데이터베이스 쿼리를 수행합니다.
컴포넌트에서는 <code>useRecoilValueLoadable</code> 훅을 사용하여 Selector의 상태와 값을 조회할 수 있습니다. 이 훅은 Loadable 객체를 반환하며, Loadable 객체의 상태에 따라 컴포넌트에서 적절한 처리를 수행할 수 있습니다.
예를 들어, 다음과 같이 컴포넌트에서 비동기 처리 상태를 표시할 수 있습니다:</p>
<pre><code class="language-javascript">function CurrentUserName() {
  const userNameLoadable = useRecoilValueLoadable(currentUserNameQuery);
  switch (userNameLoadable.state) {
    case &quot;hasValue&quot;:
      return &lt;div&gt;{userNameLoadable.contents}&lt;/div&gt;;
    case &quot;loading&quot;:
      return &lt;div&gt;Loading...&lt;/div&gt;;
    case &quot;hasError&quot;:
      throw userNameLoadable.contents;
  }
}
</code></pre>
<p>위 예제에서 <code>CurrentUserName</code> 컴포넌트는 <code>useRecoilValueLoadable</code> 훅을 사용하여 <code>currentUserNameQuery</code> Selector의 상태와 값을 조회합니다. Loadable 객체의 상태에 따라 컴포넌트에서 적절한 처리를 수행합니다.
이 외에도 Recoil에서는 Suspense와 ErrorBoundary를 사용하여 비동기 처리 상태를 표시할 수도 있습니다.
Suspense와 ErrorBoundary는 React에서 비동기 처리 상태를 표시하는 데 사용되는 컴포넌트입니다.
Suspense는 컴포넌트가 로딩 중일 때 로딩 표시자를 표시하는 데 사용됩니다. Suspense 컴포넌트는 <code>fallback</code> prop을 사용하여 로딩 표시자를 지정할 수 있습니다. Suspense 컴포넌트의 자식 컴포넌트에서 비동기 처리가 수행되면, Suspense 컴포넌트는 자동으로 로딩 표시자를 표시합니다.
예를 들어, 다음과 같이 Suspense 컴포넌트를 사용하여 비동기 처리 상태를 표시할 수 있습니다:</p>
<pre><code class="language-javascript">import React, { Suspense } from &quot;react&quot;;
function UserProfile({ userID }) {
  return (
    &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
            &lt;ProfileDetails userID={userID} /&gt;
            &lt;ProfilePosts userID={userID} /&gt;   {&quot; &quot;}
    &lt;/Suspense&gt;
  );
}
</code></pre>
<p>위 예제에서 <code>UserProfile</code> 컴포넌트는 Suspense 컴포넌트를 사용하여 비동기 처리 상태를 표시합니다. <code>ProfileDetails</code>와 <code>ProfilePosts</code> 컴포넌트에서 비동기 처리가 수행되면, Suspense 컴포넌트는 자동으로 로딩 표시자를 표시합니다.
ErrorBoundary는 컴포넌트에서 발생한 오류를 처리하는 데 사용됩니다. ErrorBoundary 컴포넌트는 <code>componentDidCatch</code> 라이프사이클 메서드나 <code>getDerivedStateFromError</code> 정적 메서드를 구현하여 오류를 처리할 수 있습니다.
예를 들어, 다음과 같이 ErrorBoundary 컴포넌트를 사용하여 오류를 처리할 수 있습니다:</p>
<pre><code class="language-javascript">import React from &quot;react&quot;;
class ErrorBoundary extends React.Component {
  state = { hasError: false };
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  componentDidCatch(error, errorInfo) {
    // 오류 정보를 로깅
    logErrorToMyService(error, errorInfo);
  }
  render() {
    if (this.state.hasError) {
      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;
    }
    return this.props.children;
  }
}
</code></pre>
<p>위 예제에서 <code>ErrorBoundary</code> 컴포넌트는 <code>getDerivedStateFromError</code> 정적 메서드와 <code>componentDidCatch</code> 라이프사이클 메서드를 구현하여 오류를 처리합니다. 자식 컴포넌트에서 오류가 발생하면, <code>ErrorBoundary</code> 컴포넌트는 오류 정보를 로깅하고 오류 메시지를 표시합니다.
Suspense와 ErrorBoundary는 Recoil에서도 사용할 수 있습니다. Recoil의 Selector에서 비동기 처리가 수행되면, Suspense와 ErrorBoundary 컴포넌트를 사용하여 비동기 처리 상태와 오류 상태를 쉽게 표시할 수 있습니다.
Recoil에서 <code>useRecoilState</code>와 <code>useRecoilValue</code>는 Atom이나 Selector의 값을 조회하는 데 사용되는 훅입니다.
<code>useRecoilState</code> 훅은 Atom이나 읽기/쓰기 가능한 Selector의 값을 조회하고 업데이트하는 데 사용됩니다. 이 훅은 <code>[value, setValue]</code> 형태의 배열을 반환하며, <code>value</code>는 Atom이나 Selector의 현재 값이고, <code>setValue</code>는 Atom이나 Selector의 값을 업데이트하는 함수입니다.
예를 들어, 다음과 같이 <code>useRecoilState</code> 훅을 사용하여 Atom의 값을 조회하고 업데이트할 수 있습니다:</p>
<pre><code class="language-jsx">import React from &quot;react&quot;;
import { atom, useRecoilState } from &quot;recoil&quot;;
const textState = atom({
  key: &quot;textState&quot;,
  default: &quot;&quot;,
});
function TextInput() {
  const [text, setText] = useRecoilState(textState);
  const onChange = (event) =&gt; {
    setText(event.target.value);
  };
  return (
    &lt;div&gt;
            &lt;input type=&quot;text&quot; value={text} onChange={onChange} /&gt;
            &lt;br /&gt;      Echo: {text}   {&quot; &quot;}
    &lt;/div&gt;
  );
}
</code></pre>
<p>위 예제에서 <code>TextInput</code> 컴포넌트는 <code>useRecoilState</code> 훅을 사용하여 <code>textState</code> Atom의 값을 조회하고 업데이트합니다. <code>setText</code> 함수를 호출하여 <code>textState</code> Atom의 값을 업데이트할 수 있습니다.
<code>useRecoilValue</code> 훅은 Atom이나 Selector의 값을 조회하는 데 사용됩니다. 이 훅은 Atom이나 Selector의 현재 값을 반환합니다.
예를 들어, 다음과 같이 <code>useRecoilValue</code> 훅을 사용하여 Atom의 값을 조회할 수 있습니다:</p>
<pre><code class="language-javascript">import React from &quot;react&quot;;
import { atom, useRecoilValue } from &quot;recoil&quot;;
const textState = atom({
  key: &quot;textState&quot;,
  default: &quot;&quot;,
});
function TextDisplay() {
  const text = useRecoilValue(textState);
  return &lt;div&gt;Echo: {text}&lt;/div&gt;;
}
</code></pre>
<p>위 예제에서 <code>TextDisplay</code> 컴포넌트는 <code>useRecoilValue</code> 훅을 사용하여 <code>textState</code> Atom의 값을 조회합니다.
간단히 말하면, <code>useRecoilState</code> 훅은 Atom이나 읽기/쓰기 가능한 Selector의 값을 조회하고 업데이트하는 데 사용되며 <code>[value, setValue]</code> 형태의 배열을 반환합니다. 반면에 <code>useRecoilValue</code> 훅은 Atom이나 Selector의 값을 조회하는 데 사용되며 Atom이나 Selector의 현재 값을 반환합니다.
Recoil의 Selector는 기본적으로 읽기 전용입니다. Selector는 Atom이나 다른 Selector를 입력으로 받는 순수 함수로, 상태를 기반으로 데이터를 계산합니다. Selector의 <code>get</code> 속성에는 계산될 함수를 정의할 수 있습니다.
읽기 전용 Selector는 다음과 같이 정의할 수 있습니다:</p>
<pre><code class="language-javascript">const charCountState = selector({
  key: &quot;charCountState&quot;,
  get: ({ get }) =&gt; {
    const text = get(textState);
    return text.length;
  },
});
</code></pre>
<p>위 예제에서 <code>charCountState</code>라는 Selector는 <code>textState</code> Atom을 입력으로 받아서 문자열의 길이를 계산합니다. 이 Selector는 읽기 전용이므로 값을 조회하는 것만 가능합니다.</p>
<h2 id="writable-and-read-write-selectors">Writable and Read-Write Selectors</h2>
<p>읽기/쓰기 가능한 Selector는 <code>set</code> 속성을 추가하여 정의할 수 있습니다. <code>set</code> 속성에는 값을 업데이트하는 함수를 정의할 수 있습니다. 읽기/쓰기 가능한 Selector는 다음과 같이 정의할 수 있습니다:</p>
<pre><code class="language-javascript">const uppercaseTextState = selector({
  key: &quot;uppercaseTextState&quot;,
  get: ({ get }) =&gt; {
    const text = get(textState);
    return text.toUpperCase();
  },
  set: ({ set }, newValue) =&gt; {
    set(textState, newValue);
  },
});
</code></pre>
<p>위 예제에서 <code>uppercaseTextState</code>라는 Selector는 <code>textState</code> Atom을 입력으로 받아서 대문자로 변환된 문자열을 반환합니다. 이 Selector는 <code>set</code> 속성을 정의하고 있으므로 읽기/쓰기 가능합니다.
간단히 말하면, 읽기 전용 Selector와 읽기/쓰기 가능한 Selector의 차이점은 <code>set</code> 속성의 유무입니다. 읽기 전용 Selector는 <code>get</code> 속성만 정의하고 있으며 값을 조회하는 것만 가능합니다. 반면에 읽기/쓰기 가능한 Selector는 <code>set</code> 속성도 정의하고 있어서 값을 업데이트하는 것도 가능합니다.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="What is RNPM?"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/en/blog/react-native-package-manager">React Native Package Manager</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-04-06T00:00:00.000Z" itemprop="datePublished">April 6, 2023</time> · <!-- -->8 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="what-is-rnpm">What is RNPM?</h2>
<p>rnpm은 <strong>React Native Package Manager</strong>로, 일상적인 React Native 개발을 용이하게 하기 위해 만들어진 패키지 매니저입니다. CocoaPods, fastlane 및 react-native link에서 영감을 받아 네이티브의 미지의 영역을 안내하는 당신의 최고의 친구 역할을 합니다. 거의 모든 패키지와 함께 작동하도록 설계되어 추가 구성이 필요하지 않습니다.
rnpm은 이제 React Native 코어에 병합되었으므로 이제는 선호하는 연결 기능을 사용하기 위해 타사 소프트웨어를 설치할 필요가 없습니다. 대신 react-native cli를 사용하면 됩니다.</p>
<h3 id="references">References</h3>
<p>(1) <a href="https://github.com/rnpm/rnpm">GitHub - rnpm/rnpm: React Native Package Manager</a>
(2) <a href="https://dev-boku.tistory.com/entry/%EB%B2%88%EC%97%AD-JavaScript-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%A7%A4%EB%8B%88%EC%A0%80-%EB%B9%84%EA%B5%90-npm-Yarn-%EB%98%90%EB%8A%94-pnpm">[번역] JavaScript 패키지 매니저 비교 - npm, Yarn 또는 pnpm? — Dev Boku</a>
(3) <a href="https://ko.wikipedia.org/wiki/RPM_%ED%8C%A8%ED%82%A4%EC%A7%80_%EB%A7%A4%EB%8B%88%EC%A0%80">RPM 패키지 매니저 - 위키백과, 우리 모두의 백과사전</a>
(4) <a href="https://linuxism.ustd.ip.or.kr/1337">linuxism :: linux - RPM(RPM Package Manager)</a>
(5) <a href="https://www.lesstif.com/1stb/rpm-18219460.html">rpm 패키지 관리자 - lesstif.com</a>
rnpm은 이제 React Native 코어에 병합되었으므로 이제는 선호하는 연결 기능을 사용하기 위해 타사 소프트웨어를 설치할 필요가 없습니다. 대신 react-native cli를 사용하면 됩니다.
예를 들어, 의존성을 설치하고 한 번에 연결하려면 다음과 같이 실행할 수 있습니다:</p>
<pre><code class="language-sh">rnpm install &lt;name&gt;
</code></pre>
<p>이미 설치되었지만 연결되지 않은 모듈이 있는 경우 다음과 같이 실행할 수 있습니다:</p>
<pre><code class="language-sh">rnpm link
</code></pre>
<p>특정 의존성만 연결하려면 다음과 같이 실행할 수 있습니다:</p>
<pre><code class="language-sh">rnpm link &lt;name&gt;
</code></pre>
<p>rnpm은 이제 React Native 코어에 병합되었기 때문에 rnpm을 직접 설치하고 사용할 필요가 없습니다. 대신 react-native cli를 사용하여 rnpm의 기능을 사용할 수 있습니다. 이는 rnpm의 기능이 이제 react-native cli에 포함되어 있기 때문입니다.
<code>react-native-cli</code>는 React Native 앱을 개발할 때 사용하는 명령줄 인터페이스입니다. 이 패키지는 <code>react-native</code>라는 이름으로 npm에 등록되어 있습니다. 따라서 <code>npx react-native</code>를 사용하여 <code>react-native-cli</code>를 실행할 수 있습니다.
<code>@react-native-community/cli</code>는 <code>react-native-cli</code>의 구현부로, React Native 커뮤니티에서 관리하  는 독립적인 패키지입니다. 이 패키지는 <code>react-native-cli</code>의 기능을 제공하며, React Native 앱 개발에 필요한 명령어들을 제공합니다.
일반적으로 <code>npx react-native</code>를 사용하여 <code>react-native-cli</code>를 실행하면 자동으로 <code>@react-native-community/cli</code>가 설치되고 실행됩니다.
<code>react-native</code> 패키지를 설치하면 자동으로 <code>@react-native-community/cli</code>가 의존성으로 설치됩니다. 따라서 <code>react-native</code> 패키지만 설치하면 <code>@react-native-community/cli</code>의 기능을 사용할 수 있습니다.
일반적으로 <code>react-native</code> 패키지를 설치하고 <code>npx react-native</code> 명령어를 사용하여 <code>react-native-cli</code>를 실행하는 것이 권장됩니다. 이렇게 하면 패키지 관리가 더 간단해집니다.
<code>react-native-cli</code>는 다양한 명령어를 제공합니다. 일부 명령어는 다음과 같습니다:</p>
<ul>
<li><code>init</code>: 새로운 React Native 프로젝트를 생성합니다.</li>
<li><code>start</code>: React Native 팩커 서버를 시작합니다.</li>
<li><code>run-android</code>: Android 기기나 에뮬레이터에서 React Native 앱을 실행합니다.</li>
<li><code>run-ios</code>: iOS 시뮬레이터에서 React Native 앱을 실행합니다.</li>
<li><code>log-android</code>: Android 기기나 에뮬레이터에서 로그를 출력합니다.</li>
<li><code>log-ios</code>: iOS 시뮬레이터에서 로그를 출력합니다.
<code>npx react-native --help</code> 명령어를 사용하면 사용 가능한 모든 명령어와 각 명령어에 대한 자세한 정보를 확인할 수 있습니다.
<code>react-native-cli</code>에는 <code>doctor</code>와 <code>info</code>와 같은 명령어도 있습니다.</li>
<li><code>doctor</code>: 개발 환경을 검사하고 문제를 진단합니다. 필요한 경우 자동으로 문제를 해결하거나 수동으로 해결하는 방법을 안내합니다.</li>
<li><code>info</code>: 개발 환경에 대한 정보를 출력합니다. 운영 체제, Node.js 버전, React Native 버전 등의 정보가 포함됩니다.
이 외에도 <code>react-native-cli</code>는 다양한 명령어를 제공합니다. <code>npx react-native --help</code> 명령어를 사용하면 사용 가능한 모든 명령어와 각 명령어에 대한 자세한 정보를 확인할 수 있습니다.
<code>npx react-native --help</code> 명령어를 실행하면 다음과 같은 명령어 목록이 출력됩니다:</li>
</ul>
<pre><code class="language-log">  init [options] &lt;ProjectName&gt; [template]
  start [options]
  run-android [options]
  run-ios [options]
  run-macos [options]
  run-windows [options]
  status [options]
  log-android [options]
  log-ios [options]
  log-windows [options]
  dependencies
  info
  autolink-windows
  ram-bundle [options] &lt;entry-file&gt;
  bundle [options]
  eject [options]
  link [packageName]
  unlink &lt;packageName&gt;
  install &lt;packageName&gt;
  uninstall &lt;packageName&gt;
  upgrade [version] [options]
  doctor
</code></pre>
<p>각 명령어에 대한 자세한 정보는 <code>npx react-native &lt;command&gt; \--help</code> 명령어를 사용하여 확인할 수 있습니다.
<code>bundle</code> 명령어는 JavaScript 번들을 생성하는 데 사용됩니다. 이 명령어는 React Native 앱의 JavaScript 코드와 의존성을 하나의 파일로 번들링합니다. <code>run-android</code>나 <code>run-ios</code>와 같은 명령어를 실행할 때 자동으로 번들링이 수행되지만, <code>bundle</code> 명령어를 사용하면 수동으로 번들을 생성할 수 있습니다.
<code>eject</code> 명령어는 React Native 앱에서 Expo를 제거하는 데 사용됩니다. Expo를 사용하여 생성된 React Native 앱은 Expo 모듈을 사용하여 네이티브 기능에 접근합니다. <code>eject</code> 명령어를 실행하면 Expo 모듈이 제거되고 네이티브 코드가 직접 접근 가능한 상태가 됩니다. 이 명령어는 Expo를 사용하지 않는 순수한 React Native 앱으로 전환하고자 할 때 사용됩니다.
<code>create-react-native-app</code> 명령어를 사용하여 생성된 앱은 Expo를 사용하지 않습니다. 따라서 이러한 앱에서 <code>eject</code> 명령어를 실행하면 아무런 작업도 수행되지 않습니다.
<code>eject</code> 명령어는 Expo를 사용하는 React Native 앱에서만 유효합니다. Expo를 사용하지 않는 순수한 React Native 앱에서는 <code>eject</code> 명령어가 필요하지 않습니다.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="아이폰의 SSH 셸에 접근하기"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/en/blog/using-linux-shell-on-the-i-phone">아이폰에서 리눅스 셸 사용하기</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-04-06T00:00:00.000Z" itemprop="datePublished">April 6, 2023</time> · <!-- -->12 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="아이폰의-ssh-셸에-접근하기">아이폰의 SSH 셸에  접근하기</h2>
<p>아이폰의 SSH 셸에 접근하려면 아이폰을 탈옥해야 합니다. 탈옥한 아이폰에서는 Cydia 앱을 사용하여 OpenSSH 애플리케이션을 설치할 수 있습니다. 그런 다음 컴퓨터에서 Cyberduck 애플리케이션을 사용하여 아이폰과 컴퓨터 간의 안전한 연결을 설정할 수 있습니다.
또한 iSH라는 앱을 사용하여 iOS에서 리눅스 셸을 실행할 수도 있습니다. 이 앱은 Alpine Linux 환경을 제공하며 apk 패키지 관리자가 포함되어 있습니다.
다만, 이러한 작업은 아이폰의 보안 및 기능에 영향을 줄 수 있으므로 신중하게 결정해야 합니다.</p>
<h3 id="references">References</h3>
<p>(1) <a href="https://www.wikihow.com/SSH-Into-an-iPhone">How to SSH Into an iPhone (with Pictures) - wikiHow</a>
(2) <a href="https://www.howtogeek.com/devops/how-to-run-a-linux-shell-on-ios/">How to Run a Linux Shell on iOS</a>
(3) <a href="https://techwiser.com/best-ssh-client-ios/">Best SSH Client Apps for iOS To Manages Remote Servers</a></p>
<h2 id="아이폰-탈옥의-위험성">아이폰 탈옥의 위험성</h2>
<ol>
<li>과열 문제</li>
<li>악성 코드에 노출</li>
<li>안정성 부족</li>
<li>배터리 수명 단축</li>
<li>보증 취소</li>
<li>아이폰을 벽돌로 만드는 위험 증가</li>
</ol>
<p>따라서 아이폰 탈옥은 신중하게 결정해야 합니다.</p>
<h3 id="references-1">References</h3>
<p>(1) <a href="https://www.malwarebytes.com/iphone-jailbreaking">What is iPhone Jailbreaking?</a>
(2) <a href="https://www.imore.com/risks-jailbreaking-your-iphone-outweigh-any-benefits">The risks of jailbreaking your iPhone outweigh any benefits</a>
(3) <a href="https://www.tomsguide.com/us/pictures-story/537-jailbreaking-iphone-pros-cons.html">10 Pros and Cons of Jailbreaking Your iPhone or iPad</a>
(4) <a href="https://www.tomsguide.com/us/iphone-jailbreak-risks,news-18850.html">How Jailbreaking Puts Your iPhone at Risk | Tom&#x27;s Guide</a>
(5) <a href="https://sectigostore.com/blog/what-is-jailbreaking-an-iphone-is-jailbreaking-safe/">What Is Jailbreaking an iPhone &amp; Is Jailbreaking Safe?</a>
(6) <a href="https://www.avast.com/c-jailbreaking">What Is Jailbreaking &amp; Is It Safe? | Jailbreaking Definition | Avast</a></p>
<p>아이폰의 SSH 셸에 접근하려면 일반적으로 아이폰을 탈옥해야 합니다. 하지만 iSH와 같은 앱을 사용하여 iOS에서 리눅스 셸을 실행할 수 있습니다. 이 앱은 Alpine Linux 환경을 제공하며 apk 패키지 관리자가 포함되어 있습니다 .
리눅스 셸에서는 일반적으로 <code>iwconfig</code> 명령어를 사용하여 현재 연결된 Wifi 네트워크의 정보를 확인할 수 있습니다. 하지만 iOS에서 iSH 앱을 사용하는 경우에는 이 명령어가 작동하지 않을 수 있습니다. iSH 앱은 iOS의 기능에 제한적인 접근 권한을 가지고 있기 때문입니다.
<code>iwconfig</code> 명령어는 리눅스에서 무선 네트워크 인터페이스의 구성을 확인하고 변경하는 데 사용됩니다. 이 명령어를 사용하면 현재 연결된 무선 네트워크의 SSID, 신호 강도, 전송 속도 등의 정보를 확인할 수 있습니다.
<code>iwconfig</code> 명령어를 입력하면 시스템에 있는 모든 네트워크 인터페이스의 정보가 표시됩니다. 특정 인터페이스의 정보만 확인하려면 <code>iwconfig [인터페이스 이름]</code>과 같이 입력하면 됩니다.
예를 들어, <code>wlan0</code> 인터페이스의 정보만 확인하려면 <code>iwconfig wlan0</code>을 입력하면 됩니다.
다만 이 명령어는 일반적인 리눅스 시스템에서만 작동합니다. iOS에서 iSH 앱을 사용하는 경우에는 이 명령어가 작동하지 않을 수 있습니다.
<code>iwconfig</code> 명령어는 무선 네트워크 인터페이스의 구성을 확인하고 변경하는 데 사용되는 명령어로, Wifi 비밀번호를 암호화하여 전송하는 기능은 제공하지 않습니다.
Wifi 비밀번호를 타인에게 안전하게 전송하려면 다른 방법을 사용해야 합니다. 예를 들어, 암호화된 메시지 전송 앱이나 이메일 서비스를 사용하여 비밀번호를 전송할 수 있습니다.</p>
<h2 id="can-i-read-my-wifi-password-from-my-iphone">Can I read my WiFi password from my iPhone?</h2>
<p><code>iwconfig</code> 명령어를 사용하여 Wifi 비밀번호를 읽을 수 없습니다. 이 명령어는 무선 네트워크 인터페이스의 구성을 확인하고 변경하는 데 사용되며, Wifi 비밀번호를 확인하는 기능은 제공하지 않습니다.
리눅스 셸에서는 일반적으로 <code>iwconfig</code> 명령어를 사용하여 현재 연결된 Wifi 네트워크의 SSID를 확인할 수 있습니다. 하지만 이 명령어로는 Wifi 비밀번호를 확인할 수 없습니다.
일반적으로 Wifi 비밀번호는 라우터의 관리 페이지에서 확인하거나 변경할 수 있습니다. 라우터의 관리 페이지에 접속하려면 웹 브라우저의 주소창에 라우터의 IP 주소를 입력하면 됩니다. 일반적으로 라우터의 IP 주소는 <code>192.168.0.1</code> 또는 <code>192.168.1.1</code>입니다.
다만 iOS에서 iSH 앱을 사용하는 경우에는 <code>iwconfig</code> 명령어가 작동하지 않을 수 있습니다. iSH 앱은 iOS의 기능에 제한적인 접근 권한을 가지고 있기 때문입니다.
라우터의 관리 페이지에 접속하려면 다음과 같은 단계를 따르면 됩니다:</p>
<ol>
<li>컴퓨터나 모바일 장치의 웹 브라우저를 실행합니다.</li>
<li>주소창에 라우터의 IP 주소를 입력하고 엔터 키를 누릅니다. 일반적으로 라우터의 IP 주소는 <code>192.168.0.1</code> 또는 <code>192.168.1.1</code>입니다.</li>
<li>라우터의 관리 페이지에 로그인합니다. 일반적으로 라우터의 기본 사용자 이름과 비밀번호는 <code>admin</code>입니다.</li>
</ol>
<p>라우터의 관리 페이지에 접속한 후에는 Wifi 설정, 포트 포워딩, 방화벽 설정 등 다양한 설정을 변경할 수 있습니다.
다만 라우터 제조사마다 관리 페이지의 디자인과 기능이 다르므로, 자세한 내용은 라우터의 사용 설명서를 참조하시기 바랍니다.
일반적으로 프로그래밍 언어를 사용하여 현재 연결된 Wifi 네트워크의 IP 주소와 SSID를 확인할 수 있습니다. 예를 들어, Python의 <code>socket</code> 모듈을 사용하여 로컬 IP 주소를 확인할 수 있습니다.
하지만 Wifi 비밀번호는 프로그래밍 언어로 확인할 수 없습니다. 일반적으로 Wifi 비밀번호는 라우터의 관리 페이지에서 확인하거나 변경할 수 있습니다.
다만 iOS에서 iSH 앱을 사용하는 경우에는 일부 기능이 제한될 수 있습니다. iSH 앱은 iOS의 기능에 제한적인 접근 권한을 가지고 있기 때문입니다.
iOS 기기에서는 bash나 sh와 같은 명령어를 사용할 수 없습니다. 하지만 iOS 기기에서는 설정 앱을 열고 Wi-Fi 섹션으로 이동하여 현재 연결된 Wi-Fi 네트워크의 이름(SSID)을 확인할 수 있습니다. 그러나 Wi-Fi 비밀번호는 iOS 기기에서 직접 확인할 수 없습니다. 비밀번호를 확인하려면 라우터의 관리자 페이지에 로그인하거나 라우터에 연결된 다른 기기에서 확인해야 합니다.
MacOS나 Linux에서 현재 연결된 Wi-Fi 네트워크의 SSID를 확인하는 방법은 다양합니다. MacOS에서는 터미널을 열고 다음 명령어를 입력하면 됩니다:</p>
<pre><code class="language-sh">/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -I | awk &#x27;/ SSID/ {print substr($0, index($0, $2))}&#x27;
</code></pre>
<p>Linux에서는 터미널을 열고 다음 명령어 중 하나를 입력하면 됩니다:</p>
<pre><code class="language-sh">iwgetid -r
</code></pre>
<p>또는</p>
<pre><code class="language-sh">nmcli -t -f active,ssid dev wifi | egrep &#x27;^yes&#x27; | cut -d: -f2
</code></pre>
<p>하지만 Wi-Fi 비밀번호는 이러한 방법으로 확인할 수 없습니다. Wi-Fi 비밀번호는 라우터의 관리자 페이지에 로그인하여 확인하거나 라우터에 연결된 다른 기기에서 확인해야 합니다.
MacOS에서는 키체인 접근 유틸리티를 사용하여 저장된 Wi-Fi 비밀번호를 확인할 수 있습니다. 키체인 접근을 열고 &#x27;시스템&#x27; 키체인을 선택한 다음 &#x27;분류&#x27;에서 &#x27;비밀번호&#x27;를 선택합니다. 그런 다음 목록에서 해당하는 Wi-Fi 네트워크를 찾아 더블클릭하고 &#x27;비밀번호 보기&#x27;를 선택한 다음 관리자 비밀번호를 입력하면 됩니다.
Linux에서는 NetworkManager를 사용하여 저장된 Wi-Fi 비밀번호를 확인할 수 있습니다. 터미널을 열고 다음 명령어를 입력하면 됩니다:</p>
<pre><code class="language-sh">sudo cat /etc/NetworkManager/system-connections/[NETWORK NAME] | grep psk=
</code></pre>
<p>위의 명령어에서 [NETWORK NAME]은 확인하려는 Wi-Fi 네트워크의 이름으로 바꿔야 합니다. 그러나 이 방법은 NetworkManager가 설치되어 있고 해당 Wi-Fi 네트워크에 연결된 적이 있는 경우에만 작동합니다.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="프로그래밍 언어에서 Truthy와 Falsy 값"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/en/blog/truthy-falsy-concept-and-introduction">Truthy &amp; Falsy 개념 및 사용방법 소개</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-04-04T00:00:00.000Z" itemprop="datePublished">April 4, 2023</time> · <!-- -->8 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="프로그래밍-언어에서-truthy와-falsy-값">프로그래밍 언어에서 Truthy와 Falsy 값</h2>
<p>Truthy와 Falsy 값은 프로그래밍 언어에서 Boolean 컨텍스트에서 true 또는 false로 평가되는 값입니다. 예를 들어, 0은 false로 평가되기 때문에 falsy 값이지만 “0”은 정의된 문자열로 truthy 값입니다.
JavaScript에서는 모든 값이 falsy로 정의되지 않는 한 truthy입니다. 즉, false, 0, -0, 0n, &quot;&quot;, null, undefined 및 NaN을 제외한 모든 값이 truthy입니다.
Python에서는 다음과 같은 값들이 falsy로 간주됩니다: None, False, 0과 같은 숫자들(0.0, 0j), 빈 시퀀스와 컬렉션([]-빈 리스트, <!-- -->-빈 딕셔너리, ()-빈 튜플, set()-빈 세트), &#x27;&#x27;-빈 str, b&#x27;&#x27;-빈 bytes 등.
다른 프로그래밍 언어들도 비슷한 방식으로 truthy와 falsy 값을 정의합니다. 이러한 값들은 코드를 더 간결하게 만드는 데 사용될 수 있습니다.</p>
<h3 id="references">References</h3>
<p>(1) <a href="https://www.sitepoint.com/boolean-data-type/">What Is a Boolean Data Type, and What Are Some Uses? — SitePoint</a>
(2) <a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">Truthy - MDN Web Docs Glossary: Definitions of Web-related terms | MDN - Mozilla</a>
(3) <a href="https://stackoverflow.com/questions/39983695/what-is-truthy-and-falsy-how-is-it-different-from-true-and-false">What is Truthy and Falsy? How is it different from True and False?</a>
(4) <a href="https://www.freecodecamp.org/news/truthy-and-falsy-values-in-python/">Truthy and Falsy Values in Python: A Detailed Introduction</a></p>
<p>다른 프로그래밍 언어들도 비슷한 방식으로 truthy와 falsy 값을 정의합니다. 예를 들어, PHP에서는 다음과 같은 값들이 falsy로 간주됩니다: false, 0, 0.0, &quot;&quot;, &quot;0&quot;, null, array().
Truthy와 Falsy 값은 프로그래밍 언어들 간의 비교에서 널리 사용됩니다 (예: PHP vs PERL vs Python vs JS). 이러한 값들은 코드를 더 간결하게 만드는 데 사용될 수 있습니다.</p>
<h3 id="references-1">References</h3>
<p>(1) <a href="https://www.sitepoint.com/boolean-data-type/">What Is a Boolean Data Type, and What Are Some Uses? — SitePoint</a>
(2) <a href="https://stackoverflow.com/questions/39983695/what-is-truthy-and-falsy-how-is-it-different-from-true-and-false">What is Truthy and Falsy? How is it different from True and False?</a>
(3) <a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">Truthy - MDN Web Docs Glossary: Definitions of Web-related terms | MDN - Mozilla</a>
(4) <a href="https://www.freecodecamp.org/news/truthy-and-falsy-values-in-python/">Truthy and Falsy Values in Python: A Detailed Introduction</a></p>
<p>Java는 C와 달리 숫자 조건문을 허용하지 않습니다. 예를 들어, 다음과 같은 코드는 Java에서 오류가 발생합니다:</p>
<pre><code class="language-java">if (5) {
    System.out.println(&quot;true&quot;);
} else {
    System.out.println(&quot;false&quot;);
}
</code></pre>
<p>이 코드는 다음과 같은 오류 메시지를 발생시킵니다:
<code>incompatible types: int cannot be converted to boolean</code>
Java에서는 boolean 타입의 값만 if문의 조건으로 사용할 수 있습니다. 따라서 Java에서는 truthy와 falsy 값이 존재하지 않습니다.
Go 언어에서도 Java와 마찬가지로 boolean 타입의 값만 if문의 조건으로 사용할 수 있습니다. 따라서 Go 언어에서도 truthy와 falsy 값이 존재하지 않습니다.
Java와 Go 언어 모두 toBoolean()이라는 내장 메소드를 가지고 있지 않습니다. 하지만, 사용자 정의 클래스에서 boolean 값을 반환하는 메소드를 정의할 수 있습니다.
예를 들어, Java에서는 다음과 같이 작성할 수 있습니다:</p>
<pre><code class="language-java">class MyClass {
    private int value;
    public MyClass(int value) {
        this.value = value;
    }
    public boolean toBoolean() {
        return value != 0;
    }
}
MyClass myObject = new MyClass(5);
if (myObject.toBoolean()) {
    System.out.println(&quot;true&quot;);
} else {
    System.out.println(&quot;false&quot;);
}
</code></pre>
<p>이 코드는 &quot;true&quot;를 출력합니다.
Go 언어에서도 비슷한 방식으로 작성할 수 있습니다:</p>
<pre><code class="language-go">type MyClass struct {
    value int
}
func (m MyClass) toBoolean() bool {
    return m.value != 0
}
func main() {
    myObject := MyClass{5}
    if myObject.toBoolean() {
        fmt.Println(&quot;true&quot;)
    } else {
        fmt.Println(&quot;false&quot;)
    }
}
</code></pre>
<p>이 코드도 &quot;true&quot;를 출력합니다.</p>
<p>사용자 정의 클래스에서 boolean 값을 반환하는 메소드의 동작 방식은 사용자가 정의한대로 작동합니다. 따라서 false를 반환하도록 강제할 수 있습니다.
Java에서 모든 클래스는 Object 클래스를 상속합니다. Object 클래스에는 몇 가지 메소드가 정의되어 있습니다. 이 중 일부 메소드는 사용자 정의 클래스에서 오버라이딩하는 것이 좋습니다.</p>
<ul>
<li><code>equals(Object obj)</code>: 객체가 다른 객체와 &quot;동일&quot;한지 여부를 결정합니다. 이 메소드는 일반적으로 오버라이딩하는 것이 좋습니다.</li>
<li><code>hashCode()</code>: 객체의 해시 코드 값을 반환합니다. equals 메소드를 오버라이딩하는 경우, hashCode 메소드도 함께 오버라이딩해야 합니다.</li>
<li><code>toString()</code>: 객체를 문자열로 표현합니다. 이 메소드는 일반적으로 오버라이딩하는 것이 좋습니다.</li>
</ul>
<p>하지만, 이러한 메소드들을 반드시 오버라이딩해야 하는 것은 아닙니다. 이러한 메소드들을 오버라이딩하지 않으면 Object 클래스에 정의된 기본 구현이 사용됩니다.
Java에서 hashCode() 메소드는 객체의 해시 코드 값을 반환합니다. 이 메소드는 equals 메소드와 함께 오버라이딩하는 것이 좋습니다. equals 메소드가 두 객체를 &quot;동일&quot;하다고 판단하면, 두 객체의 hashCode 메소드는 같은 값을 반환해야 합니다.
다음은 hashCode 메소드를 오버라이딩하는 예시 코드입니다:</p>
<pre><code class="language-java">class MyClass {
    private int value;
    public MyClass(int value) {
        this.value = value;
    }
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        MyClass other = (MyClass) obj;
        return value == other.value;
    }
    @Override
    public int hashCode() {
        return value;
    }
}
</code></pre>
<p>이 코드에서 MyClass 클래스는 value 필드를 가지고 있습니다. equals 메소드는 두 객체의 value 필드가 같은 경우에만 true를 반환합니다. 따라서 hashCode 메소드도 value 필드의 값을 반환합니다.
이렇게 함으로써, equals 메소드가 두 객체를 &quot;동일&quot;하다고 판단하면, 두 객체의 hashCode 메소드는 같은 값을 반환하게 됩니다.</p></div></article><nav class="pagination-nav" aria-label="Blog list page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/wiki/en/blog/page/2"><div class="pagination-nav__label">Newer Entries</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/wiki/en/blog/page/4"><div class="pagination-nav__label">Older Entries</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/wiki/en/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/wiki/en/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/AndrewDongminYoo/wiki" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>