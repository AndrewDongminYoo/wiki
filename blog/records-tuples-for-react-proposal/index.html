<!doctype html>
<html lang="ko" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.0.0">
<title data-rh="true">Records &amp; Tuples for React Proposal | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-test-site.com/wiki/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-test-site.com/wiki/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-test-site.com/wiki/blog/records-tuples-for-react-proposal"><meta data-rh="true" property="og:locale" content="ko"><meta data-rh="true" property="og:locale:alternate" content="en"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Records &amp; Tuples for React Proposal | My Site"><meta data-rh="true" name="description" content="매우 흥미로운 제안인 레코드 &amp; 튜플이 TC39\\에서 2단계에 도달했습니다."><meta data-rh="true" property="og:description" content="매우 흥미로운 제안인 레코드 &amp; 튜플이 TC39\\에서 2단계에 도달했습니다."><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2023-03-26T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://gravatar.com/donminzzi"><link data-rh="true" rel="icon" href="/wiki/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://your-docusaurus-test-site.com/wiki/blog/records-tuples-for-react-proposal"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/wiki/blog/records-tuples-for-react-proposal" hreflang="ko"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/wiki/en/blog/records-tuples-for-react-proposal" hreflang="en"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/wiki/blog/records-tuples-for-react-proposal" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/wiki/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/wiki/blog/atom.xml" title="My Site Atom Feed"><link rel="stylesheet" href="/wiki/assets/css/styles.a30419b5.css">
<script src="/wiki/assets/js/runtime~main.9c986a32.js" defer="defer"></script>
<script src="/wiki/assets/js/main.e59d876b.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="본문으로 건너뛰기"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">본문으로 건너뛰기</a></div><nav aria-label="메인" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="네비게이션 바 토글하기" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/wiki/"><div class="navbar__logo"><img src="/wiki/img/logo.svg" alt="내 사이트 로고" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/wiki/img/logo.svg" alt="내 사이트 로고" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">내 사이트</b></a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>한국어</a><ul class="dropdown__menu"><li><a href="/wiki/blog/records-tuples-for-react-proposal" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="ko">한국어</a></li><li><a href="/wiki/en/blog/records-tuples-for-react-proposal" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="en">English</a></li></ul></div><a class="navbar__item navbar__link" href="/wiki/docs/intro">튜토리얼</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/wiki/blog">블로그</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/AndrewDongminYoo/wiki" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">깃허브<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="최근 블로그 문서 둘러보기"><div class="sidebarItemTitle_pO2u margin-bottom--md">최신글</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/blog/front-backend-developer-roadmap">프론트+백엔드 개발자 로드맵</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/blog/static-property-in-java-class">Static Property in Java Class</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/blog/four-mainstream-d-bs-and-features">가장 많이 사용되는 주류 DB 4가지와 특징</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/blog/generate-unicode-emoji-regular-expression">Generate Unicode emoji regular expression</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/blog/redirection-of-the-website">웹사이트의 리다이렉팅 방식</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="https://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="매우 흥미로운 제 안인 레코드 &amp; 튜플이 TC39\\에서 2단계에 도달했습니다."><header><h1 class="title_f1Hy" itemprop="headline">Records &amp; Tuples for React Proposal</h1><div class="container_mt6G margin-vert--md"><time datetime="2023-03-26T00:00:00.000Z" itemprop="datePublished">2023년 3월 26일</time> · <!-- -->약 32분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div id="__blog-post-container" class="markdown" itemprop="articleBody"><p>**매우 흥미로운 제안인 <a href="https://github.com/tc39/proposal-record-tuple">레코드 &amp; 튜플</a>이 **TC39**에서 <a href="https://twitter.com/robpalmer2/status/1286040041089904640">2단계</a>에 도달했습니다.</p>
<p>레코드와 튜플은 <strong>불변 데이터 구조</strong>를 자바스크립트로 가져옵니다.</p>
<p>하지만 <strong>React</strong>에 <strong>매우</strong> 흥미로운 <strong>동등성(equality)</strong> 속성을 간과해서는 안 됩니다.</p>
<p>React 버그의 많은 범주는 <strong>불안정한 객체 아이덴티티</strong>와 관련이 있습니다:</p>
<ul>
<li><strong>성능</strong>: 피할 수 있는 재렌더링</li>
<li><strong>동작</strong>: 쓸모없는 이펙트 재실행, 무한 루프</li>
<li><strong>API 표면</strong>: 안정적인 객체 아이덴티티가 중요한 경우 표현할 수 없음</li>
</ul>
<p>레코드와 튜플의 기초를 설명하고, 이를 통해 어떻게 현실의 React 문제를 해결할 수 있는지 설명하겠습니다.</p>
<h2 id="레코드와-튜플-101">레코드와 튜플 101</h2>
<p>이 글은 React의 레코드와 튜플에 관한 글입니다. 여기서는 기본적인 내용만 다루겠습니다.</p>
<p>레코드와 튜플은 <strong>#</strong> 접두사가 붙은 일반적인 객체와 배열처럼 보입니다.</p>
<pre><code class="language-tsx">const record = #{a: 1, b: 2};
record.a;
// 1

const updatedRecord = #{...record, b: 3};
// #{a: 1, b: 3};
const tuple = #[1, 5, 2, 3, 4];
tuple[1];
// 5

const filteredTuple = tuple.filter(num =&gt; num &gt; 2)
// #[5, 3, 4];
</code></pre>
<p>They are <strong>deeply immutable</strong> by default.</p>
<pre><code class="language-tsx">const record = #{a: 1, b: 2};
record.b = 3;
// throws TypeError
</code></pre>
<p>이들은 **&quot;복합 프리미티브&quot;**로 볼 수 있으며 값으로 비교할 수 있습니다.</p>
<p><strong>매우 중요</strong>: 두 개의 완전히 동일한 레코드는 <code>===</code>와 함께 <code>true</code>를 <strong>항상</strong> 반환합니다.</p>
<pre><code class="language-ts">const record = JSON.parseImmutable(&quot;{a: 1, b: [2, 3]}&quot;);
// #{a: 1, b: #[2, 3]}
JSON.stringify(record);
// &#x27;{a: 1, b: [2, 3]}&#x27;
</code></pre>
<p>어떻게든 레코드의 아이덴티티는 일반 JS 프리미티브와 마찬가지로 실제 값이라고 생각할 수 있습니다.</p>
<p>이 프로퍼티는 앞으로 살펴볼 것처럼 React에 <strong>심각한 영향</strong>을 미칩니다.</p>
<p>JSON과 상호 운용이 가능합니다:</p>
<pre><code class="language-ts">const record1 = #{
  a: {
    regular: &#x27;object&#x27;
  },
};
// throws TypeError, because a record can&#x27;t contain an object

const record2 = #{
  b: new Date(),
};
// throws TypeError, because a record can&#x27;t contain a Date

const record3 = #{
  c: new MyClass(),
};
// throws TypeError, because a record can&#x27;t contain a class

const record4 = #{
  d: function () {
    alert(&#x27;forbidden&#x27;);
  },
};
// throws TypeError, because a record can&#x27;t contain a function
</code></pre>
<p>다른 레코드와 튜플 또는 프리미티브 값만 포함할 수 있습니다.</p>
<p><strong>참고</strong>: 심볼을 WeakMap 키(<a href="https://github.com/tc39/proposal-symbols-as-weakmap-keys">별도 제안</a>)로 사용하고 레코드의 심볼을 <a href="https://github.com/tc39/proposal-record-tuple#could-i-box-a-pointer-to-an-object-and-put-that-in-a-record-or-tuple">참조</a>하여 레코드에 이러한 변경 가능한 값을 추가할 수 있습니다.</p>
<p>더 알고 싶으신가요? <a href="https://github.com/tc39/proposal-record-tuple">제안</a>을 직접 읽어보시거나 Axel Rauschmayer의 <a href="https://2ality.com/2020/05/records-tuples-first-look.html">기사</a>를 읽어보세요.</p>
<h2 id="react를-위한-레코드와-튜플">React를 위한 레코드와 튜플</h2>
<p>React 개발자들은 이제 **불변성(immutability)**에 익숙해졌습니다.</p>
<p>어떤 상태를 불변의 방식으로 업데이트할 때마다 <strong>새로운 객체 아이덴티티</strong>를 생성합니다.</p>
<p>안타깝게도 이 불변성 모델은 React 애플리케이션에 완전히 새로운 종류의 버그와 성능 문제를 일으켰습니다. 때로는 컴포넌트가 올바르고 성능 좋은 방식으로 작동하지만, 이는 <strong>소품이 시간이 지나도 최대한 아이덴티티를 보존한다는 가정 하에서만</strong> 가능합니다.</p>
<p>저는 레코드와 튜플을 객체 아이덴티티를 보다 &quot;안정적으로&quot;** 만드는 편리한 방법으로 생각하고 싶습니다.</p>
<p>실제 사용 사례를 통해 이 제안이 React 코드에 어떤 영향을 미치는지 살펴봅시다.</p>
<p><strong>참고</strong>: React를 실행할 수 있는 <a href="https://rickbutton.github.io/record-tuple-playground"> 레코드 &amp; 튜플 플레이그라운드</a>가 있습니다.</p>
<h2 id="불변성">불변성</h2>
<p>불변성을 적용하는 것은 재귀적인 <code>Object.freeze()</code> 호출로 달성할 수 있습니다.</p>
<p>하지만 실제로는 업데이트할 때마다 <code>Object.freeze()</code>를 적용하는 것이 편리하지 않기 때문에 불변성 모델을 너무 엄격하게 적용하지 않고 사용하는 경우가 많습니다. 하지만 상태를 직접 변경하는 것은 초보 React 개발자들이 흔히 저지르는 실수입니다.</p>
<p>레코드 및 튜플 제안은 <strong>불변성을 강제</strong>하고 일반적인 상태 변경 실수를 방지합니다:</p>
<pre><code class="language-tsx">const Hello = ({ profile }) =&gt; {
  // prop mutation: throws TypeError
  profile.name = &#x27;Sebastien updated&#x27;;
  return &lt;p&gt;Hello {profile.name}&lt;/p&gt;;
};
function App() {
  const [profile, setProfile] = React.useState(#{
    name: &#x27;Sebastien&#x27;,
  });
  // state mutation: throws TypeError
  profile.name = &#x27;Sebastien updated&#x27;;
  return &lt;Hello profile={profile} /&gt;;
}
</code></pre>
<h2 id="불변-업데이트">불변 업데이트</h2>
<p>React에서 불변 상태 업데이트를 수행하는 방법에는 <a href="https://dev.to/sebastienlorber/insight-3-use-immerjs-over-lodash-set-immutablejs-or-plain-js-36bl">여러 가지</a>가 있습니다: vanilla JS, Lodash set, ImmerJS, ImmutableJS...</p>
<p>레코드와 튜플은 ES6 객체와 배열에서 사용하는 것과 동일한 종류의 불변 업데이트 패턴을 지원합니다:</p>
<pre><code class="language-tsx">const initialState = #{
  user: #{
    firstName: &quot;Sebastien&quot;,
    lastName: &quot;Lorber&quot;
  }
  company: #{
    name: &quot;Lambda Scale&quot;,
  }
};
const updatedState = {
  ...initialState,
  company: {
    ...initialState.company,
    name: &#x27;Freelance&#x27;,
  },
};
</code></pre>
<p>지금까지는 중첩된 속성을 처리하는 단순성과 일반 JS 코드와의 상호 운용성 덕분에 <a href="https://github.com/immerjs/immer">ImmerJS</a>가 불변성 업데이트 전쟁에서 승리했습니다.</p>
<p>Immer가 레코드 및 튜플과 어떻게 작동할 수 있는지는 아직 명확하지 않지만, 제안서 작성자들이 연구하고 있는 부분입니다.</p>
<p>별개로 Michael Weststrate는 <a href="https://github.com/tc39/proposal-deep-path-properties-for-record">관련된 제안</a>이 [레코드 및 튜플에 ImmerJS를 **불필요하게 만들 수 있다]고 <a href="https://twitter.com/mweststrate/status/1263482177934819329">강조</a>했습니다:</p>
<pre><code class="language-tsx">const initialState = #{
  counters: #[
    #{ name: &quot;Counter 1&quot;, value: 1 },
    #{ name: &quot;Counter 2&quot;, value: 0 },
    #{ name: &quot;Counter 3&quot;, value: 123 },
  ],
  metadata: #{
    lastUpdate: 1584382969000,
  },
};
// Vanilla JS updates
// using deep-path-properties-for-record proposal
const updatedState = #{
  ...initialState,
  counters[0].value: 2,
  counters[1].value: 1,
  metadata.lastUpdate: 1584383011300,
};
</code></pre>
<h2 id="usememo">useMemo</h2>
<p><code>useMemo()</code>는 비용이 많이 드는 계산을 메모하는 것 외에도 <strong>트리의 더 깊은 곳에서 쓸모없는 계산, 재렌더링 또는 이펙트 실행을 트리거</strong>할 수 있는 <strong>새 객체 ID 생성을 피하는 데에도 유용합니다</strong>.</p>
<p>여러 필터가 있는 UI가 있고 백엔드에서 일부 데이터를 가져오고자 하는 사용 사례를 고려해 보겠습니다.</p>
<p>기존 React 코드베이스에는 다음과 같은 코드가 포함될 수 있습니다:</p>
<pre><code class="language-tsx">// Don&#x27;t change apiFilters object identity,
// unless one of the filter changes
// Not doing this is likely to trigger a new fetch
// on each render
const apiFilters = useMemo(
  () =&gt; ({ userFilter, companyFilter }),
  [userFilter, companyFilter],
);
const { apiData, loading } = useApiData(apiFilters);
</code></pre>
<p>레코드 및 튜플을 사용하면 간단히 이렇게 됩니다:</p>
<pre><code class="language-tsx">const {apiData,loading} = useApiData(#{ userFilter, companyFilter })
</code></pre>
<h3 id="useeffect">useEffect</h3>
<p>API 필터 사용 사례를 계속 살펴보겠습니다:</p>
<pre><code class="language-tsx">const apiFilters = { userFilter, companyFilter };
useEffect(() =&gt; {
  fetchApiData(apiFilters).then(setApiDataInState);
}, [apiFilters]);
</code></pre>
<p>안타깝게도 이 컴포넌트가 리렌더링할 때마다 <code>apiFilters</code> 객체의 ID가 변경되기 때문에 가져오기 효과가 <strong>재실행</strong>됩니다. <code>setApiDataInState</code>는 리렌더링을 트리거하고, 결국 무한한 불러오기/렌더링 루프가 발생하게 됩니다.</p>
<p>이 실수는 React 개발자들 사이에서 매우 흔한 실수이며, <a href="https://www.google.com/search?q=useEffect+%2B+%22infinite+loop%22">useEffect 무한 루프</a>에 대한 구글 검색 결과만 수천 개가 넘습니다.</p>
<p><a href="https://twitter.com/kentcdodds">Kent C Dodds</a>는 개발 과정에서 무한 루프를 끊는 <a href="https://github.com/kentcdodds/stop-runaway-react-effects">도구</a>를 만들기도 했습니다.</p>
<p>매우 일반적인 해결책: 이펙트의 콜백에 직접 <code>apiFilters</code>를 생성합니다:</p>
<pre><code class="language-tsx">useEffect(() =&gt; {
  const apiFilters = { userFilter, companyFilter };
  fetchApiData(apiFilters).then(setApiDataInState);
}, [userFilter, companyFilter]);
</code></pre>
<p><a href="https://twitter.com/acutmore/status/1256533631914426369">트위터</a>에서 찾을 수 있는 또 다른 창의적인 솔루션(성능은 좋지 않음)입니다:</p>
<pre><code class="language-tsx">const apiFiltersString = JSON.stringify({
  userFilter,
  companyFilter,
});
useEffect(() =&gt; {
  fetchApiData(JSON.parse(apiFiltersString)).then(setApiDataInState);
}, [apiFiltersString]);
</code></pre>
<p>그 중 가장 제   마음에 드는 기능입니다:</p>
<pre><code class="language-tsx">// We already saw this somewhere, right? :p
const apiFilters = useMemo(
  () =&gt; ({ userFilter, companyFilter }),
  [userFilter, companyFilter],
);
useEffect(() =&gt; {
  fetchApiData(apiFilters).then(setApiDataInState);
}, [apiFilters]);
</code></pre>
<p>이 문제를 해결하는 멋진 방법이 많이 있지만 필터 수가 증가함에 따라 모두 <strong>귀찮아지는</strong> 경향이 있습니다.</p>
<p><a href="https://github.com/kentcdodds/use-deep-compare-effect">use-deep-compare-effect</a>(<a href="https://twitter.com/kentcdodds">Kent C Dodds</a>)가 덜 성가시겠지만, 리렌더링할 때마다 딥 이퀄리티를 실행하는 데는 지불하고 싶지 않은 비용이 듭니다.</p>
<p>레코드 및 튜플보다 훨씬 <strong>장황하고 관용적이지 않습니다</strong>:</p>
<pre><code class="language-tsx">const apiFilters = #{ userFilter, companyFilter };
useEffect(() =&gt; {
  fetchApiData(apiFilters).then(setApiDataInState);
}, [apiFilters]);
</code></pre>
<h3 id="props와-reactmemo">Props와 React.memo</h3>
<p>프로포즈에서 객체 아이덴티티를 보존하는 것은 React 퍼포먼스에도 매우 유용합니다.</p>
<p>또 다른 매우 흔한 성능 실수는 렌더링에서 새로운 객체 아이덴티티를 생성하는 것입니다.</p>
<pre><code class="language-tsx">const Parent = () =&gt; {
  useRerenderEverySeconds();
  return (
    &lt;ExpensiveChild
      // someData props object is created &quot;on the fly&quot;
      someData={{ attr1: &quot;abc&quot;, attr2: &quot;def&quot; }}
    /&gt;
  );
};
const ExpensiveChild = React.memo(({ someData }) =&gt; {
  return &lt;div&gt;{expensiveRender(someData)}&lt;/div&gt;;
});
</code></pre>
<p>대부분의 경우 이것은 문제가 되지 않습니다. React는 충분히 빠르니까요.</p>
<p>하지만 때때로 앱을 최적화하려는 경우, 이 새로운 객체 생성은 <code>React.memo()</code>를 쓸모없게 만듭니다. 최악의  경우, 실제로 애플리케이션을 조금 느리게 만듭니다(항상 거짓을 반환하는 추가적인 얕은 동등성 검사를 실행해야 하기 때문입니다).</p>
<p>클라이언트 코드베이스에서 자주 볼 수 있는 또 다른 패턴입니다:</p>
<pre><code class="language-tsx">const currentUser = { name: &quot;Sebastien&quot; };
const currentCompany = { name: &quot;Lambda Scale&quot; };
const AppProvider = () =&gt; {
  useRerenderEverySeconds();
  return (
    &lt;MyAppContext.Provider
      // the value prop object is created &quot;on the fly&quot;
      value={{ currentUser, currentCompany }}
    /&gt;
  );
};
</code></pre>
<p><code>currentUser</code> 또는 <code>currentCompany</code>가 <strong>업데이트되지 않는다는</strong> 사실에도 불구하고, 이 공급자가 리렌더링할 때마다 컨텍스트 값이 변경되어 모든 컨텍스트 구독자의 리렌더링을 트리거합니다.</p>
<p>이러한 모든 문제는 메모화를 통해 해결할 수 있습니다:</p>
<pre><code class="language-tsx">const someData = useMemo(() =&gt; ({ attr1: &quot;abc&quot;, attr2: &quot;def&quot; }), []);
&lt;ExpensiveChild someData={someData} /&gt;;
</code></pre>
<pre><code class="language-tsx">const contextValue = useMemo(
  () =&gt; ({ currentUser, currentCompany }),
  [currentUser, currentCompany],
);
&lt;MyAppContext.Provider value={contextValue} /&gt;;
</code></pre>
<p>레코드 및 튜플을 사용하면 <strong>성능이 뛰어난 코드를 작성하는 것이 관용적입니다</strong>:</p>
<pre><code class="language-tsx">&lt;ExpensiveChild someData={#{ attr1: &#x27;abc&#x27;, attr2: &#x27;def&#x27; }} /&gt;;
</code></pre>
<pre><code class="language-tsx">&lt;MyAppContext.Provider value={#{ currentUser, currentCompany }} /&gt;;
</code></pre>
<h2 id="불러오기-및-다시-불러오기">불러오기 및 다시 불러오기</h2>
<p>React에서 데이터를 불러오는 방법은 여러 가지가 있습니다: <code>useEffect</code>, HOC, Render props, Redux, SWR, React-Query, Apollo, Relay, Urql, ...</p>
<p>대부분의 경우, 우리는 요청을 백엔드에 전달하고 JSON 데이터를 반환받습니다.</p>
<p>이 섹션을 설명하기 위해 제가 만든 아주 간단한 불러오기 라이브러리인 <a href="https://github.com/slorber/react-async-hook">react-async-hook</a>을 사용하겠지만, 다른 라이브러리에도 적용될 수 있습니다.</p>
<p>API 데이터를 가져오는 고전적인 비동기 함수를 고려해 봅시다:</p>
<pre><code class="language-tsx">const fetchUserAndCompany = async () =&gt; {
  const response = await fetch(`https://myBackend.com/userAndCompany`);
  return response.json();
};
</code></pre>
<p>이 앱은 데이터를 가져오고, 시간이 지나도 이 데이터가 오래된 데이터가 아닌 &#x27;최신&#x27; 상태로 유지되도록 합니다:</p>
<pre><code class="language-tsx">const App = ({ id }) =&gt; {
  const { result, refetch } = useAsync(fetchUserAndCompany, []);
  // We try very hard to not display stale data to the user!
  useInterval(refetch, 10000);
  useOnReconnect(refetch);
  useOnNavigate(refetch);
  if (!result) {
    return null;
  }
  return (
    &lt;div&gt;
      &lt;User user={result.user} /&gt;
      &lt;Company company={result.company} /&gt;
    &lt;/div&gt;
  );
};
const User = React.memo(({ user }) =&gt; {
  return &lt;div&gt;{user.name}&lt;/div&gt;;
});
const Company = React.memo(({ company }) =&gt; {
  return &lt;div&gt;{company.name}&lt;/div&gt;;
});
</code></pre>
<p>문제: 성능상의 이유로 <code>React.memo</code>를 사용했지만, 다시 불러올 때마다 가져온 데이터가 이전과 <strong>동일</strong>(완전히 동일한 페이로드)임에도 불구하고 <strong>새로운 아이덴티티</strong>를 가진 새로운 JS 객체가 생성되고 <strong>모든 것이 리렌더링</strong>됩니다.</p>
<p>이 시나리오를 상상해 봅시다:</p>
<ul>
<li>&quot;Stale-While-Revalidate&quot; 패턴(캐시된/부실 데이터를 먼저 표시한 다음 백그라  운드에서 데이터를 새로 고침)을 사용합니다.</li>
<li>페이지가 복잡하고 렌더링 집약적이며 많은 백엔드 데이터가 표시됩니다.</li>
</ul>
<p>캐시된 데이터로 인해 처음 렌더링하는 데 이미 많은 비용이 드는 페이지로 이동합니다. 1초 후 새로 고쳐진 데이터가 다시 표시됩니다. 캐시된 데이터와 거의 동일함에도 불구하고 모든 것이 리렌더링됩니다. <a href="https://reactjs.org/docs/concurrent-mode-intro.html">동시성 모드</a>와 타임 슬라이싱이 없으면 일부 사용자는 수백 밀리초 동안 <strong>UI가 멈추는</strong> 현상을 경험할 수도 있습니다.</p>
<p>이제 가져오기 함수를 레코드를 반환하도록 변환해 보겠습니다:</p>
<pre><code class="language-tsx">const fetchUserAndCompany = async () =&gt; {
  const response = await fetch(`https://myBackend.com/userAndCompany`);
  return JSON.parseImmutable(await response.text());
};
</code></pre>
<p>우연히도 JSON은 레코드 및 튜플과 호환되며, <a href="https://github.com/tc39/proposal-record-tuple#jsonparseimmutable">JSON.parseImmutable</a>을 사용하여 모든 백엔드 응답을 레코드로 변환할 수 있어야 합니다.</p>
<p><strong>참고</strong>: 제안 작성자 중 한 명인 <a href="https://twitter.com/r_ricard">Robin Ricard</a>는 새로운 <code>response.immutableJson()</code> 함수를 추진하고 있습니다.</p>
<p>레코드 및 튜플을 사용하면 백엔드에서 동일한 데이터를 반환하면 <strong>아무것도 리렌더링하지</strong> 않습니다!</p>
<p>또한 응답의 한 부분만 변경된 경우에도 응답의 다른 중첩 객체는 여전히 <strong>아이덴티티를 유지</strong>합니다. 즉, <code>user.name</code>만 변경된 경우 <code>User</code> 컴포넌트는 리렌더링되지만 <code>Company</code> 컴포넌트는 렌더링되지 않습니다!</p>
<p>&quot;Stale-While-Revalidate&quot;와 같은 패턴이 점점 더 대중화되  고 있고 SWR, React-Query, Apollo, Relay와 같은 라이브러리에서 기본으로 제공된다는 점을 고려할 때 이 모든 것이 성능에 미치는 영향을 상상해 보겠습니다.</p>
<h2 id="쿼리-문자열-읽기">쿼리 문자열 읽기</h2>
<p>검색 UI에서는 쿼리 문자열에 필터의 상태를 <strong>보존</strong>하는 것이 좋습니다. 그러면 사용자는 링크를 복사/붙여넣거나 페이지를 새로고침하거나 북마크할 수 있습니다.</p>
<p>필터가 1~2개라면 간단하지만, 검색 UI가 복잡해지면(필터가 10개 이상, AND/OR 로직으로 쿼리를 작성하는 기능 등) 쿼리 문자열을 관리하기 위해 좋은 추상화를 사용하는 것이 좋습니다.</p>
<p>저는 개인적으로 <a href="https://github.com/ljharb/qs">qs</a>를 좋아합니다. 중첩 객체를 제대로 처리하는 몇 안 되는 라이브러리 중 하나이기 때문입니다.</p>
<pre><code class="language-tsx">const queryStringObject = {
  filters: {
    userName: &quot;Sebastien&quot;,
  },
  displayMode: &quot;list&quot;,
};
const queryString = qs.stringify(queryStringObject);
const queryStringObject2 = qs.parse(queryString);
assert.deepEqual(queryStringObject, queryStringObject2);
assert(queryStringObject !== queryStringObject2);
</code></pre>
<p><code>queryStringObject</code>와 <code>queryStringObject2</code>는 매우 동일하지만, <code>qs.parse</code>가 새 객체를 생성하기 때문에 더 이상 동일하지 않습니다.</p>
<p>쿼리 문자열 구문 분석을 후크에 통합하고 <code>useMemo()</code> 또는 <a href="https://github.com/discord/use-memo-value">use-memo-value</a>와 같은 라이브러리를 사용하여 쿼리 문자열 객체를 &quot;안정화&quot;할 수 있습니다.</p>
<pre><code class="language-tsx">const useQueryStringObject = () =&gt; {
  // Provided by your routing library, like React-Router
  const { search } = useLocation();
  return useMemo(() =&gt; qs.parse(search), [search]);
};
</code></pre>
<p> 이제 트리의 더 깊은 곳을 상상해 보세요:</p>
<pre><code class="language-tsx">const { filters } = useQueryStringObject();
useEffect(() =&gt; {
  fetchUsers(filters).then(setUsers);
}, [filters]);
</code></pre>
<p>이것은 약간 지저분하지만 같은 문제가 반복해서 발생합니다.</p>
<p><code>queryStringObject</code> 아이덴티티를 보존하기 위해 <code>useMemo()</code>를 사용했음에도 불구하고 원치 않는 <code>fetchUsers</code> 호출이 발생하게 됩니다.</p>
<p>사용자가 (다시 불러오기를 트리거하지 않고 렌더링 로직만 변경해야 하는) <code>displayMode</code>를 업데이트하면 쿼리 문자열이 변경되어 쿼리 문자열이 다시 구문 분석되고 <code>filter</code> 속성에 대한 새로운 객체 ID가 생성되어 원치 않는 <code>useEffect</code> 실행으로 이어집니다.</p>
<p>다시 말하지만, 레코드 및 튜플은 이러한 일이 발생하지 않도록 방지합니다.</p>
<pre><code class="language-tsx">// This is a non-performant, but working solution.
// Lib authors should provide a method such as qs.parseRecord(search)
const parseQueryStringAsRecord = (search) =&gt; {
  const queryStringObject = qs.parse(search);
  // Note: the Record(obj) conversion function is not recursive
  // There&#x27;s a recursive conversion method here:
  // https://tc39.es/proposal-record-tuple/cookbook/index.html
  return JSON.parseImmutable(JSON.stringify(queryStringObject));
};
const useQueryStringRecord = () =&gt; {
  const { search } = useLocation();
  return useMemo(() =&gt; parseQueryStringAsRecord(search), [search]);
};
</code></pre>
<p>이제 사용자가 <code>displayMode</code>를 업데이트하더라도 <code>filters</code> 객체는 그 아이덴티티를 유지하며 쓸모없는 리페치를 트리거하지 않습니다.</p>
<p><strong>참고</strong>: 레코드 및 튜플 제안이 받아들여지면 <code>qs</code>와 같은 라이브러리에서 <code>qs.parseRecord(search)</code> 메서드를 제공할 가능성이 높습니다.</p>
<h3 id="매우-동등한-js-변환">매우 동등한 JS 변환</h3>
<p>컴포넌트에서 다음과 같은 JS 변환을 상상해 보세요:</p>
<pre><code class="language-tsx">const AllUsers = [
  { id: 1, name: &quot;Sebastien&quot; },
  { id: 2, name: &quot;John&quot; },
];
const Parent = () =&gt; {
  const userIdsToHide = useUserIdsToHide();
  const users = AllUsers.filter((user) =&gt; !userIdsToHide.includes(user.id));
  return &lt;UserList users={users} /&gt;;
};
const UserList = React.memo(({ users }) =&gt; (
  &lt;ul&gt;
    {users.map((user) =&gt; (
      &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
    ))}
  &lt;/ul&gt;
));
</code></pre>
<p><code>filter</code>는 항상 <strong>새 배열 인스턴스</strong>를 반환하기 때문에 <code>Parent</code> 컴포넌트가 리렌더링될 때마다 <code>UserList</code> 컴포넌트도 리렌더링됩니다.</p>
<p>이는 <code>userIdsToHide</code>가 비어 있고 <code>AllUsers</code> 아이덴티티가 안정된 경우에도 마찬가지입니다! 이 경우 필터 연산은 실제로 아무것도 필터링하지 않고, 단지 <strong>쓸모없는 배열 인스턴스를 새로 생성</strong>하여 <code>React.memo</code> 최적화를 선택 해제합니다.</p>
<p>이러한 종류의 변환은 components, reducers, selectors, Redux 등 <code>map</code> 또는 <code>filter</code>와 같은 연산자를 사용하는 React 코드베이스에서 매우 흔합니다.</p>
<p>메모화를 통해 이 문제를 해결할 수 있지만, 레코드와 튜플을 사용하는 것이 더 관용적입니다:</p>
<pre><code class="language-tsx">const AllUsers = #[
  #{ id: 1, name: &#x27;Sebastien&#x27; },
  #{ id: 2, name: &#x27;John&#x27; },
];
const filteredUsers = AllUsers.filter(() =&gt; true);
AllUsers === filteredUsers;
// true
</code></pre>
<h3 id="react-키로써의-레코드">React 키로써의 레코드</h3>
<p>렌더링할 항목 목록이 있다고 가정해 봅시다:</p>
<pre><code class="language-tsx">const list = [
  { country: &quot;FR&quot;, localPhoneNumber: &quot;111111&quot; },
  { country: &quot;FR&quot;, localPhoneNumber: &quot;222222&quot; },
  { country: &quot;US&quot;, localPhoneNumber: &quot;111111&quot; },
];
</code></pre>
<p>어떤 키를 사용하시겠습니까?</p>
<p><code>country</code>와 <code>localPhoneNumber</code>가 모두 목록에서 <strong>독립적으로 고유하지</strong> 않다는 점을 고려하면 두 가지 선택지가 있습니다.</p>
<p><strong>배열 인덱스 키</strong>:</p>
<pre><code class="language-tsx">&lt;&gt;
  {list.map((item, index) =&gt; (
    &lt;Item key={`poormans_key_${index}`} item={item} /&gt;
  ))}
&lt;/&gt;
</code></pre>
<p>이 방법은 항상 작동하지만, 특히 <strong>목록의 항목이 재정렬된 경우</strong>에는 이상적이지 않습니다.</p>
<p><strong>복합 키</strong>:</p>
<pre><code class="language-tsx">&lt;&gt;
  {list.map((item) =&gt; (
    &lt;Item key={`${item.country}_${item.localPhoneNumber}`} item={item} /&gt;
  ))}
&lt;/&gt;
</code></pre>
<p>이 솔루션은 **목록 재순서를 더 잘 처리하지만 **커플/튜플이 고유하다는 것을 확실히 알고 있는 경우에만 가능합니다.</p>
<p>이런 경우에는 <strong>레코드를 키로</strong> 직접 사용하는 것이 **더 편리하지 않을까요?</p>
<pre><code class="language-tsx">const list = #[
  #{ country: &#x27;FR&#x27;, localPhoneNumber: &#x27;111111&#x27; },
  #{ country: &#x27;FR&#x27;, localPhoneNumber: &#x27;222222&#x27; },
  #{ country: &#x27;US&#x27;, localPhoneNumber: &#x27;111111&#x27; },
];
&lt;&gt;
  {list.map((item) =&gt; (
    &lt;Item key={item} item={item} /&gt;
  ))}
&lt;/&gt;
</code></pre>
<p>이것은 <a href="https://twitter.com/barklund">Morten Barklund</a>가 <a href="https://twitter.com/barklund/status/1289273309889064960">제안</a>했습니다.</p>
<h3 id="명시적-api-서페이스">명시적 API 서페이스</h3>
<p>이 TypeScript 컴포넌트를 살펴봅시다:</p>
<pre><code class="language-tsx">const UsersPageContent = ({ usersFilters }: { usersFilters: UsersFilters }) =&gt; {
  const [users, setUsers] = useState([]);
  // poor-man&#x27;s fetch
  useEffect(() =&gt; {
    fetchUsers(usersFilters).then(setUsers);
  }, [usersFilters]);
  return &lt;Users users={users} /&gt;;
};
</code></pre>
<p>이 코드는 앞서 살펴본 것처럼 usersFilters 프로퍼티의 안정성에 따라 무한 루프를 생성할 수도 있고 생성하지 않을 수도 있습니다. 이렇게 하면 상위 컴포넌트의 구현자가 문서화하여 명확하게 이해해야 하는 암시적 API 계약이 생성되며, TypeScript를 사용하지만 유형 시스템에는 반영되지 않습니다.</p>
<p>다음은 무한 루프로 이어질 수 있지만 TypeScript에는 이를 방지할 방법이 없습니다:</p>
<pre><code class="language-tsx">&lt;UsersPageContent usersFilters={{ nameFilter, ageFilter }} /&gt;
</code></pre>
<p>레코드 및 튜플을 사용하면 TypeScript가 레코드를 예상하도록 지시할 수 있습니다:</p>
<pre><code class="language-tsx">const UsersPageContent = ({
  usersFilters,
}: {
  usersFilters: #{nameFilter: string, ageFilter: string}
}) =&gt; {
  const [users, setUsers] = useState([]);
  // poor-man&#x27;s fetch
  useEffect(() =&gt; {
    fetchUsers(usersFilters).then(setUsers);
  }, [usersFilters]);
  return &lt;Users users={users} /&gt;;
};
</code></pre>
<p><strong>참고</strong>: <code>#{nameFilter: string, ageFilter: string}</code>은 제가 직접 고안한 것입니다. 아직 TypeScript 구문이 어떻게 될지 알 수 없습니다.</p>
<p>다음 코드는 TypeScript 컴파일이 실패합니다:</p>
<pre><code class="language-tsx">&lt;UsersPageContent usersFilters={{ nameFilter, ageFilter }} /&gt;
</code></pre>
<p>다음 코드는 컴파일을 문제없이 허용하지만요.</p>
<pre><code class="language-tsx">&lt;UsersPageContent
  usersFilters={#{ nameFilter, ageFilter }}
/&gt;
</code></pre>
<p>레코드와 튜플을 사용하면 <strong>컴파일 시간</strong>에 이러한 무한 루프를 방지할 수 있습니다.</p>
<p>컴파일러에 <strong>구현이 객체 식별에 민감</strong>(또는 값별 비교에 의존)하다는 것을 <strong>명시적으로</strong> 알릴 수 있는 방법이 있습니다.</p>
<p><strong>참고</strong>: <code>readonly</code>은 이 문제를 해결하지 못합니다. 변이를 방지할 수는 있지만 안정적인 아이덴티티를 보장하지 못하기 때문입니다.</p>
<h3 id="직렬화-보장">직렬화 보장</h3>
<p>팀의 개발자가 직렬화할 수 없는 것을 글로벌 앱 상태에 넣지 않도록 하고 싶을 수 있습니다. 이는 상태를 백엔드로 보내거나 <code>localStorage</code>(또는 React-Native 사용자의 경우 <code>AsyncStorage</code>)에 로컬로 유지하려는 경우 중요합니다.</p>
<p>이를 보장하려면 루트 객체가 레코드인지 확인하기만 하면 됩니다. 이렇게 하면 중첩된 레코드와 튜플을 포함한 모든 중첩된 어트리뷰트도 프리미티브가 됩니다.</p>
<p>다음은 시간이 지나도 Redux 저장소를 계속 직렬화할 수 있도록 Redux와 통합한 예시입니다:</p>
<pre><code class="language-tsx">if (process.env.NODE_ENV === &quot;development&quot;) {
  ReduxStore.subscribe(() =&gt; {
    if (typeof ReduxStore.getState() !== &quot;record&quot;) {
      throw new Error(
        &quot;Don&#x27;t put non-serializable things in the Redux store! &quot; +
          &quot;The root Redux state must be a record!&quot;,
      );
    }
  });
}
</code></pre>
<p><strong>참고</strong>: 레코드에 넣을 수 있으면서도 직렬화될 수는 없는 <code>심볼</code>이 있으므로 완벽하게 안정된 보장은 아닙니다.</p>
<h3 id="css-in-js-성능">CSS-in-JS 성능</h3>
<p>인기 있는 라이브러리에서 css 프로퍼티를 사용한 CSS-in-JS를 살펴봅시다:</p>
<pre><code class="language-tsx">const Component = () =&gt; (
  &lt;div
    css={{
      backgroundColor: &quot;hotpink&quot;,
    }}
  &gt;
    This has a hotpink background.
  &lt;/div&gt;
);
</code></pre>
<p>CSS-in-JS 라이브러리는 리렌더링할 때마다 새 CSS 객체를 받습니다.</p>
<p>처음 렌더링할 때 이 객체를 고유한 클래스 이름으로 해시하고 CSS를 삽입합니다. 스타일 객체는 리렌더링할 때마다 다른 아이덴티티를 가지며, CSS-in-JS 라이브러리는 이를 <strong>해시하고 또 해시</strong>해야 합니다.</p>
<pre><code class="language-tsx">const insertedClassNames = new Set();
function handleStyleObject(styleObject) {
  // computeStyleHash re-executes every time
  const className = computeStyleHash(styleObject);
  // only insert the css for this className once
  if (!insertedClassNames.has(className)) {
    insertCSS(className, styleObject);
    insertedClassNames.add(className);
  }
  return className;
}
</code></pre>
<p>레코드 및 튜플을 사용하면 이러한 스타일 객체의 ID가 시간이 지나도 보존됩니다.</p>
<pre><code class="language-tsx">const Component = () =&gt; (
  &lt;div
    css={#{
      backgroundColor: &#x27;hotpink&#x27;,
    }}
  &gt;
    This has a hotpink background.
  &lt;/div&gt;
);
</code></pre>
<p>레코드 및 튜플을 <a href="https://github.com/tc39/proposal-record-tuple#usage-in-mapsetweakmapweakset">맵 키로 사용할 수 있습니다</a>. 이렇게 하면 CSS-in-JS 라이브러리를 더 빠르게 구현할 수 있습니다:</p>
<pre><code class="language-tsx">const insertedStyleRecords = new Map();
function handleStyleRecord(styleRecord) {
  let className = insertedStyleRecords.get(styleRecord);
  if (!className) {
    // computeStyleHash is only executed once!
    className = computeStyleHash(styleRecord);
    insertCSS(className, styleRecord);
    insertedStyleRecords.add(styleRecord, className);
  }
  return className;
}
</code></pre>
<p>레코드 및 튜플의 <a href="https://github.com/tc39/proposal-record-tuple#what-are-the-performance-expectations-of-these-data-structures">성능</a>에 대해서는 아직 알 수 없지만(브라우저 공급업체 구현에 따라 달라질 수 있음), 동등한 객체를 생성한 다음 클래스 이름으로 해싱하는 것보다 빠를 것이라고 말하는 것이 안전할 것 같습니다.</p>
<p><strong>참고</strong>: 좋은 Babel 플러그인이 포함된 일부 CSS-in-JS 라이브러리는 컴파일 시 정적 스타일 객체를 상수로 변환할 수 있지만, 동적 스타일에서는 변환하는 데 어려움을 겪을 수 있습니다.</p>
<pre><code class="language-tsx">const staticStyleObject = { backgroundColor: &quot;hotpink&quot; };
const Component = () =&gt; (
  &lt;div css={staticStyleObject}&gt;This has a hotpink background.&lt;/div&gt;
);
</code></pre>
<h2 id="결론">결론</h2>
<p>많은 React 성능 및 동작 문제는 객체 ID와 관련이 있습니다.</p>
<p><strong>레코드와 튜플</strong>은 일종의 &quot;자동 메모화&quot;를 제공함으로써 객체 아이덴티티가 기본적으로 &quot;더 안정적&quot;이 되도록 보장하고, 이러한 React 문제를 더 쉽게 해결할 수 있도록 도와줍니다.</p>
<p>TypeScript를 사용하면 API 표면이 <strong>객체 ID에 민감</strong>하다는 것을 더 잘 표현할 수 있습니다.</p>
<p>여러분도 저만큼이나 이 제안에 흥미를 느끼셨으면 좋겠습니다!</p>
<p>읽어주셔서 감사합니다!</p>
<p>이 멋진 제안서를 작성하고 제 글을 검토해 주신 <a href="https://twitter.com/r_ricard">Robin Ricard</a>, <a href="https://twitter.com/rickbutton">Rick Button</a>, <a href="https://twitter.com/littledan">Daniel Ehrenberg</a>, <a href="https://twitter.com/NicoloRibaudo">Nicolò Ribaudo</a>, <a href="https://twitter.com/robpalmer2">Rob Palmer</a>에게 감사의 인사를 전합니다.</p>
<p>마음에 드신다면 <a href="https://twitter.com/sebastienlorber/status/1289222799882481665">트위터</a>, <a href="https://dev.to/sebastienlorber/records-tuples-for-react-way-more-than-immutability-2iic">개발자</a>, <a href="https://www.reddit.com/r/reactjs/comments/i19y22/records_tuples_for_react/">레딧</a> 또는 <a href="https://news.ycombinator.com/item?id=24010282">해커뉴스</a>에서 널리 알려주세요.</p>
<p>브라우저 코드 데모 또는 <a href="https://github.com/slorber/sebastienlorber.com/tree/master/content/posts/2020-07-31-records-and-tuples-for-react-developers">블로그 저장소</a>에서 내 게시물 오타 수정하기</p>
<p>이와 같은 더 많은 콘텐츠를 보시려면 <a href="https://thisweekinreact.com/">This Week In React</a>를 구독하고 <a href="https://twitter.com/sebastienlorber">트위터</a>에서 저를 팔로우하세요.</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="블로그 게시물 탐색"><a class="pagination-nav__link pagination-nav__link--prev" href="/wiki/blog/the-effect-of-ai-on-cyber-security"><div class="pagination-nav__sublabel">이전 게시물</div><div class="pagination-nav__label">인공지능이 사이버 보안에 끼치는 영향</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/wiki/blog/remote-git-hosting-and-publishing"><div class="pagination-nav__sublabel">다음 게시물</div><div class="pagination-nav__label">Remote Git Hosting and Publishing</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#레코드와-튜플-101" class="table-of-contents__link toc-highlight">레코드와 튜플 101</a></li><li><a href="#react를-위한-레코드와-튜플" class="table-of-contents__link toc-highlight">React를 위한 레코드와 튜플</a></li><li><a href="#불변성" class="table-of-contents__link toc-highlight">불변성</a></li><li><a href="#불변-업데이트" class="table-of-contents__link toc-highlight">불변 업데이트</a></li><li><a href="#usememo" class="table-of-contents__link toc-highlight">useMemo</a><ul><li><a href="#useeffect" class="table-of-contents__link toc-highlight">useEffect</a></li><li><a href="#props와-reactmemo" class="table-of-contents__link toc-highlight">Props와 React.memo</a></li></ul></li><li><a href="#불러오기-및-다시-불러오기" class="table-of-contents__link toc-highlight">불러오기 및 다시 불러오기</a></li><li><a href="#쿼리-문자열-읽기" class="table-of-contents__link toc-highlight">쿼리 문자열 읽기</a><ul><li><a href="#매우-동등한-js-변환" class="table-of-contents__link toc-highlight">매우 동등한 JS 변환</a></li><li><a href="#react-키로써의-레코드" class="table-of-contents__link toc-highlight">React 키로써의 레코드</a></li><li><a href="#명시적-api-서페이스" class="table-of-contents__link toc-highlight">명시적 API 서페이스</a></li><li><a href="#직렬화-보장" class="table-of-contents__link toc-highlight">직렬화 보장</a></li><li><a href="#css-in-js-성능" class="table-of-contents__link toc-highlight">CSS-in-JS 성능</a></li></ul></li><li><a href="#결론" class="table-of-contents__link toc-highlight">결론</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">문서</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/wiki/docs/intro">튜토리얼</a></li></ul></div><div class="col footer__col"><div class="footer__title">커뮤니티</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">스택오버플로우<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">디스코드<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">트위터<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">더보기</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/wiki/blog">블로그</a></li><li class="footer__item"><a href="https://github.com/AndrewDongminYoo/wiki" target="_blank" rel="noopener noreferrer" class="footer__link-item">깃허브<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Dongmin Yu, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>