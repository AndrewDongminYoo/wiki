<!doctype html>
<html lang="ko" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.0.0">
<title data-rh="true">블로그 | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://andrewdongminyoo.github.io/wiki/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://andrewdongminyoo.github.io/wiki/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://andrewdongminyoo.github.io/wiki/blog/page/5"><meta data-rh="true" property="og:locale" content="ko"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" property="og:title" content="블로그 | My Site"><meta data-rh="true" name="description" content="블로그"><meta data-rh="true" property="og:description" content="블로그"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="icon" href="/wiki/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://andrewdongminyoo.github.io/wiki/blog/page/5"><link data-rh="true" rel="alternate" href="https://andrewdongminyoo.github.io/wiki/blog/page/5" hreflang="ko"><link data-rh="true" rel="alternate" href="https://andrewdongminyoo.github.io/wiki/blog/page/5" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://W3IYVVWLWE-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/wiki/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/wiki/blog/atom.xml" title="My Site Atom Feed">



<link rel="search" type="application/opensearchdescription+xml" title="My Site" href="/wiki/opensearch.xml"><link rel="stylesheet" href="/wiki/assets/css/styles.87524305.css">
<script src="/wiki/assets/js/runtime~main.08d7e581.js" defer="defer"></script>
<script src="/wiki/assets/js/main.7baa3f39.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="본문으로 건너뛰기"><a class="skipToContent_D8pK" href="#__docusaurus_skipToContent_fallback">본문으로 건너뛰기</a></div><nav aria-label="메인" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="네비게이션 바 토글하기" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/wiki/"><div class="navbar__logo"><img src="/wiki/img/logo.svg" alt="내 사이트 로고" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/wiki/img/logo.svg" alt="내 사이트 로고" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">내 사이트</b></a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>한국어</a><ul class="dropdown__menu"><li><a href="/wiki/blog/page/5" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="ko">한국어</a></li></ul></div><a class="navbar__item navbar__link" href="/wiki/docs/intro">튜토리얼</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/wiki/blog">블로그</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/AndrewDongminYoo/wiki" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">깃허브<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="검색"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">검색</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="최근 블로그 문서 둘러보기"><div class="sidebarItemTitle_pO2u margin-bottom--md">최신글</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/blog/front-backend-developer-roadmap">프론트+백엔드 개발자 로드맵</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/blog/static-property-in-java-class">Static Property in Java Class</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/blog/four-mainstream-d-bs-and-features">  가장 많이 사용되는 주류 DB 4가지와 특징</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/blog/generate-unicode-emoji-regular-expression">Generate Unicode emoji regular expression</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/blog/redirection-of-the-website">웹사이트의 리다이렉팅 방식</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="https://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="Node.js의 Vite와 Deno"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/another-runtimes-of-javascript">Another Runtimes of JavaScript</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-03-20T00:00:00.000Z" itemprop="datePublished">2023년 3월 20일</time> · <!-- -->약 21분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="nodejs의-vite와-deno">Node.js의 Vite와 Deno</h2>
<p>Node.js는 가장 오래되고 널리 사용되는 런타임이며, Vite는 Node.js 기반의 개발 서버이자 빌드 도구입니다. Deno는 Node.js의 창시자인 라이언 달이 만든  새로운 런타임으로, 보안과 현대적인 표준을 강조합니다.
Vite와 Deno는 현재 호환되지 않습니다. Vite는 Node.js에 의존하는 많은 패키지들을 사용하고 있으며, Deno는 Node.js와 다른 모듈 시스템과 API를 가지고 있습니다. 하지만 앞으로 Deno가 npm 패키지들을 지원하게 되면, Vite와 Deno가 함께 작동할 수 있도록 하는 프로젝트들이 진행 중입니다.</p>
<h3 id="references">References</h3>
<p>(1) <a href="https://kdydesign.github.io/2022/02/17/deno-tutorial/">[Deno] Node.js의 대안!! Deno 알아보기 - Dev. DY</a>
(2) <a href="https://www.itworld.co.kr/news/250828">&quot;데노 vs. Node.js&quot; JS 런타임 선택 가이드 - ITWorld Korea</a>
(3) <a href="https://github.com/vitejs/vite/issues/109">Vite can support deno runtime? · Issue #109 · vitejs/vite · GitHub</a>
(4) <a href="https://dev.to/vonheikemen/vite-and-deno-an-experiment-1jdf">vite and deno: an experiment - DEV Community</a>
(5) <a href="https://github.com/denoland/deno/issues/15427">Support Vite · Issue #15427 · denoland/deno · GitHub</a>
(6) <a href="https://swtpumpkin.github.io/backend/deno/denoVsNode/">deno와 node.js 비교 | Swtpumpkin Blog</a></p>
<h2 id="주목받는-자바스크립트-런타임-환경">주목받는 자바스크립트 런타임 환경</h2>
<p>자바스크립트 런타임 환경은 자바스크립트 코드를 실행할 수 있는 환경을 말합니다. 브라우저 역시 자바스크립트 런타임 환경 중 하나입니다.</p>
<ul>
<li><strong>React Native</strong>: React Native는 모바일 앱 개발을 위한 자바스크립트 런타임 환경입니다. React Native는 네이티브 모듈과 통신하면서 자바스크립트 코드를 실행합니다. React Native의 장점은 웹 개발자가 쉽게 모바일 앱을 만들 수 있다는 것이고, 단점은 성능이나 디버깅이 어렵다는 것입니다.</li>
<li><strong>Electron</strong>: Electron은 데스크톱 애플리케이션 개발을 위한 자바 스크립트 런타임 환경입니다. Electron은 Node.js와 Chromium을 결합하여 웹 기술로 데스크톱 애플리케이션을 만들 수 있게 합니다. Electron의 장점은 크로스 플랫폼 개발이 쉽다는 것이고, 단점은 메모리 사용량이 많다는 것입니다.</li>
<li><strong>QuickJS</strong>: QuickJS는 가볍고 임베디드 시스템에 적합한 자바스크립트 엔진입니다. QuickJS는 C 언어로 작성되었으며, ES2020 표준을 지원합니다. QuickJS의 장점은 속도가 빠르고 메모리 사용량이 적다는 것이고, 단점은 아직 안정성이나 호환성이 부족하다는 것입니다.</li>
<li><strong>Duktape</strong>: Duktape는 C 언어로 작성된 임베디드 자바스크립트 엔진입니다. Duktape는 ES5 표준을 지원하며, ES6의 일부 기능도 사용할 수 있습니다. Duktape의 장점은 메모리 사용량이 적고 소스 코드가 작다는 것이고, 단점은 성능이나 호환성이 낮다는 것입니다.</li>
<li><strong>GraalVM</strong>: GraalVM은 자바스크립트를 비롯한 여러 언어를 실행할 수 있는 고성능 런타임 환경입니다. GraalVM은 JIT 컴파일러와 폴리글랏 엔진을 통해 다양한 언어 간의 상호 운용성과 최적화를 제공합니다. GraalVM의 장점은 속도가 빠르고 유연하다는 것이고, 단점은 설치나 설정이 복잡하다는 것입니다.</li>
<li><strong>Rhino</strong>: Rhino는 자바로 작성된 자바스크립트 엔진입니다. Rhino는 자바와 자바스크립트 간의 통합을 쉽게 할 수 있게 해줍니다. Rhino의 장점은 자바와 호환되고 안정적이라는 것이고, 단점은 성능이나 메모리 사용량이 높다는 것입니다.</li>
</ul>
<h3 id="references-1">References</h3>
<p>(1) <a href="https://www.itworld.co.kr/news/250828">&quot;데노 vs. Node.js&quot; JS 런타임 선택 가이드 - ITWorld Korea</a>
(2) <a href="https://beomy.github.io/tech/javascript/javascript-runtime/">[JavaScript] 자바스 크립트 런타임 | Beomy</a>
(3) <a href="https://velog.io/@vrisel/JavaScript-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%B9%84%EA%B5%90">JavaScript 기반 라이브러리, 프레임워크 비교</a>
(4) <a href="https://beomy.github.io/tech/javascript/javascript-runtime/">[JavaScript] 자바스크립트 런타임 | Beomy</a>
(5) <a href="https://velog.io/@cseon230/">런타임 환경</a>
(6) <a href="https://www.java.com/ko/download/help/update_runtime_settings.html">Windows에서 Java 런타임 설정 업데이트</a></p>
<h2 id="vite와-deno">Vite와 Deno</h2>
<p>Vite는 자바스크립트 빌드 도구이고, Deno는 자바스크립트 런타임 환경입니다.
Vite는 웹팩과 같은 번들러를 대체하는 빌드 도구입니다. Vite는 ES 모듈을 기반으로 하여 개발 서버와 프로덕션 빌드를 제공합니다. Vite의 장점은 속도가 빠르고 설정이 쉽다는 것이고, 단점은 호환성이나 안정성이 낮다는 것입니다.
Deno는 Node.js와 유사한 자바스크립트와 타입스크립트를 위한 런타임 환경입니다. Deno는 보안과 표준을 중시하며, URL을 통해 모듈을 가져올 수 있습니다. Deno의 장점은 보안이 강하고 타입스크립트를 지원한다는 것이고, 단점은 생태계가 작고 호환성이 낮다는 것입니다.</p>
<h3 id="references-2">References</h3>
<p>(1) <a href="https://ui.toast.com/weekly-pick/ko_20220127/">차세대 빌드 도구 비교 | TOAST UI :: Make Your Web Delicious!</a>
(2) <a href="https://dev.to/vonheikemen/vite-and-deno-an-experiment-1jdf">vite and deno: an experiment - DEV Community</a>
(3) <a href="https://kdydesign.github.io/2022/02/17/deno-tutorial/">[Deno] Node.js의 대안!! Deno 알아보기 - Dev. DY</a></p>
<h2 id="자바스크립트-빌드-도구">자바스크립트 빌드 도구</h2>
<p>자바스크립트 빌드 도구에는 웹팩, 롤업, 스노우팩, Vite 등이 있습니다.
웹팩은 가장 널리 사용되는 빌드 도구로, 모듈 번들러라고도 합니다.   웹팩은 자바스크립트뿐만 아니라 HTML, CSS, 이미지 등의 리소스도 모듈로 취급하여 의존성을 분석하고 하나의 파일로 번들링합니다. 웹팩의 장점은 다양한 플러그인과 로더를 통해 많은 기능을 제공한다는 것이고, 단점은 설정이 복잡하고 느리다는 것입니다.
롤업은 웹팩과 유사한 모듈 번들러입니다. 롤업은 ES 모듈을 기준으로 하여 트리 쉐이킹과 코드 스플리팅을 지원합니다. 롤업의 장점은 ES 모듈을 최적화하여 작고 효율적인 번들을 생성한다는 것이고, 단점은 웹팩보다 지원하는 기능이 적다는 것입니다.
스노우팩과 Vite는 ES 모듈을 기반으로 한 차세대 빌드 도구입니다. 스노우팩과 Vite는 개발 서버와 프로덕션 빌드를 제공합니다. 스노우팩과 Vite의 장점은 속도가 빠르고 설정이 쉽다는 것이고, 단점은 호환성이나 안정성이 낮다는 것입니다.</p>
<h3 id="references-3">References</h3>
<p>(1) <a href="https://explorejs.tistory.com/24">자바스크립트 개발 도구와 테스트-3 :: JS 탐구생활</a>
(2) <a href="https://colinch4.github.io/2021-06-17/chap02/">[learning javascript] chapter 2. 자바스크립트 개발 도구</a>
(3) <a href="https://ui.toast.com/posts/ko_20220127/">차세대 빌드 도구 비교 | TOAST UI :: Make Your Web Delicious!</a></p>
<p>웹팩 빌드 도구를 베이스로 하는 프레임워크는 Nuxt.js와 Next.js 등이 있습니다. 이들은 웹팩을 사용하여 서버 측 렌더링을 지원하는 메타 프레임워크입니다.
바벨은 웹팩과 별개의 도구로, 자바스크립트 코드를 변환해주는 컴파일러입니다. 바벨은 최신 자바스크립트 문법을 구형 브라우저에서도 동작할 수 있도록 호환성을 보장해줍니다. 웹팩은 바벨을 로더로 사용하여 모듈 번들링 과정에서 코드 변환을 수행할 수 있습니다.</p>
<h3 id="references-4">References</h3>
<p>(1) <a href="https://ui.toast.com/weekly-pick/ko_20220127/">차세대 빌드 도구 비교 | TOAST UI :: Make Your Web Delicious!</a>
(2) <a href="https://devlog.jwgo.kr/2018/12/03/webpack-babel-react/">웹팩과 바벨 무엇이 다른가. 리액트에서는 뭘 써야 할까? · Tonic</a>
(3) <a href="https://berkbach.com/%EC%9B%B9%ED%8C%A9-webpack-%EA%B3%BC-%EB%B0%94%EB%B2%A8-babel-%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-react-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0-fb87d0027766">Webpack과 Babel을 이용한 React 개발 환경 구성하기 | Berkbach</a>
(4) <a href="https://hoilzz.github.io/webpack/2-add-babel/">[나만의 웹팩 만들기] 2. babel 추가하기 | hoilzz</a>
(5) <a href="https://www.hanl.tech/blog/webpack%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-%EC%A0%95%EC%9D%98%EC%99%80-%ED%95%84%EC%9A%94%EC%84%B1-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%9E%A5%EB%8B%A8%EC%A0%90/">Webpack이란 무엇인가? 정의와 필요성, 그리고 장단점 | 하늘네트</a>
(6) <a href="https://appmaster.io/ko/blog/10gaji-coegoyi-web-baegendeu-peureimweokeu">2022년 웹 개발을 위한 상위 10가지 최고의 웹 백엔드 프레임워크 ...</a></p>
<h2 id="parcel-번들러">Parcel 번들러</h2>
<p>Parcel도 웹팩과 비슷한 번들러입니다. Parcel은 웹팩보다 설정이 간단하고 빠른 번들링 속도를 자랑합니다. 하지만 웹팩보다는 기능이 적고 커스터마이징이 어렵습니다.
웹팩 대체 번들러로는 Vite, Rollup, Snowpack 등이 있습니다. 이들은 모두 웹팩보다 더 빠르고 간편하게 번들링을 할 수 있다고 주장합니다. 하지만 각각 장단점이 있으므로 프로젝트의 목적과 요구사항에 따라 적절한 번들러를 선택하는 것이 중요합니다.</p>
<h3 id="references-5">References</h3>
<p>(1) <a href="https://ko.parceljs.org/">Parcel 한국어판</a>
(2) <a href="https://ko.parceljs.org/getting_started.html">🚀 시작하기</a>
(3) <a href="https://ropung.tistory.com/21">리액트 프  로젝트 초기 설정 - CRA vs Vite</a>
(4) <a href="https://velog.io/@joabyjoa/Parcel">Parcel로 빠르게 프로젝트 시작하기</a>
(5) <a href="https://velog.io/@uoayop/">Webpack : 웹팩 찍먹하기 (+ module, bundler, loader)</a>
(6) <a href="https://sunny921.github.io/posts/webpack-1/">(Webpack) 웹팩 - 모듈 번들러와 로더 | Let&#x27;s Sunny</a></p>
<h2 id="웹팩이-모듈화할-수-있는-리소스">웹팩이 모듈화할 수 있는 리소스</h2>
<p>웹팩은 모듈 번들러로서, 자바스크립트 파일뿐만 아니라 CSS, HTML, 이미지, 폰트 등의 리소스 파일도 모듈로 취급합니다. 이렇게 하면 각 리소스 파일을 재사용하고 의존성 관리를 할 수 있습니다.</p>
<ul>
<li>ECMAScript 모듈</li>
<li>CommonJS 모듈</li>
<li>AMD 모듈</li>
<li>Assets (CSS, HTML, 이미지, 폰트 등)</li>
<li>WebAssembly 모듈</li>
</ul>
<p>그 밖에도 웹팩은 로더를 통해 다양한 언어와 전처리기로 작성된 모듈을 지원합니다. 예를 들어 TypeScript, Sass, Babel 등의 로더가 있습니다.</p>
<h3 id="references-6">References</h3>
<p>(1) <a href="https://pathas.tistory.com/219">JavaScript | Webpack 기초 정리 :: Pathas&#x27; Path as Web Developer</a>
(2) <a href="https://junhee-hee.tistory.com/entry/%EC%8A%A4%ED%84%B0%EB%94%94-with-%EC%8B%A4%EC%A0%84-%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-17%ED%8E%B8-%EC%9B%B9%ED%8C%A9">[스터디 with 실전 리액트 프로그래밍] 17편 - 웹팩</a>
(3) <a href="https://webpack.kr/configuration/module/">Module | 웹팩</a>
(4) <a href="https://webpack.kr/concepts/modules">Modules | 웹팩</a>
(5) <a href="https://velog.io/@uoayop/">Webpack : 웹팩 찍먹하기 (+ module, bundler, loader)</a></p>
<p>웹팩의 로더와 플러그인은 다음과 같이 차이점이 있습니다.</p>
<ul>
<li>로더는 파일을 해석하고 변환하는 과정에 관여합니다. 예를 들어 CSS 파일을 자바스크립트로 변환하거나 TypeScript를 자바스크립트로 컴파일하는 등의 작업을 수행합니다.</li>
<li>플러그인은 웹팩의 기본적인 동작에 추가적인 기능을 제공합니다. 예를 들어 번들된 결과물을 난독화하거나 특정 텍스트를 추출하는 등의 작업을 수행합니다.
로더는 모듈 규칙(module.rules) 속성에 배열 형태로 설정하고, 플러그인은 플러그인(plugins) 속성에 배열 형태로 설정합니다.</li>
</ul>
<h3 id="references-7">References</h3>
<p>(2) <a href="http://daplus.net/javascript-webpack-%EB%A1%9C%EB%8D%94-%EB%8C%80-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%B4-%EB%AD%90%EC%95%BC/">[javascript] Webpack 로더 대 플러그인; 차이점이 뭐야? - 리뷰나라</a>
(3) <a href="https://agal.tistory.com/70">플러그인 - 웹팩(Webpack) 기본편 | 김정환 :: Interactive Developer</a>
(4) <a href="https://joshua1988.github.io/webpack-guide/concepts/plugin.html">Plugin | 웹팩 핸드북</a>
(5) <a href="https://www.web-development-kb-ko.site/ko/javascript/%EC%9B%B9%ED%8C%A9-%EB%A1%9C%EB%8D%94%EC%99%80-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%B4-%EB%AD%90%EC%95%BC/826288250/">javascript — 웹팩 로더와 플러그인; 차이점이 뭐야?</a>
(6) <a href="https://velog.io/@bangina/Webpack%EA%B3%BC-%EC%9D%B8%EC%82%AC%ED%95%98%EA%B8%B0-%EC%9B%B9%ED%8C%A9-%EA%B8%B0%EB%B3%B8-%EC%82%AC%EC%9A%A9%EB%B2%95-%EB%AA%A8%EB%93%9C%EB%A1%9C%EB%8D%94%EC%95%84%EC%9B%83%ED%92%8B%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8">[TIL]Webpack과 인사하기 - 웹팩 기본 사용법, 모드/로더/아웃풋</a></p>
<p>웹팩의 모드와 환경변수는 다음과 같이 설명할 수 있습니다.</p>
<ul>
<li>웹팩의 모드는 웹팩의 동작 방식을 결정하는 옵션입니다. development, production, none 중 하나를 선택할 수 있습니다. 각 모드에 따라 웹팩은 내부적으로 최적화를 수행하거나 소스맵을 생성하거나 프로세스 환경 변수를 설정합니다.</li>
<li>웹팩의 환경변  수는 웹팩이 실행되는 노드 환경에서 사용할 수 있는 변수입니다. 예를 들어 dotenv 모듈을 사용하여 .env 파일에 저장된 변수들을 불러올 수 있습니다. 또한 webpack.DefinePlugin을 사용하여 전역 변수로 등록하여 코드 내에서 구분할 수 있게 할 수 있습니다.</li>
</ul>
<h3 id="references-8">References</h3>
<p>(1) <a href="https://webpack.kr/concepts/">Concepts | 웹팩</a>
(2) <a href="https://velog.io/@marulloc/Webpack-Webpack">[Webpack] Webpack과 환경변수</a>
(3) <a href="https://zuminternet.github.io/ZUM-Webpack-dev-proxy-part1/">Webpack Dev Server를 이용한 개발 환경 구성 Part1</a>
(4) <a href="https://falsy.me/dotenv%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-nodejs-%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98-%EC%84%A4%EC%A0%95%EA%B3%BC-webpack-%EB%B2%88%EB%93%A4%EB%A1%9C-%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98-%EC%A0%84/">dotenv를 사용한 NodeJS 환경변수 설정과 Webpack 번들로 환경변수 ...</a></p>
<h2 id="웹팩의-엔트리와-아웃풋">웹팩의 엔트리와 아웃풋</h2>
<ul>
<li>엔트리는 웹팩이 모듈을 해석하고 번들링하는 시작점입니다. 엔트리에 지정된 파일부터 의존하는 모듈들을 찾아내어 하나의 결과물로 만듭니다. 엔트리는 entry 속성에 문자열이나 배열이나 객체로 설정할 수 있습니다.</li>
<li>아웃풋은 웹팩이 번들링한 결과물을 저장할 위치와 파일명을 지정하는 옵션입니다. 아웃풋은 output 속성에 객체로 설정하며, path와 filename 속성은 필수입니다. path는 절대경로를 사용해야 하고, filename은 [name], [hash], [chunkhash] 등의 키워드를 사용할 수 있습니다.</li>
</ul>
<h3 id="references-9">References</h3>
<p>(1) <a href="https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html">프론트엔드 개발환경의 이해: 웹팩(기본) | 김정환 블로그</a>
(2) <a href="https://junior-datalist.tistory.com/209">프론트엔드 개발환 경: 웹팩</a></p>
<h2 id="일반적으로-많이-사용되는-웹팩-플러그인과-로더">일반적으로 많이 사용되는 웹팩 플러그인과 로더</h2>
<ul>
<li>플러그인</li>
</ul>
<p>- HtmlWebpackPlugin: HTML 파일을 생성하고 번들링된 스크립트를 자동으로 삽입해주는 플러그인입니다.
  - MiniCssExtractPlugin: CSS 파일을 별도로 추출하고 HTML 파일에 링크하는 플러그인입니다.
  - CleanWebpackPlugin: 빌드 전에 output 폴더를 자동으로 삭제해주는 플러그인입니다.
  - OptimizeCssAssetsWebpackPlugin: CSS 파일을 최적화하고 압축하는 플러그인입니다.
  - TerserWebpackPlugin: JS 파일을 최적화하고 압축하는 플러그인입니다.</p>
<ul>
<li>로더</li>
</ul>
<p>- babel-loader: 바벨을 사용하여 JS 파일을 변환하는 로더입니다.
  - css-loader: CSS 파일을 모듈로 인식할 수 있게 해주는 로더입니다.
  - style-loader: CSS 파일을 동적으로 스타일 태그로 삽입해주는 로더입니다.
  - file-loader: 이미지나 폰트 등의 파일을 모듈로 인식할 수 있게 해주는 로더입니다.
  - url-loader: 작은 크기의 이미지나 폰트 등의 파일을 base64로 인코딩하여 JS나 CSS에 내장시켜주는 로더입니다.</p>
<h3 id="references-10">References</h3>
<p>(1) <a href="https://carpediem9911.tistory.com/34">웹팩 설정하기 - 플러그인</a>
(2) <a href="https://velog.io/@uoayop/">Webpack : 웹팩 찍먹하기 (+ module, bundler, loader)</a>
(3) <a href="https://aoptimer.com/%EC%9B%8C%EB%93%9C%ED%94%84%EB%A0%88%EC%8A%A4-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%B6%94%EC%B2%9C/">최고의 10가지 워드프레스 플러그인 추천 (2020) | 옵티머</a>
(4) <a href="https://sunny921.github.io/posts/webpack-1/">(Webpack) 웹팩 - 모듈 번들러와 로더 | Let&#x27;s Sunny</a>
(5) <a href="https://junhobaik.github.io/vsc-plugin-list/">사용중인 VSCode(Visual Studio Code) 확장 플러그인 목록</a>
(6) <a href="https://webpack.kr/concepts/loaders/">Loaders | 웹팩</a></p>
<h2 id="웹팩의-설정-방법">웹팩의 설정 방법</h2>
<ul>
<li>웹팩을 설치하기 위해서는 npm을 이용해야 합니다. npm은 Node.js를 설치하면 함께 설치됩니다.</li>
<li>웹팩과 웹팩 CLI 패키지를 설치합니다. CLI는 커맨드 라인 인터페이스로, 터미널에서 웹팩 명령어를 사용할 수 있게 해줍니다.</li>
<li>웹팩에서 기본적으로 인식하는 설정 파일 이름은 webpack.config.js입니다. 이 파일을 프로젝트 루트 폴더에 생성합니다.</li>
<li>설정 파일에는 mode, entry, output, module, plugins 등의 속성을 정의할 수 있습니다.
  - mode: 개발 모드(development)와 배포 모드(production)를 구분하여 최적화 옵션을 적용할 수 있습니다.
  - entry: 번들링할 파일의 시작점을 지정합니다.
  - output: 번들링된 결과물의 파일명과 경로를 지정합니다.
  - module: 로더를 사용하여 다양한 형식의 파일들을 모듈로 변환할 수 있습니다. rules 배열에 각각의 로더와 적용할 파일 확장자를 정의합니다.
  - plugins: 번들링 과정에 추가적인 기능을 제공하는 플러그인들을 사용할 수 있습니다. plugins 배열에 각각의 플러그인 객체를 생성하여 넣습니다.</li>
</ul>
<h3 id="references-11">References</h3>
<p>(1) <a href="https://velog.io/@eastshine94/webpack-webpack-%EC%84%A4%EC%B9%98%EB%B6%80%ED%84%B0-%EC%8B%A4%ED%96%89%EA%B9%8C%EC%A7%80">[webpack] webpack 설치부터 실행까지</a>
(2) <a href="https://www.daleseo.com/webpack-config/">웹팩(Webpack) 기본 설정법 (Entry/Output/Loader/Plugins)</a>
(3) <a href="https://www.daleseo.com/webpack-basics/">웹팩(Webpack) 기본 사용법 (CLI) | Engineering Blog by Dale Seo</a></p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="Node.js 패키지 매니저"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/node-js-package-manager-pnpm-and-yarn-berry">Node.js의 Package Manager pnpm and Yarn berry</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-03-20T00:00:00.000Z" itemprop="datePublished">2023년 3월 20일</time> · <!-- -->약 23분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="nodejs-패키지-매니저">Node.js 패키지 매니저</h2>
<p>Node.js 패키지 매니저는 Node.js에서 사용할 수 있는 모듈을 패키지 형태로 저장해 둔 패키지 생태계이자 패키지 설치 및 관리를 위한 CLI를 제공하는 도구입니다. npm은 Node.js와 함께 설치되어 가장 널리 쓰이는 패키지 매니저입니다. Yarn과 pnpm 외에도 다른 패키지 매니저들이 있습니다. 예를 들어, cnpm, ied, npmd 등이 있습니다. 각 도구마다 장단점이 있으므로 프로젝트의 요구사항과 개인의 취향에 따라 선택하시면 됩니다.</p>
<h3 id="references">References</h3>
<p>(1) <a href="https://library.gabia.com/contents/8206/">[Node.js] 인기 NPM 패키지 알아보기 | 가비아 라이브러리</a>
(2) <a href="https://heropy.blog/2018/02/18/node-js-npm/">처음 시작하는 Node.js 개발 - 2 - npm | HEROPY</a>
(3) <a href="https://nodejs.org/ko/download/package-manager">패키지 매니저로 Node.js 설치하기 | Node.js</a>
(4) <a href="https://nodejs.org/en/download/package-manager">Installing Node.js via package manager | Node.js</a>
(5) <a href="https://www.npmjs.com/package/npm">npm - a JavaScript package manager</a></p>
<h2 id="각-패키지-매니저의-강점">각 패키지 매니저의 강점</h2>
<ul>
<li>npm: Node.js와 함께 설치되어 가장 널리 쓰이는 패키지 매니저입니다. 모든 Node.js 모듈을 호환하고 사용하기 쉽습니다.</li>
<li>yarn: npm보다 빠르고 안정적인 설치 속도를 제공합니다. 오프라인 모드와 워크스페이스 기능을 지원합니다.</li>
<li>pnpm: 디스크 공간과 메모리를 절약하는 방식으로 패키지를 설치합니다. 중복된 패키지를 하나의 복사본으로 관리하고 심볼릭 링크로 연결합니다.</li>
<li>cnpm: 중국에서 개발된 패키지 매니저로 npm의 미러 서버를 사용하여 중국 내에서 빠른 다운로드 속도를 제공합니다.</li>
</ul>
<h3 id="references-1">References</h3>
<p>(1) <a href="https://blog.logrocket.com/javascript-package-managers-compared/">JavaScript package managers compared: npm, Yarn, or pnpm?</a>
(2) <a href="https://www.atatus.com/blog/npm-vs-yarn-vs-pnpm/">JavaScript Package Managers: NPM Vs YARN Vs PNPM - Atatus</a>
(3) <a href="https://refine.dev/blog/pnpm-vs-npm-and-yarn/">Why you should prefer using pnpm over npm and yarn? | refine</a></p>
<h2 id="리액트-네이티브-개발의-패키지-매니저">리액트 네이티브 개발의 패키지 매니저</h2>
<p>yarn berry와 pnpm은 모두 Plug&#x27;n&#x27;Play(PnP)라는 기능을 지원합니다. PnP는 패키지를 설치할 때 node_modules 폴더를 생성하지 않고, 하나의 복사본으로 관리하고 심볼릭 링크로 연결하는 방식입니다. 이렇게 하면 디스크 공간과 메모리를 절약하고 설치 속도를 향상시킬 수 있습니다.
그  러나 yarn berry와 pnpm은 PnP를 구현하는 방식에 차이가 있습니다. yarn berry는 PnP를 기본적으로 활성화하고, 호환되지 않는 패키지들을 위해 loose 모드라는 옵션을 제공합니다. pnpm은 PnP 대신 node_modules 폴더에 심볼릭 링크를 생성하는 방식을 사용합니다. 이 방식은 호환성 문제가 적으나, 일부 패키지들이 심볼릭 링크로 인식하지 못하는 경우가 있습니다.
따라서 리액트 네이티브 개발자에게 어떤 패키지 매니저가 더 적합한지는 프로젝트의 특성과 사용하는 패키지들에 따라 다르겠습니다. 일반적으로 yarn berry는 PnP의 장점을 최대한 활용하고 싶은 경우에 좋으며, pnpm은 node_modules 폴더의 구조를 유지하면서 캐싱의 장점을 얻고 싶은 경우에 좋습니다.</p>
<h3 id="references-2">References</h3>
<p>(1) <a href="https://blog.logrocket.com/advanced-package-manager-features-npm-yarn-pnpm/">Advanced package manager features for npm, Yarn, and pnpm</a>
(2) <a href="https://blog.logrocket.com/javascript-package-managers-compared/">JavaScript package managers compared: npm, Yarn, or pnpm?</a>
(3) <a href="https://yarnpkg.com/features/pnp/">Plug&#x27;n&#x27;Play | Yarn - Package Manager</a>
(4) <a href="https://stackoverflow.com/questions/58464279/npm-or-yarn-what-is-the-standard-practice-of-starting-react-native-projects-and">reactjs - NPM or Yarn? What is the standard practice of starting React Native projects ...</a></p>
<h2 id="두-패키지-도구의-차이점과-각각의-장단점">두 패키지 도구의 차이점과 각각의 장단점</h2>
<p>yarn berry와 pnpm의 차이점</p>
<ul>
<li>yarn berry는 PnP를 기본적으로 활성화하고, 호환되지 않는 패키지들을 위해 loose 모드라는 옵션을 제공합니다. pnpm은 PnP 대신 node_modules 폴더에 심볼릭 링크를 생성하는 방식을 사용합니다.</li>
<li>yarn berry는 워크스페이스 기능을 지원하며, 여러 프로젝트를 하나의 저장소에서 관리할 수 있습니다. pnpm은 워크스페이스 기능을 지원하지 않으며, 각 프로젝트마다 별도의 패키지 매니저를 사용해야 합니다.</li>
<li>yarn berry는 플러그인 시스템을 제공하며, 다양한 기능들을 추가할 수 있습니다. pnpm은 플러그인 시스템을 제공하지 않으며, 필요한 기능들은 별도의 도구나 스크립트로 구현해야 합니다.</li>
</ul>
<p>yarn berry와 pnpm의 장단점</p>
<ul>
<li>yarn berry의 장점은 PnP의 장점을 최대한 활용하고 싶은 경우에 좋으며, 워크스페이스와 플러그인 등 다양한 기능들을 제공한다는 점입니다. 단점은 PnP가 호환되지 않는 패키지들이 있어서 loose 모드를 사용해야 하는 경우가 있다는 점입니다.</li>
<li>pnpm의 장점은 node_modules 폴더의 구조를 유지하면서 캐싱의 장점을 얻고 싶은 경우에 좋으며, 호환성 문제가 적다는 점입니다. 단점은 워크스페이스와 플러그인 등 다양한 기능들이 부족하다는 점입니다.</li>
</ul>
<h3 id="references-3">References</h3>
<p>(1) <a href="https://www.atatus.com/blog/npm-vs-yarn-vs-pnpm/">JavaScript Package Managers: NPM Vs YARN Vs PNPM - Atatus</a>
(2) <a href="https://blog.logrocket.com/javascript-package-managers-compared/">JavaScript package managers compared: npm, Yarn, or pnpm?</a>
(3) <a href="https://pnpm.io/benchmarks">Benchmarks of JavaScript Package Managers | pnpm</a></p>
<h2 id="yarn-berry와-pnpm-각각에-대한-성능-벤치마크-결과">yarn berry와 pnpm 각각에 대한 성능 벤치마크 결과</h2>
<ul>
<li>yarn berry는 PnP 모드를 사용하면 설치 시간이 가장 빠르고, 캐시가 없는 경우에도 빠른 속도를 유지합니다. 하지만 업데이트 시간은 다른 패키지 매니저들보다 느립니다.</li>
<li>pnpm은 캐시가 있는 경우에 설치 시간이 가장 빠르고, 캐시가 없는 경우에도 yarn berry보다 느리지 않습니다. 업데이트 시간은 npm보다 빠르고, yarn classic보다 조금 느립니다.
성능 벤치마크 결과는 프로젝트의 크기나 구조에 따라 달라질 수 있으므로 참고만 하시기 바랍니다.</li>
</ul>
<h3 id="references-4">References</h3>
<p>(1) <a href="https://pnpm.io/benchmarks">Benchmarks of JavaScript Package Managers | pnpm</a>
(2) <a href="https://blog.logrocket.com/javascript-package-managers-compared/">JavaScript package managers compared: npm, Yarn, or pnpm?</a>
(3) <a href="https://github.com/pnpm/benchmarks-of-javascript-package-managers">pnpm/benchmarks-of-javascript-package-managers - GitHub</a></p>
<h2 id="yarn-berry가-업데이트-시간이-느린-이유">yarn berry가 업데이트 시간이 느린 이유</h2>
<ul>
<li>yarn berry는 PnP 모드를 사용하면 node_modules 폴더를 생성하지 않고, .pnp.js 파일에 패키지의 위치를 기록합니다. 이 방식은 설치 시간을 줄여주지만, 업데이트 시간을 늘리는 단점이 있습니다.</li>
<li>yarn berry는 업데이트할 때 peer dependencies의 충돌 여부를 체크하고, 문제가 있으면 경고 메시지를 출력합니다. 이 과정은 업데이트 시간에 영향을 줄 수 있습니다.</li>
</ul>
<h2 id="yarn-berry의-업데이트-시간을-최소화하는-방법">yarn berry의 업데이트 시간을 최소화하는 방법</h2>
<ul>
<li>yarn berry의 설정 파일인 .yarnrc.yml 파일에 nodeLinker: node-modules 라고 추가하면 PnP 모드를 비활성화하고, node_modules 폴더를 생성하는 방식으로 바꿀 수 있습니다. 이렇게 하면 업데이트 시간이 줄어들 수 있습니다.</li>
<li>yarn berry의 명령어인 yarn up 을 사용하면 패키지들을 최신 버전으로 업데이트할 수 있습니다. 이 명령어는 peer dependencies의 충돌 여부를 무시하므로, 경고 메시지가 나오지 않습니다. 하지만 peer dependencies가 정상적으로 작동하지 않을 수도 있으므로 주의해야 합니다.</li>
</ul>
<h3 id="references-5">References</h3>
<p>(1) <a href="https://yarnpkg.com/getting-started/migration/">Migration | Yarn - Package Manager</a>
(2) <a href="https://medium.com/inato/make-your-ci-faster-and-improve-developer-experience-upgrade-to-yarn-2-with-or-without-939524d9bef2">Make your CI faster and improve developer experience: Upgrade to Yarn &gt;2 with (or ...</a>
(3) <a href="https://github.com/yarnpkg/berry/issues/3476">[Bug?]: yarn install link step very slow · Issue #3476 · yarnpkg/berry - GitHub</a></p>
<h2 id="yarn-berry의-loose-모드-활성화-방법">yarn berry의 loose 모드 활성화 방법</h2>
<ul>
<li>yarn berry의 설정 파일인 .yarnrc.yml 파일에 pnpMode: loose 라고 추가하면 loose 모드를 활성화할 수 있습니다.</li>
<li>loose 모드는 PnP 모드와 비슷하지만, node_modules 링커에서 hoist되었을 패키지들에 대해서는 경고 메시지만 출력하고 접근을 허용합니다. 이렇게 하면 호환성 문제를 줄일 수 있습니다.</li>
</ul>
<h2 id="특정-패키지가-pnp를-지원하지-않는-것을-미리-알-수-있는-방법">특정 패키지가 PnP를 지원하지 않는 것을 미리 알 수 있는 방법</h2>
<ul>
<li>yarn berry의 명령어인 yarn dlx @yarnpkg/doctor 을 사용하면 프로젝트에 있는 패키지들이 PnP를 지원하는지 검사할 수 있습니다. 이 명령어는 문제가 있는 패키지들을 보여주고, 해결 방법을 제안합니다.</li>
<li><a href="https://yarnpkg.com/">yarn berry 웹사이트</a> 에서 패키지 이름을 검색하면 해당 패키지가 PnP를 지원하는지 여부를 확인할 수 있습니다. PnP를 지원하는 패키지는 아이콘으로 표시됩니다.</li>
</ul>
<h3 id="references-6">References</h3>
<p>(1) <a href="https://github.com/yarnpkg/berry/blob/master/CHANGELOG.md">berry/CHANGELOG.md at master · yarnpkg/berry · GitHub</a>
(2) <a href="https://stackoverflow.com/questions/61901805/fallback-pool-in-yarn-v2-loose-mode">yarnpkg - Fallback pool in yarn v2 &quot;loose&quot; mode - Stack Overflow</a>
(3) <a href="https://dev.to/arcanis/yarn-2-1-git-workspaces-focused-installs-loose-mode-live-playground-4kfc">Yarn 2.1 🐱‍🏍 Git Workspaces, Focused Installs, Loose mode, Live Playground ...</a></p>
<h2 id="yarn-berry에서-nodelinker-node_modules-옵션과-pnpmode-loose-옵션의-차이점">yarn berry에서 nodeLinker: node_modules 옵션과 pnpMode: loose 옵션의 차이점</h2>
<ul>
<li>nodeLinker: node_modules 옵션은 PnP 모드를 완전히 비활성화하고, 전통적인 node_modules 폴더를 생성하는 방식으로 패키지들을 설치하고 관리합니다. 이 옵션은 호환성 문제를 없애지만, 설치 시간과 디스크 공간을 많이 소모합니다.</li>
<li>pnpMode: loose 옵션은 PnP 모드를 부분적으로 활성화하고, node_modules 링커에서 hoist되었을 패키지들에 대해서는 경고 메시지만 출력하고 접근을 허용합니다. 이 옵션은 호환성 문제를 줄이면서도 설치 시간과 디스크 공간을 절약할 수 있습니다.</li>
</ul>
<p>두 옵션은 동시에 사용할 수 없습니다. 왜냐하면 두 옵션은 서로 다른 링커 방식을 사용하기 때문입니다. 만약 두 옵션을 동시에 설정하면 yarn berry는 오류 메시지를 출력하고 작동하지 않습니다.</p>
<h3 id="references-7">References</h3>
<p>(1) <a href="https://blog.logrocket.com/advanced-package-manager-features-npm-yarn-pnpm/">Advanced package manager features for npm, Yarn, and pnpm</a>
(2) <a href="https://stackoverflow.com/questions/71063201/yarn-3-nodelinker-node-modules">yarnpkg - Yarn 3 nodeLinker: node-modules - Stack Overflow</a>
(3) <a href="https://woong-jae.com/projects/220711-pnp-dependency-error/">Yarn PnP 의존성 에러 해결기 | 햣 블로그</a>
(4) <a href="https://yarnpkg.com/features/pnp/">Plug&#x27;n&#x27;Play | Yarn - Package Manager</a>
(5) <a href="https://github.com/yarnpkg/berry/issues/3482">Default nodeLinker is node_modules instead of pnp · Issue #3482 · yarnpkg/berry ...</a></p>
<h2 id="yarn-berry-마이그레이션-방법">yarn berry 마이그레이션 방법</h2>
<p>yarn classic을 사용하던 프로젝트에서 yarn berry로 업데이트하고 나서, 다음과 같은 작업을 해야 합니다:</p>
<ul>
<li>yarn set version berry 명령어를 실행하여 yarn berry를 활성화합니다.</li>
<li>.npmrc나 .yarnrc 파일이 있다면 새로운 형식인 .yarnrc.yml 파일로 변환합니다. 이 과정에서 기존의 설정들을 유지하거나 변경할 수 있습니다.</li>
<li>yarn install 명령어를 실행하여 프로젝트의 의존성들을 설치합니다. 이때 PnP 모드가 기본적으로 적용되므로 호환성 문제가 발생할 수 있습니다. 이런 경우에는 nodeLinker: node_modules 옵션을 사용하거나 pnpMode: loose 옵션을 사용하여 해결할 수 있습니다.</li>
<li>package.json 파일에 있는 scripts 설정들을 검토하고 필요한 경우 수정합니다. 예를 들어 node_modules 폴더에 직접 접근하는 스크립트는 PnP 모드와 충돌할 수 있으므로 yarn dlx 명령어를 사용하여 대체할 수 있습니다.</li>
</ul>
<p>.yarnrc.yml 파일과 .yarnrc 파일은 동시에 사용할 수 없습니다. 왜냐하면 두 파일은 서로 다른 형식의 설정 파일이기 때문입니다. 만약 두 파일이 동시에 존재한다면 yarn berry는 오류 메시지를 출력하고 작동하지 않습니다.</p>
<h3 id="references-8">References</h3>
<p>(1) <a href="https://yarnpkg.com/getting-started/migration/">Migration | Yarn - Package Manager</a>
(2) <a href="https://github.com/yarnpkg/berry/discussions/3448">Feedback on Yarn 3 migration from Yarn classic · Discussion #3448 · yarnpkg/berry ...</a>
(3) <a href="https://github.com/yarnpkg/yarn">yarnpkg/yarn: The 1.x line is frozen - GitHub</a></p>
<h2 id="yarn-berry의-dlx-커맨드">yarn berry의 dlx 커맨드</h2>
<ul>
<li>dlx 커맨드는 npx 커맨드와 유사하게 한 번만 실행할 패키지를 설치하고 실행하는 명령어입니다. 예를 들어 yarn dlx create-react-app 명령어는 create-react-app 패키지를 임시로 설치하고 프로젝트를 생성한 후 삭제합니다.</li>
<li>dlx 커맨드는 yarn berry의 PnP 모드와 호환되도록 설계되었습니다. 따라서 node_modules 폴더에 직접 접근하는 패키지들을 dlx 커맨드로 대체할 수 있습니다. 예를 들어 yarn dlx eslint --init 명령어는 eslint 패키지를 임시로 설치하고 설정 파일을 생성한 후 삭제합니다.</li>
<li>dlx 커맨드는 -p,--package 플래그를 사용하여 실행할 패키지와 실행할 명령어를 구분할 수 있습니다. 예를 들어 yarn dlx -p jest jest 명령어는 jest 패키지에서 jest 명령어를 실행합니다.</li>
</ul>
<h3 id="references-9">References</h3>
<p>(1) <a href="https://yarnpkg.com/cli/dlx/"><code>yarn dlx</code> | Yarn - Package Manager</a>
(2) <a href="https://github.com/yarnpkg/berry">GitHub - yarnpkg/berry: 📦🐈 Active development trunk for Yarn ⚒</a>
(3) <a href="https://haranglog.tistory.com/28">Yarn berry에서 React + Jest + Cypress + TypeScript + Github Actions CI/CD를 ...</a>
(4) <a href="https://kasterra.github.io/setting-yarn-berry/">yarn berry로 React.js 프로젝트 시작하기 | Kasterra&#x27;s Archive</a>
(5) <a href="https://yarnpkg.com/getting-started/migration/">Migration | Yarn - Package Manager</a></p>
<h2 id="yarn-dlx-명령어와-npx-명령어의-충돌-가능성">yarn dlx 명령어와 npx 명령어의 충돌 가능성</h2>
<p>dlx 커맨드는 npx 커맨드와 거의 동일한 기능을 제공하지만 yarn berry의 PnP 모드와 호환되도록 만들어졌습니다. 따라서 yarn berry를 사용하는 프로젝트에서는 dlx 커맨드를 사용하는 것이 권장됩니다. npx 커맨드는 node_modules 폴더에 의존하기 때문에 PnP 모드와 충돌할 수 있습니다.</p>
<p>패키지 매니저는 프로젝트의 의존성을 관리하는 도구입니다. 각 프로젝트마다 다른 패키지 매니저를 사용할 수 있습니다. 예를 들 어, npm, yarn, pnpm 등의 패키지 매니저를 선택할 수 있습니다.</p>
<p>각 패키지 매니저는 자신만의 장단점이 있으므로, 프로젝트의 목적과 요구사항에 따라 적합한 패키지 매니저를 선택하는 것이 좋습니다. 또한, 패키지 매니저를 바꾸고 싶다면, 기존에 설치된 패키지들을 삭제하고 새로운 패키지 매니저로 다시 설치하는 과정이 필요합니다. 각 패키지 매니저 사이에 간섭은 전혀 없다고 단언하기는 어렵습니다. 가능하면 한 프로젝트에서는 한 가지 패키지 매니저만 사용하시는 것이 안전하고 편리할 것입니다.</p>
<h3 id="references-10">References</h3>
<p>(1) <a href="https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Package_management">Package management basics - Learn web development | MDN - Mozilla</a>
(2) <a href="https://blog.logrocket.com/javascript-package-managers-compared/">JavaScript package managers compared: npm, Yarn, or pnpm?</a>
(3) <a href="https://stackoverflow.com/questions/42142993/adding-nuget-packages-from-one-project-to-another">Adding Nuget Packages From One Project To Another</a></p>
<h2 id="yarn-berry로-업그레이드하지-않아도-되는-경우">Yarn Berry로 업그레이드하지 않아도 되는 경우</h2>
<p>pnpm과 yarn berry를 프로젝트에 적용시켜 보고자 하는 개발자들을 대상으로, 다음과 같은 경우에는 기존의 npm이나 yarn classic을 쓰는 게 낫다고 말할 수 있습니다:</p>
<ul>
<li>Node.js의 버전이 16.9.0 미만인 경우: pnpm과 yarn berry는 Corepack이라는 도구를 사용하여 패키지 매니저를 관리합니다. 하지만 Corepack은 Node.js 16.9.0 이상에서만 사전 설치되어 있으므로, 그 이하의 버전에서는 별도로 설치하고 활성화해야 합니다. 이 과정이 번거롭거나 오류가 발생할 수 있는 경우에는 npm이나 yarn classic을 사용하는 것이 편리할 수 있습 니다.</li>
<li>패키지가 node_modules 폴더에 의존하는 경우: pnpm과 yarn berry는 node_modules 폴더를 생성하지 않고, 의존성을 공유하거나 가상화하는 방식으로 패키지를 관리합니다. 이는 디스크 공간과 설치 속도를 절약할 수 있지만, node_modules 폴더에 직접 접근하거나 수정하는 패키지와 호환되지 않을 수 있습니다. 이런 패키지들은 pnpm의 --shamefully-hoist 옵션이나 yarn berry의 nodeLinker 옵션으로 해결할 수 있기도 하지만, 그렇게 되면 pnpm과 yarn berry의 장점을 잃게 될 수 있습니다. 따라서 이런 패키지들을 사용해야 하는 경우에는 npm이나 yarn classic을 사용하는 것이 안전할 수 있습니다.</li>
</ul>
<p>위의 예시 외에도 다른 상황에 따라서 pnpm과 yarn berry가 적합하지 않을 수도 있습니다. 따라서 프로젝트의 특성과 요구사항을 잘 파악하고, 패키지 매니저를 선택하시기 바랍니다.</p>
<h3 id="references-11">References</h3>
<p>(1) <a href="https://blog.logrocket.com/javascript-package-managers-compared/">JavaScript package managers compared: npm, Yarn, or pnpm?</a>
(2) <a href="https://refine.dev/blog/pnpm-vs-npm-and-yarn/">Why you should prefer using pnpm over npm and yarn? | refine</a>
(3) <a href="https://www.atatus.com/blog/npm-vs-yarn-vs-pnpm/">JavaScript Package Managers: NPM Vs YARN Vs PNPM - Atatus</a></p>
<h2 id="yarn-classic-yarn-berry-pnpm의-인기">yarn classic, yarn berry, pnpm의 인기</h2>
<p>yarn classic과 pnpm, yarn berry의 각 사용자 비율을 정확하게 알려주기는 어렵습니다. 패키지 매니저의 사용률은 다양한 요인에 따라 변화할 수 있고, 중복 사용자가 많을 수 있기 때문입니다. 하지만 대략적인 사용률을 알고 싶으시다면, 다음과 같은 방법으로 참고할 수 있습니다:</p>
<ul>
<li>npm registry에서 각 패키지 매니저의 다운로드 횟수를 확인하는 방법: 이 방법은 각 패키지 매니저의 인기도를 나타낼 수 있습니다. 예를 들어, 2022년 12월 1일부터 2023년 1월 8일까지의 기간 동안, yarn classic은 약 <strong>2억 5천만</strong>번 다운로드되었고, pnpm은 약 <strong>1천만</strong>번 다운로드되었으며, yarn berry는 약 <strong>3백만</strong>번 다운로드되었습니다. 이 결과를 보면, yarn classic이 가장 인기있는 패키지 매니저라고 할 수 있습니다.</li>
<li>각 패키지 매니저의 벤치마크 결과를 확인하는 방법: 이 방법은 각 패키지 매니저의 성능을 비교할 수 있습니다. 예를 들어, pnpm 공식 웹사이트에서 제공하는 벤치마크 결과에 따르면, pnpm이 npm과 yarn classic보다 설치 속도와 디스크 공간 절약 면에서 우수하다고 합니다. 또한 yarn berry는 node_modules 폴더를 생성하지 않는 PnP 모드로 실행될 때 가장 빠른 설치 속도와 가장 적은 디스크 공간을 차지한다고 합니다. 이 결과를 보면, pnpm과 yarn berry가 성능 면에서 우위에 있다고 할 수 있습니다.</li>
</ul>
<h3 id="references-12">References</h3>
<p>(1) <a href="https://blog.logrocket.com/javascript-package-managers-compared/">JavaScript package managers compared: npm, Yarn, or pnpm?</a>
(2) <a href="https://www.atatus.com/blog/npm-vs-yarn-vs-pnpm/">JavaScript Package Managers: NPM Vs YARN Vs PNPM - Atatus</a>
(3) <a href="https://pnpm.io/benchmarks">Benchmarks of JavaScript Package Managers | pnpm</a></p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="What is Yarn Berry?"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/yarn-berry-and-classic">Yarn Berry and Classic</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-03-20T00:00:00.000Z" itemprop="datePublished">2023년 3월 20일</time> · <!-- -->약 26분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="what-is-yarn-berry">What is Yarn Berry?</h2>
<p>Yarn Berry는 Yarn의 새로운 버전으로, Node.js를 위한 패키지 관리 시스템입니다. Yarn Berry는 node_modules 폴더를 사용하지 않고 zip 파일로 모듈들을 관리하며, Plug&#x27;n&#x27;Play (PnP)라는 기능을 제공합니다. PnP는 모듈 설치 시간을 줄이고 디스크 공간을 절약하며 호환성 문제를 해결하는 등의 장점이 있습니다. Yarn Berry를 사용하려면 다음과 같은 단계를 따라야 합니다:</p>
<ul>
<li>npm install -g yarn 명령어로 글로벌 yarn 버전을 최신 v1으로 업데이트합니다.</li>
<li>프로젝트 디렉토리로 이동합니다.</li>
<li>yarn set version berry 명령어로 v2를 활성화합니다.</li>
<li>.npmrc 또는 .yarnrc 파일이 있다면 새로운 형식으로 변경합니다.</li>
<li>.yarnrc.yml 파일에 nodeLinker: node-modules 를 추가합니다.</li>
</ul>
<h3 id="references">References</h3>
<p>(1) <a href="https://toss.tech/article/node-modules-and-yarn-berry">node_modules로부터 우리를 구원해 줄 Yarn Berry</a>
(2) <a href="https://subtlething.tistory.com/126">[Devlog] yarn berry</a>
(3) <a href="https://kasterra.github.io/setting-yarn-berry/">yarn berry로 React.js 프로젝트 시작하기 | Kasterra&#x27;s Archive</a>
(4) <a href="https://github.com/yarnpkg/berry">GitHub - yarnpkg/berry: 📦🐈 Active development trunk for Yarn ⚒</a>
(5) <a href="https://yarnpkg.com/getting-started/migration/">Migration | Yarn - Package Manager</a></p>
<h2 id="yarn-berry와-yarn-classic의-차이점">yarn Berry와 Yarn Classic의 차이점</h2>
<p>Yarn Berry와 Yarn Classic의 가장 큰 차이점은 모듈 관리 방식입니다. Yarn Classic은 node_modules 폴더에 모든 의존성을 설치하고, package.json 파일에 버전 정보를 기록합니다. Yarn Berry는 zip 파일로 모든 의존성을 압축하고, .yarn 폴더에 저장합니다. 또한 package.json 파일 대신 .yarnrc.yml 파일에 버전 정보를 기록합니다. 이러한 차이점으로 인해 Yarn Berry는 설치 속도가 빠르고 디스크 공간을 절약하며 호환성 문제를 해결할 수 있습니다. 그러나 Yarn Berry는 아직 새로운 버전이기 때문에 일부 툴이나 라이브러리와의 호환성 문제가 발생할 수 있습니다. 따라서 프로젝트의 특성과 요구사항에 따라 적절한 버전을 선택하는 것이 중요합니다.</p>
<h3 id="references-1">References</h3>
<p>(1) <a href="https://yarnpkg.com/getting-started/migration/">Migration | Yarn - Package Manager</a>
(2) <a href="https://github.com/yarnpkg/berry">GitHub - yarnpkg/berry: 📦🐈 Active development trunk for Yarn ⚒</a>
(3) <a href="https://stackoverflow.com/questions/71634861/difference-between-yarn-versions">yarnpkg - Difference between yarn versions - Stack Overflow</a></p>
<h2 id="yarn-berry의-장점">Yarn Berry의 장점</h2>
<ul>
<li>설치 시간이 빠릅니다. zip 파일로 모듈을 관리하고 캐시를 사용하기 때문에 node_modules 폴더를 생성하거나 의존성을 다운로드할 필요가 없습니다.</li>
<li>디스크 공간을 절약합니다. zip 파일은 일반 파일보다 용량이 작으며, 캐시를 공유할 수 있기 때문에 중복된 모 듈을 저장할 필요가 없습니다.</li>
<li>호환성 문제를 해결합니다. PnP 기능을 사용하면 모듈 간의 충돌이나 버전 문제를 방지할 수 있습니다.</li>
</ul>
<h2 id="yarn-berry의-단점">Yarn Berry의 단점</h2>
<ul>
<li>저장소 크기가 증가합니다. zip 파일을 저장소에 푸시하면 git이 모든 변경 내역을 기억하기 때문에 저장소의 크기가 커질 수 있습니다.</li>
<li>클론 시간이 증가합니다. 저장소 크기가 커지면 클론하는데 걸리는 시간도 길어질 수 있습니다.</li>
<li>일부 툴이나 라이브러리와 호환되지 않을 수 있습니다. Yarn Berry는 아직 새로운 버전이기 때문에 일부 툴이나 라이브러리가 node_modules 폴더나 package.json 파일에 의존하는 경우 호환성 문제가 발생할 수 있습니다.</li>
</ul>
<p>따라서 Yarn Berry를 사용하기 전에 프로젝트의 특성과 요구사항에 따라 장단점을 고려하는 것이 좋습니다.😊</p>
<h3 id="references-2">References</h3>
<p>(1) <a href="https://stackoverflow.com/questions/69885538/should-i-push-the-yarn-cache-folder-to-github-yarn2">Should i push the .yarn/cache folder to Github - Yarn2</a>
(2) <a href="https://blog.hao.dev/state-of-yarn-2-berry-in-2021/">State of Yarn 2 (Berry) in 2021 · Hao&#x27;s learning log</a>
(3) <a href="https://shift.infinite.red/yarn-1-vs-yarn-2-vs-npm-a69ccf0229cd">Yarn 1 vs Yarn 2 vs NPM - Medium</a></p>
<h2 id="yarn-berry-dont-need-packagejson">Yarn Berry don&#x27;t need package.json?</h2>
<p>Yarn Berry는 package.json 파일을 사용하지 않는 것이 아니라, package.json 파일에 버전 정보를 기록하지 않는 것입니다. Yarn Berry는 대신 .yarnrc.yml 파일에 버전 정보를 기록합니다. 따라서 package.json 파일은 여전히 프로젝트의 이름, 설명, 스크립트 등의 정보를 담고 있습니다.😊</p>
<h2 id="yarn-berry를-사용하는-nodejs-프로젝트의-gitignore-파일을-작성하는-방법">Yarn Berry  를 사용하는 Node.js 프로젝트의 gitignore 파일을 작성하는 방법</h2>
<ul>
<li>.yarn 폴더 내에 있는 캐시 파일들은 저장소에 커밋하지 않는 것이 좋습니다. 이 파일들은 zip 파일로 압축된 모듈들이며, 저장소의 용량을 증가시킬 수 있습니다. 따라서 .yarn/cache 폴더를 gitignore 파일에 추가합니다.</li>
<li>.yarn 폴더 내에 있는 설정 파일들은 저장소에 커밋하는 것이 좋습니다. 이 파일들은 Yarn Berry의 버전 정보나 PnP 설정 등을 담고 있으며, 프로젝트의 의존성 관리에 필요합니다. 따라서 .yarnrc.yml 파일이나 .pnp.js 파일 등을 gitignore 파일에서 제외합니다.</li>
<li>node_modules 폴더는 Yarn Berry를 사용하면 생성되지 않으므로 gitignore 파일에 추가할 필요가 없습니다.</li>
</ul>
<p>따라서 Yarn Berry를 사용하는 Node.js 프로젝트의 gitignore 파일은 다음과 같이 작성할 수 있습니다:</p>
<pre><code class="language-gitignore"># Ignore cache files
.yarn/cache

# Do not ignore settings files
!.yarnrc.yml
!.pnp.js
</code></pre>
<h3 id="references-3">References</h3>
<p>(1) <a href="https://github.com/yarnpkg/berry/blob/master/.gitignore">berry/.gitignore at master · yarnpkg/berry · GitHub</a>
(2) <a href="https://github.com/yarnpkg/berry/issues/454">[Question] What files should be listed in <code>.gitignore</code> ? · Issue #454 · yarnpkg/berry</a>
(3) <a href="https://gist.github.com/nickmccurdy/d64ed8aeb4ed4e44a8eeb8c803a8402c">Better gitignore for Yarn 2 (berry) see [https://github.com/github/gitignore/pull/3479]</a></p>
<h2 id="yarn-classic에서-yarn-berry로-마이그레이션할-때-수정해야-할-사항">Yarn Classic에서 Yarn Berry로 마이그레이션할 때 수정해야 할 사항</h2>
<ul>
<li>Yarn Berry를 활성화합니다. <code>yarn set version berry</code> 명령어를 실행하면 프로젝트에 .yarn 폴더와 .yarnrc.yml 파일이 생성됩니다. 이 파일들은 Yarn Berry의 버전 정보와 설정을 담고 있습니다.</li>
<li>설정 파일을 새로운 형식으로 변환합니다. 만약 .npmrc나 .yarnrc 파일을 사용했다면, 이 파일들을 .yarnrc.yml 파일에 병합해야 합니다. 예를 들어, <code>registry &quot;https://registry.yarnpkg.com&quot;</code> 라는 설정은 <code>npmRegistryServer: &quot;https://registry.yarnpkg.com&quot;</code> 로 바꿔야 합니다.</li>
<li>의존성을 설치합니다. <code>yarn install</code> 명령어를 실행하면 의존성들이 zip 파일로 압축되어 .yarn/cache 폴더에 저장됩니다. 또한 PnP 모드가 기본적으로 활성화되므로 node_modules 폴더가 생성되지 않습니다.</li>
<li>호환성 문제를 해결합니다. 일부 툴이나 라이브러리가 Yarn Berry와 호환되지 않는 경우가 있습니다. 이런 경우에는 PnP 패치나 플러그인을 사용하거나, loose 모드나 nodeLinker 옵션을 사용하여 문제를 해결할 수 있습니다.</li>
</ul>
<p>따라서 Yarn Classic에서 Yarn Berry로 마이그레이션할 때 체크리스트는 다음과 같이 작성할 수 있습니다:</p>
<pre><code class="language-TODO">- [ ] yarn set version berry 명령어 실행
- [ ] 설정 파일 변환
- [ ] yarn install 명령어 실행
- [ ] 호환성 문제 해결
</code></pre>
<h3 id="references-4">References</h3>
<p>(1) <a href="https://yarnpkg.com/getting-started/migration/">Migration | Yarn - Package Manager</a>
(2) <a href="https://github.com/yarnpkg/berry/discussions/3448">Feedback on Yarn 3 migration from Yarn classic · Discussion #3448 · yarnpkg/berry ...</a>
(3) <a href="https://github.com/yarnpkg/yarn">yarnpkg/yarn: The 1.x line is frozen - GitHub</a></p>
<h2 id="사용-방법이나-플래그가-변경deprecated된-일부-명령어들">사용 방법이나 플래그가 변경(deprecated)된 일부 명령어들</h2>
<p>Yarn Berry에서 모든 명령어들이 바뀐 것은 아니지만, 일부 명령어들은 사용 방법이나 플래그가 변경되었습니다. 예를 들어:</p>
<ul>
<li><code>yarn install</code> 명령어는 이제 <code>--frozen-lockfile</code> 플래그가 기본값입니다. 만약 의존성을 업데이트하고 싶다면 <code>--check-cache</code> 플래그를 사용해야 합니다.</li>
<li><code>yarn start</code>, <code>yarn run</code>, <code>yarn add</code> 등의 명령어는 이제 Node 환경 변수를 주입하기 위해 <code>yarn node</code>를 사용해야 합니다. 예를 들어, <code>yarn node index.js</code> 또는 <code>yarn node -p &quot;process.versions.pnp&quot;</code>와 같이 사용할 수 있습니다.</li>
<li><code>yarn global</code> 명령어는 이제 존재하지 않습니다. 대신에 Yarn Berry에서 제공하는 코어 패키지나 플러그인 패키지를 설치하고 싶다면 <code>yarn dlx</code> 명령어를 사용할 수 있습니다.</li>
</ul>
<p>따라서 바뀌기 전의 명령어 -&gt; 바뀐 명령어 형식의 리스트는 다음과 같이 작성할 수 있습니다:</p>
<pre><code class="language-changeLog">- yarn install -&gt; yarn install --check-cache
- yarn start/run/add ... -&gt; yarn node start/run/add ...
- yarn global ... -&gt; yarn dlx ...
</code></pre>
<p>새롭게 생긴 명령어 리스트는 다음과 같이 작성할 수 있습니다:</p>
<pre><code class="language-changeLog">- yarn set version: Yarn 버전을 설정하거나 업데이트합니다.
- yarn up: 의존성을 업데이트합니다.
- yarn patch: 의존성에 패치를 적용합니다.
- yarn plugin: Yarn 플러그인을 관리합니다.
- yarn workspaces: 워크스페이스에 관한 정보를 출력합니다.
</code></pre>
<p>사라지거나 더 이상 권장하지 않는 명령어 리스트는 다음과 같이 작성할 수 있습니다:</p>
<pre><code class="language-changeLog">- yarn global: 글로벌 패키지 설치 기능이 제거되었습니다.
- yarn upgrade: 대신에 yarn up을 사용하세요.
- yarn upgrade-interactive: 대신에 \--interactive 옵션을 추가하세요.
</code></pre>
<h3 id="references-5">References</h3>
<p>(1) <a href="https://github.com/yarnpkg/berry">GitHub - yarnpkg/berry: 📦🐈 Active development trunk for Yarn ⚒</a>
(2) <a href="https://classic.yarnpkg.com/lang/en/docs/cli/">CLI Introduction | Yarn</a>
(3) <a href="https://yarnpkg.com/getting-started/migration/">Migration | Yarn - Package Manager</a></p>
<h2 id="migration-from-yarn-classic-to-yarn-berry-example">Migration from Yarn Classic to Yarn Berry (Example)</h2>
<p>리액트 네이티브 라이브러리의 package.json 내용을 Yarn Berry로 마이그레이션하기 위해서는 다음과 같은 절차를 따라야 합니다:</p>
<ul>
<li><code>yarn set version berry</code> 명령어를 실행하여 Yarn 버전을 2로 설정합니다. 이 명령어는 <code>.yarnrc.yml</code> 파일과 <code>.yarn/releases/yarn-berry.cjs</code> 파일을 생성합니다.</li>
<li>만약 <code>.npmrc</code> 또는 <code>.yarnrc</code> 파일을 사용하고 있다면, 새로운 형식으로 변환해야 합니다. 예를 들어, <code>registry &quot;https://registry.yarnpkg.com&quot;</code> 는 <code>npmRegistryServer: &quot;https://registry.yarnpkg.com&quot;</code> 로 바뀌어야 합니다.</li>
<li><code>.yarnrc.yml</code> 파일에 <code>nodeLinker: node-modules</code> 를 추가합니다. 이 옵션은 기존의 node_modules 폴더를 사용하도록 설정합니다. 만약 PnP 기능을 사용하고 싶다면 이 옵션을 생략할 수 있습니다.</li>
<li><code>yarn install</code> 명령어를 실행하여 의존성을 설치하고 lock 파일을 업데이트합니다.</li>
</ul>
<p>따라서 수정된 package.json 내용은 다음과 같습니다:</p>
<pre><code class="language-jsonc">{
  &quot;name&quot;: &quot;@dongminyu/react-native-step-counter&quot;,
  &quot;version&quot;: &quot;0.1.11&quot;,
  &quot;private&quot;: false,
  &quot;summary&quot;: &quot;It is a multi-platform library that combines CoreMotionSensor from iOS with SensorEventListener from Android.&quot;,
  &quot;description&quot;: &quot;This library provides an interface for tracking the number of steps taken by the user in a React Native app.&quot;,
  &quot;main&quot;: &quot;lib/commonjs/index&quot;,
  &quot;module&quot;: &quot;lib/module/index&quot;,
  &quot;types&quot;: &quot;lib/typescript/index.d.ts&quot;,
  &quot;react-native&quot;: &quot;src/index&quot;,
  &quot;source&quot;: &quot;src/index&quot;, // files 필드에 .yarn 폴더와 .pnp.js 파일을 추가합니다 // 만약 PnP 기능을 사용하지 않는다면 .pnp.js 파일은 제외할 수 있습니다 // .gitignore 파일에도 동일한 내용을 추가해야 합니다 // https://github.com/yarnpkg/berry/blob/master/.gitignore#L8-L9 // https://github.com/yarnpkg/berry/blob/master/package.json#L16-L17 // https://github.com/yarnpkg/berry/blob/master/.npmignore#L1-L2 // 참고하세요
  &quot;files&quot;: [&quot;.yarn/**/*&quot;, &quot;.pnp.js&quot;],
  &quot;scripts&quot;: {
    // yarn install 명령어에 \--check-cache 플래그를 추가합니다
    // https://yarnpkg.com/getting-started/migration/#update-your-install-script-if-needed
    // 참고하세요
    &quot;bootstrap&quot;: &quot;yarn install --check-cache &amp;&amp; yarn example install &amp;&amp; yarn example pods &amp;&amp; yarn example gradle&quot;
  }
}
</code></pre>
<h3 id="references-6">References</h3>
<p>(1) <a href="https://yarnpkg.com/getting-started/migration/">Migration | Yarn - Package Manager</a>
(2) <a href="https://github.com/yarnpkg/berry">GitHub - yarnpkg/berry: 📦🐈 Active development trunk for Yarn ⚒</a>
(3) <a href="https://stackoverflow.com/questions/49689174/yarn-how-to-upgrade-yarn-version-using-terminal">Yarn: How to upgrade yarn version using terminal?</a></p>
<h2 id="make-alias-to-make-easy-to-use-yarn-berry">Make Alias to Make Easy to Use Yarn Berry</h2>
<p>Yarn Berry에서는 기본적으로 명령어에 대한 별칭(alias) 기능을 제공하지 않습니다. 이는 Yarn의 핵심 철학 중 하나인 단순성을 지키기 위한 결정입니다. 그러나 만약 사용자가 별칭 기능을 원한다면, 다음과 같은 방법들이 있습니다:</p>
<ul>
<li>쉘(shell)에서 별칭을 설정하는 방법. 예를 들어, <code>alias y= &quot;yarn&quot;</code> 과 같이 쉘 설정 파일에 별칭을 추가할 수 있습니다. 이 방법은 간단하고 편리하지만, 쉘마다 다른 방식으로 설정해야 하고, 모든 팀원이 동일한 별칭을 사용하기 어렵다는 단점이 있습니다.</li>
<li>Yarn 플러그인(plugin)을 사용하는 방법. Yarn Berry에서는 플러그인 시스템을 도입하여 사용자가 커스텀 명령어를 만들 수 있도록 지원합니다. 예를 들어, <code>yarn plugin import https://github.com/yarnpkg/berry/raw/master/packages/plugin-aliases/sources/index.ts</code> 와 같이 플러그인을 설치하면 <code>yarn add</code> 대신 <code>yarn a</code> 를 사용할 수 있습니다. 이 방법은 프로젝트별로 일관된 별칭을 사용할 수 있고, Yarn의 기능을 확장할 수 있다는 장점이 있습니다.</li>
</ul>
<h3 id="references-7">References</h3>
<p>(1) <a href="https://classic.yarnpkg.com/blog/2017/06/19/adding-command-line-aliases-for-yarn/">Adding Command Line Aliases for Yarn | Yarn Blog</a>
(2) <a href="https://gist.github.com/DanyloMoraes/ebcf380f3c5264162786197ec1c82cf4">Useful aliases for Yarn · GitHub</a>
(3) <a href="https://github.com/yarnpkg/berry/issues/3077">[Feature] Command aliases · Issue #3077 · yarnpkg/berry</a>
(4) <a href="https://classic.yarnpkg.com/lang/en/docs/cli/">CLI Introduction | Yarn</a></p>
<h2 id="how-to-set-default-option-to-yarn-install">How to Set Default Option to Yarn Install</h2>
<p>리포지토리 내의 yarn 설정파일을 작성해 yarn install의 기본 option을 &quot;--check-cache&quot; 와같은 것으로 디폴트하고 이 외 옵션을 사용하면 그 옵션이 적용되도록 부트스트랩할 수 있나?</p>
<p>Yarn Berry에서는 <code>.yarnrc.yml</code> 파일을 사용하여 Yarn의 내부 설정을 관리할 수 있습니다. 이 파일은 프로젝트의 루트 디렉토리에 위치해야 하며, 다음과 같은 형식으로 옵션을 지정할 수 있습니다:</p>
<pre><code class="language-yaml">yarnPath: &quot;.yarn/releases/yarn-berry.cjs&quot;
nodeLinker: &quot;pnp&quot;
initFields:
  license: &quot;MIT&quot;
  version: &quot;1.0.0&quot;
npmRegistryServer: &quot;https://registry.yarnpkg.com&quot;
npmPublishRegistry: &quot;https://registry.npmjs.org&quot;
</code></pre>
<p>이 예시에서는 <code>yarn install</code> 의 기본 옵션을 <code>--check-cache</code> 로 설정하고 싶다면, 다음과 같이 <code>installConfig.checkCache</code> 항목을 추가하면 됩니다:</p>
<pre><code class="language-yaml">installConfig:
  checkCache: true
</code></pre>
<p>이렇게 하면 <code>yarn install</code> 명령어를 실행할 때마다 캐시된 파일들의 무결성을 검사하게 됩니다. 만약 다른 옵션을 사용하고 싶다면 명령어에 직접 추가하면 됩니다. 예를 들어, <code>--immutable</code> 옵션을 사용하고 싶다면 <code>yarn install --immutable</code> 과 같이 입력하면 됩니다.</p>
<h3 id="references-8">References</h3>
<p>(1) <a href="https://yarnpkg.com/configuration/yarnrc/">Configuration options | Yarn - Package Manager</a>
(2) <a href="https://classic.yarnpkg.com/lang/en/docs/cli/config/">yarn config | Yarn</a>
(3) <a href="https://yarnpkg.com/getting-started/migration/">Migration | Yarn - Package Manager</a></p>
<h2 id="how-to-update-dependencies-with-yarn-berry">How to Update Dependencies with Yarn Berry</h2>
<p>나는 라이브러리 전체 의존성을 업데이트하는 &#x27;yarn update --audit --latest&#x27;를 자주 사용하는데 같은 방법으로 yarn up에 적용할 수 있나?</p>
<p>Yarn Berry에서는 <code>yarn up</code> 명령어를 사용하여 라이브러리의 의존성을 업데이트할 수 있습니다. 이 명령어는 <code>package.json</code> 파일에 있는 버전 범위를 기준으로 업데이트를 수행하며, 다음과 같은 옵션을 사용할 수 있습니다:</p>
<ul>
<li><code>--latest</code>: 버전 범위와 상관없이 최신 버전으로 업데이트합니다.</li>
<li><code>--caret</code>, <code>--tilde</code>, <code>--exact</code>: 업데이트 후에 <code>package.json</code> 파일에 적용할 버전 범위의 접두사를 지정합니다.</li>
<li><code>--audit</code>: 의존성을 업데이트하기 전에 보안 취약점을 검사합니다.</li>
<li>따라서, 질문하신 명령어와 동일한 기능을 하려면 다음과 같이 입력하면 됩니다:</li>
</ul>
<pre><code class="language-sh">yarn up --audit --latest
</code></pre>
<h3 id="references-9">References</h3>
<p>(1) <a href="https://github.com/yarnpkg/berry">GitHub - yarnpkg/berry: 📦🐈 Active development trunk for Yarn ⚒</a>
(2) <a href="https://stackoverflow.com/questions/49689174/yarn-how-to-upgrade-yarn-version-using-terminal">Yarn: How to upgrade yarn version using terminal?</a>
(3) <a href="https://classic.yarnpkg.com/lang/en/docs/cli/upgrade/">yarn upgrade | Yarn</a></p>
<h2 id="how-to-reset-yarn-and-nodejs-cache">How to Reset Yarn and Node.js Cache</h2>
<p>Yarn의 로컬 캐시를 리셋하는 방법은 다음과 같습니다:</p>
<ul>
<li><code>yarn cache clean</code> 명령어를 사용하여 현  재 프로젝트의 로컬 캐시를 삭제합니다.</li>
<li><code>yarn cache clean --mirror</code> 명령어를 사용하여 전역 캐시를 삭제합니다.</li>
<li><code>yarn cache clean &lt;module_name&gt;</code> 명령어를 사용하여 특정 모듈의 캐시만 삭제합니다.</li>
</ul>
<p>Node.js의 로컬 캐시를 리셋하는 방법은 다음과 같습니다:</p>
<ul>
<li><code>npm cache clean --force</code> 명령어를 사용하여 전역 캐시를 삭제합니다.</li>
<li><code>npm cache verify</code> 명령어를 사용하여 캐시의 무결성을 검사하고 오래된 데이터를 제거합니다.</li>
</ul>
<p>Yarn Berry의 캐시를 삭제하는 방법은 다음과 같습니다:</p>
<ul>
<li><code>.yarn/cache</code> 폴더를 삭제하면 로컬 캐시를 삭제할 수 있습니다. 이 폴더는 프로젝트의 루트 디렉토리에 위치하며, <code>yarn install</code> 명령어를 실행할 때마다 다시 생성됩니다.</li>
<li><code>.yarn/berry/cache</code> 폴더를 삭제하면 전역 캐시를 삭제할 수 있습니다. 이 폴더는 Yarn Berry의 설치 경로에 위치하며, PnP 기능을 사용할 때 패키지 파일을 읽어오는 역할을 합니다. 이 폴더도 <code>yarn install</code> 명령어를 실행할 때마다 다시 생성됩니다.</li>
</ul>
<h3 id="references-10">References</h3>
<p>(1) <a href="https://yarnpkg.com/cli/cache/clean/"><code>yarn cache clean</code> | Yarn - Package Manager</a>
(2) <a href="https://classic.yarnpkg.com/lang/en/docs/cli/cache/">yarn cache | Yarn</a>
(3) <a href="https://stackoverflow.com/questions/39991508/how-to-clear-cache-in-yarn">yarnpkg - How to clear cache in Yarn? - Stack Overflow</a>
(4) <a href="https://classic.yarnpkg.com/lang/en/docs/cli/cache/">yarn cache | Yarn</a>
(5) <a href="https://stackoverflow.com/questions/70699473/what-is-the-yarn-berry-cache-folder-for-when-using-yarn-3">What is the .yarn/berry/cache folder for when using Yarn 3?</a>
(6) <a href="https://yarnpkg.com/features/offline-cache/">Offline Cache | Yarn - Package Manager</a></p>
<h2 id="what-is-pnp-feature-in-yarn-berry">What is PnP Feature in Yarn Berry?</h2>
<p>Yarn Berry의 PnP 기능은 node_modules 디렉토리를 사용하지 않고 패키지 의존성을 관리하는 방식입니다. PnP는 package.json 파일을 기반으로 의존성 트리를 생성하고,.yarn/cache 폴더에 의존성 정보를 저장하고.pnp.cjs 파일에 의존성을 찾을 수 있는 정보가 기록됩니다. 이렇게 하면 패키지 설치 시간과 디스크 공간을 절약할 수 있습니다. 또한 PnP는 zero install이라는 기능을 지원하여 프로젝트를 복제할 때 별도의 설치 과정 없이 바로 실행할 수 있습니다.</p>
<h3 id="references-11">References</h3>
<p>(1) <a href="https://velog.io/@thkim/Yarn-Berry">Yarn Berry 도입 (feat. pnp)</a>
(2) <a href="https://helloinyong.tistory.com/341">[Yarn berry] pnp (Plug And Play), Zero Install을 위한 Dependency 문제 ...</a>
(3) <a href="https://helloinyong.tistory.com/m/341">[Yarn berry] pnp(Plug And Play), Zero Install을 위한 Dependency 문제 해결하기</a>
(4) <a href="https://velog.io/@dami/Yarn-berry-PnP">Yarn Berry의 PnP(Plug&#x27;n&#x27;Play) 살펴보기</a></p>
<h2 id="is-there-some-issue-can-happen-if-i-dont-migrate-to-yarn-berry">Is there Some Issue can happen If I don&#x27;t migrate to Yarn Berry?</h2>
<p>Yarn Classic 버전을 계속해서 대규모 상업적 서비스에 이용할 때 발생할 수 있는 관련 이슈에는 다음과 같은 것들이 있습니다.</p>
<ul>
<li>nodejs 대신 node 이름을 사용하는 일부 배포판에서 yarn이 node가 설치되지 않았다고 불평할 수 있습니다.</li>
<li>node_modules 디렉토리가 프로젝트마다 중복되어 디스크 공간을 낭비하고 설치 시간을 늘릴 수 있습니다.</li>
<li>프로젝트가 내 컴퓨터에서 작동하지 않는다는 문제를 일으킬 수 있는 의존성 해결 방식의 한계가 있습니다.</li>
<li>Yarn 2와 비교하여 새로운 기능이나 개선사항이 제공되지 않을 수 있습니다.</li>
</ul>
<h3 id="references-12">References</h3>
<p>(1) <a href="https://classic.yarnpkg.com/lang/en/docs/install/">Installation | Yarn</a>
(2) <a href="https://yarnpkg.com/getting-started/migration/">Migration | Yarn - Package Manager</a>
(3) <a href="https://github.com/yarnpkg/yarn/issues">Issues · yarnpkg/yarn · GitHub</a></p>
<h2 id="yarn-berry-is-not-compatible-with-yarn-classic">Yarn Berry is not compatible with Yarn Classic?</h2>
<p>Yarn 2가 기존의 프로젝트 구조나 설정과 충돌할까봐 걱정 하시는군요. Yarn 2가 기존의 프로젝트 구조나 설정과 충돌할 수 있는 이유 중 하나는 Yarn 2가 새로운 Plug&#x27;n&#x27;Play (PnP) 아키텍처를 사용하기 때문입니다. PnP는 패키지를 설치하는 node_modules/ 폴더를 없애고 대신 .pnp.js 파일을 생성하여 의존성을 관리합니다. 이 방식은 디스크 공간과 설치 시간을 절약하고 의존성 해결 방식을 개선하지만, node_modules/ 폴더에 의존하는 일부 IDE나 툴과 호환되지 않을 수 있습니다. 하지만 걱정하지 마세요. Yarn 2는 nodeLinker: node-modules 옵션을 통해 기존의 node_modules/ 폴더를 유지할 수 있도록 지원합니다. 또한 Yarn 2는 PnP와 호환되도록 만들어진 다양한 IDE나 툴의 플러그인들을 제공합니다. 따라서 Yarn 2로 마이그레이션하더라도 기존의 프로젝트 구조나 설정과 크게 충돌할 가능성은 낮습니다.</p>
<h3 id="references-13">References</h3>
<p>(1) <a href="https://spin.atomicobject.com/2021/02/17/switch-yarn-2/">It’s 2021, and You Should Switch to Yarn 2 - Atomic Spin</a>
(2) <a href="https://yarnpkg.dev/releases/2-0/">Introducing Yarn 2 ! 🧶🌟</a>
(3) <a href="https://njbmartin.medium.com/whats-the-problem-with-yarn-2-ca59e3fabc9f">What&#x27;s the problem with Yarn 2? - Medium</a></p>
<h2 id="difference-between-yarn-version-2_-and-yarn-version-3_">Difference between Yarn version 2._ and Yarn version 3._</h2>
<p>Yarn version 2.*와 Yarn version 3.*에는 몇 가지 차이점이 있습니다.</p>
<ul>
<li>Yarn 3는 Yarn 2보다 성능이 향상되었습니다. 예를 들어, yarn install 명령어의 실행 시간이 약 30% 단축되었습니다.</li>
<li>Yarn 3는 esbuild를 사용하여 TypeScript 파일을 컴파일할 수 있습니다. 이 기능은 yarn plugin import typescript 명령어로 설치할 수 있으며, yarn tsc 명령어로 실행할 수 있습니다.</li>
<li>Yarn 3는 패키지의 버전 범위를 더 유연하게 지정할 수 있도록 해줍니다. 예를 들어, ^1.0.0 || ^2.0.0 과 같은 복합 버전 범위를 사용할 수 있습니다.</li>
<li>Yarn 3는 패키지의 의존성을 더 쉽게 수정할 수 있는 patch 프로토콜을 개선했습니다. 예를 들어, patch<!-- -->:foo<!-- -->@npm:1.0.0#./my-changes.patch 과 같은 형식으로 패치 파일을 지정할 수 있습니다.</li>
</ul>
<h3 id="references-14">References</h3>
<p>(1) <a href="http://geekdaxue.co/read/chencheng@mdh-weekly/ak0ta5">MDH 前端周刊第 13 期：Yarn 3、React Re-rendering、Just JavaScript</a>
(2) <a href="https://stackoverflow.com/questions/69019854/why-is-yarn-2-yarn-3-0-1">javascript - Why is &quot;yarn 2&quot; yarn 3.0.1? - Stack Overflow</a>
(3) <a href="https://plainenglish.io/blog/getting-started-with-yarn-3-and-typescript-125e7b537e6c">Getting Started with Yarn 3 and TypeScript - Medium</a>
(4) <a href="https://spin.atomicobject.com/2021/02/17/switch-yarn-2/">It’s 2021, and You Should Switch to Yarn 2 - Atomic Spin</a></p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="리눅스 기본 명령어"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/unix-s-various-cli-commands">UNIX의 다양한 CLI 명령어 😊</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-03-19T00:00:00.000Z" itemprop="datePublished">2023년 3월 19일</time> · <!-- -->약 3분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="리눅스-기본-명령어">리눅스 기본 명령어</h2>
<ul>
<li><code>ls</code>: 현재 디렉토리의 파일과 폴더를 보여줍니다. 옵션으로 <code>-a</code>, <code>-l</code> 등을 사용할 수 있습니다.</li>
<li><code>cd</code>: 디렉토리를 이동합니다. 예를 들어 <code>cd /home</code> 으로 홈 디렉토리로 이동할 수 있습니다.</li>
<li><code>pwd</code>: 현재 디렉토리의 경로를 보여줍니다.</li>
<li><code>cp</code>: 파일이나 폴더를 복사합니다. 예를 들어 <code>cp file1 file2</code> 는 <code>file1을 file2</code>로 복사합니다.</li>
<li><code>mv</code>: 파일이나 폴더의 이름을 바꾸거나 이동합니다. 예를 들어 mv file1 file2 는 file1의 이름을 file2로 바꿉니다.</li>
<li><code>rm</code>: 파일이나 폴더를 삭제합니다. 주의해서 사용해야 합니다. 옵션으로 <code>-r</code>, <code>-f</code> 등을 사용할 수 있습니다.</li>
<li><code>cat</code>: 파일의 내용을 화면에 출력하거나 파일을 만듭니다. 예를 들어 <code>cat filename</code> 은 <code>filename</code>의 내용을 출력하고 <code>cat &gt; filename</code> 은 새로운 <code>filename</code> 파일을 만듭니다.</li>
<li><code>find</code>: 각종 파일이나 폴더를 검색합니다. 예를 들어 <code>find -name &#x27;\*.pl&#x27;</code> 은 현재 디렉토리에서 pl확장자를 가진 모든 파일을 찾습니다.</li>
<li><code>ping</code>: 네트워크 연결 상태를 확인합니다. 예를 들어 <code>ping www.google.com</code> 은 구글과의 연결 상태와 시간을 보여줍니다.</li>
<li><code>date</code>: 현재 날짜와 시간을 보여줍니다.</li>
</ul>
<p>이 외에도 많은 리눅스 명령어가 있으니 참고하시기 바랍니다.</p>
<h3 id="references">References</h3>
<ol>
<li><a href="https://dora-guide.com/linux-commands/">리눅스 명령어 모음 BEST 50 초보자 및 전문가용 - 도라가이드.</a></li>
<li><a href="http://ivis.kr/images/e/e9/2018_Unix_command_vi.pdf">리눅스 기본 명령어 및 Vi 명령어 정리.</a></li>
<li><a href="https://itholic.github.io/linux-basic-command/">[linux] 리눅스 기본 명령어/자주 쓰는 명령어 | 코딩장이.</a></li>
</ol></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="블로그 게시물은 MDX와 같은 도큐사우루스 마크다운 기능을 지원합니다."><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/mdx-blog-post">MDX 블로그 포스팅 작성하기</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2021-08-01T00:00:00.000Z" itemprop="datePublished">2021년 8월 1일</time> · <!-- -->약 1분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>블로그 게시물은 <a href="https://mdxjs.com/">MDX</a>와 같은 <a href="https://docusaurus.io/docs/markdown-features">도큐사우루스 마크다운 기능</a>을 지원합니다.</p>
<admonition type="tip"><p>React의 강력한 기능을 사용하여 인터랙티브한 블로그 게시물을 작성하세요.</p><pre><code class="language-js">&lt;button onClick={() =&gt; alert(&quot;button clicked!&quot;)}&gt;Click me!&lt;/button&gt;
</code></pre><button>Click me!</button></admonition></div><footer class="row docusaurus-mt-lg"><div class="col"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/wiki/blog/tags/docusaurus">docusaurus</a></li></ul></div></footer></article><nav class="pagination-nav" aria-label="블로그 게시물 목록 탐색"><a class="pagination-nav__link pagination-nav__link--prev" href="/wiki/blog/page/4"><div class="pagination-nav__label">이전 페이지</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">문서</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/wiki/docs/intro">튜토리얼</a></li></ul></div><div class="col footer__col"><div class="footer__title">커뮤니티</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">스  택오버플로우<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">디스코드<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">트위터<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">더보기</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/wiki/blog">블로그</a></li><li class="footer__item"><a href="https://github.com/AndrewDongminYoo/wiki" target="_blank" rel="noopener noreferrer" class="footer__link-item">깃허브<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Dongmin Yu, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>