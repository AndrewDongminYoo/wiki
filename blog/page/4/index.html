<!doctype html>
<html lang="ko" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.0.0">
<title data-rh="true">블로그 | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://andrewdongminyoo.github.io/wiki/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://andrewdongminyoo.github.io/wiki/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://andrewdongminyoo.github.io/wiki/blog/page/4"><meta data-rh="true" property="og:locale" content="ko"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" property="og:title" content="블로그 | My Site"><meta data-rh="true" name="description" content="블로그"><meta data-rh="true" property="og:description" content="블로그"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="icon" href="/wiki/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://andrewdongminyoo.github.io/wiki/blog/page/4"><link data-rh="true" rel="alternate" href="https://andrewdongminyoo.github.io/wiki/blog/page/4" hreflang="ko"><link data-rh="true" rel="alternate" href="https://andrewdongminyoo.github.io/wiki/blog/page/4" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://W3IYVVWLWE-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/wiki/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/wiki/blog/atom.xml" title="My Site Atom Feed">



<link rel="search" type="application/opensearchdescription+xml" title="My Site" href="/wiki/opensearch.xml"><link rel="stylesheet" href="/wiki/assets/css/styles.87524305.css">
<script src="/wiki/assets/js/runtime~main.08d7e581.js" defer="defer"></script>
<script src="/wiki/assets/js/main.7baa3f39.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="본문으로 건너뛰기"><a class="skipToContent_D8pK" href="#__docusaurus_skipToContent_fallback">본문으로 건너뛰기</a></div><nav aria-label="메인" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="네비게이션 바 토글하기" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/wiki/"><div class="navbar__logo"><img src="/wiki/img/logo.svg" alt="내 사이트 로고" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/wiki/img/logo.svg" alt="내 사이트 로고" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">내 사이트</b></a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>한국어</a><ul class="dropdown__menu"><li><a href="/wiki/blog/page/4" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="ko">한국어</a></li></ul></div><a class="navbar__item navbar__link" href="/wiki/docs/intro">튜토리얼</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/wiki/blog">블로그</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/AndrewDongminYoo/wiki" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">깃허브<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="검색"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">검색</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="최근 블로그 문서 둘러보기"><div class="sidebarItemTitle_pO2u margin-bottom--md">최신글</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/blog/front-backend-developer-roadmap">프론트+백엔드 개발자 로드맵</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/blog/static-property-in-java-class">Static Property in Java Class</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/blog/four-mainstream-d-bs-and-features">  가장 많이 사용되는 주류 DB 4가지와 특징</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/blog/generate-unicode-emoji-regular-expression">Generate Unicode emoji regular expression</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/blog/redirection-of-the-website">웹사이트의 리다이렉팅 방식</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="https://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="Migrating React Native library to Turbo Modules"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/turbo-native-modules-react-native">Turbo Native Modules · React Native</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-04-04T00:00:00.000Z" itemprop="datePublished">2023년 4월 4일</time> · <!-- -->약 1분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="migrating-react-native-library-to-turbo-modules">Migrating React Native library to Turbo Modules</h2>
<p>Migrating your React Native library to use Turbo Modules, which is part of the new architecture of React Native, can provide several benefits. Turbo Modules are the next iteration on Native Modules and provide a few extra benefits such as strongly typed interfaces that are consistent across platforms, the ability to write your code in C++, either exclusively or integrated with another native platform language, reducing the need to duplicate implementations across platforms, lazy loading of modules, allowing for faster app startup and more efficient communication between native and JavaScript code than the bridge.</p>
<h3 id="references">References</h3>
<ol>
<li><a href="https://reactnative.dev/docs/the-new-architecture/pillars-turbomodules">Turbo Native Modules · React Native</a></li>
<li><a href="https://reactnative.dev/docs/the-new-architecture/backward-compatibility-turbomodules">Turbo Modules as Legacy Native Modules · React Native</a></li>
<li><a href="https://www.callstack.com/blog/migrating-a-react-native-library-to-the-new-architecture">Migrating a React Native Library to the New Architecture</a></li>
</ol></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="코드 예제"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/web-driver-manager-and-meipass">WebDriver Manager와 MEIPASS</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-04-03T00:00:00.000Z" itemprop="datePublished">2023년 4월 3일</time> · <!-- -->약 21분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="코드-예제">코드 예제</h2>
<pre><code class="language-python">if getattr(sys, &#x27;frozen&#x27;, False) and hasattr(sys, &#x27;_MEIPASS&#x27;):
     chrome_path = os.path.join(sys._MEIPASS, &#x27;chromedriver.exe&#x27;)
 else:
      chrome_path = ChromeDriverManager().install()
      chrome_service = Service(chrome_path)
</code></pre>
<h2 id="코드-설명">코드 설명</h2>
<p>이 코드는 PyInstaller로 생성된 번들 실행 파일에서 스크립트가 실행되는지 여부를 확인합니다. 만약 그렇다면 번들에 포함된 Chrome 드라이버의 경로를 설정합니다. 그렇지 않으면 ChromeDriverManager를 사용하여 Chrome 드라이버를 설치하고 경로를 설정합니다. 그런 다음 지정된 경로를 사용하여 Chrome 서비스 객체를 생성합니다.
webdriver.Chrome()을 사용하여 드라이버 인스턴스를 만들 때 이 코드가 없으면 에러가 발생할 수 있습니다. 이는 Chrome 드라이버의 경로가 올바르게 설정되지 않았기 때문일 수 있습니다. 이 코드는 Chrome 드라이버의 경로를 올바르게 설정하여 이러한 문제를 해결하는 데 도움이 됩니다.
<code>getattr(sys, &#x27;frozen&#x27;, False)</code>은 <code>sys</code> 모듈의 <code>frozen</code> 속성을 가져오는 코드입니다. <code>frozen</code> 속성은 스크립트가 PyInstaller로 생성된 번들 실행 파일에서 실행되는 경우에만 존재합니다. 따라서 이 코드는 스크립트가 번들 실행 파일에서 실행되는지 여부를 확인하는 데 사용됩니다. <code>False</code>는 <code>frozen</code> 속성이 존재하지 않을 경우 반환되는 기본값입니다.
<code>hasattr(sys, &#x27;_MEIPASS&#x27;)</code>는 <code>sys</code> 모듈에 <code>_MEIPASS</code> 속성이 있는지 여부를 확인하는 코드입니다. <code>_MEIPASS</code> 속성은 PyInstaller로 생성된 번들 실행 파일에서 스크립트가 실행되는 경우에만 존재하며, 번들의 임시 디렉토리 경로를 나타냅니다. 따라서 이 코드도 스크립트가 번들 실행 파일에서 실행되는지 여부를 확인하는 데 사용됩니다.
<code>_MEIPASS</code>는 PyInstaller의 내부 변수로, 약어가 아닙니다. 이 변수는 PyInstaller로 생성된 번들 실행 파일에서 스크립트가 실행되는 경우에만 존재하며, 번들의 임시 디렉토리 경로를 나타냅니다. 이 경로는 PyInstaller가 번들을 실행할 때 생성하는 임시 디렉토리로, 번들에 포함된 모든 리소스 파일이 이 디렉토리에 추출됩니다.
셀레니움(Selenium) 웹 드라이버의 생성자에 파라미터가 없는 경우, 셀레니움은 시스템 환경 변수 <code>PATH</code>에서 Chrome 드라이버의 실행 파일을 찾습니다. 따라서 Chrome 드라이버의 실행 파일이 <code>PATH</code>에 포함된 디렉토리에 있어야 합니다.
서비스 객체를 생성자의 <code>service</code> 파라미터로 전달하는 경우, 셀레니움은 서비스 객체가 가리키는 경로에서 Chrome 드라이버의 실행 파일을 찾습니다. 이 경우 <code>PATH</code>에 포함된 디렉토리에 Chrome 드라이버의 실행 파일이 없어도 됩니다. 서비스 객체를 사용하면 Chrome 드라이버의 경로를 명시적으로 지정할 수 있습니다.
<code>executable_path</code> 변수를 사용하여 Chrome 드라이버의 경로를 지정하는 것과 서비스 객체를 사용하여 Chrome 드라이버의 경로를 지정하는 것은 기능적으로 동일합니다. 둘 다 Chrome 드라이버의 경로를 명시적으로 지정할 수 있습니다.
그러나 서비스 객체를 사용하면 추가적인 옵션을 설정할 수 있습니다. 예를   들어, 서비스 객체의 <code>service_args</code> 속성을 사용하여 Chrome 드라이버의 로그 파일 경로나 로그 수준을 지정할 수 있습니다. 따라서 서비스 객체를 사용하는 것이 더 유연하고 확장 가능한 방법입니다.
<code>service_args</code> 속성은 서비스 객체를 생성할 때 전달할 수 있는 선택적 파라미터입니다. 이 속성은 Chrome 드라이버의 명령줄 인수를 지정하는 데 사용됩니다.
예를 들어, Chrome 드라이버의 로그 파일 경로와 로그 수준을 지정하려면 다음과 같이 <code>service_args</code> 속성을 사용할 수 있습니다.</p>
<pre><code class="language-python">from selenium.webdriver.chrome.service import Service
chrome_service = Service(executable_path=&#x27;/path/to/chromedriver&#x27;,
                         service_args=[&#x27;--log-path=/path/to/logfile&#x27;, &#x27;--verbose&#x27;])
</code></pre>
<p>위 코드에서 <code>--log-path</code> 인수는 Chrome 드라이버의 로그 파일 경로를 지정하고, <code>--verbose</code> 인수는 로그 수준을 지정합니다. 이 외에도 다양한 명령줄 인수를 사용하여 Chrome 드라이버의 동작을 제어할 수 있습니다.
Chrome 드라이버의 실행 파일에 <code>--help</code> 커맨드를 사용하면 사용 가능한 모든 명령줄 인수의 목록을 확인할 수 있습니다. 예를 들어, Windows에서는 명령 프롬프트에서 다음과 같이 입력할 수 있습니다.</p>
<pre><code class="language-batch">chromedriver.exe --help
</code></pre>
<p>Linux나 macOS에서는 터미널에서 다음과 같이 입력할 수 있습니다.</p>
<pre><code class="language-sh">./chromedriver --help
</code></pre>
<p>위 명령을 실행하면 Chrome 드라이버가 지원하는 모든 명령줄 인수와 각 인수의 설명이 출력됩니다. 이 정보를 참조하여 <code>service_args</code> 속성에 전달할 인수를 선택할 수 있습니다.
WebDriverManager는 Chrome 드라이버의 설치와 관리를 자동화하는 라이브러리입니다. 이 라이브러리는 시스템에 설치된 Chrome 브라우저의 버전과 호환되는 Chrome 드라이버의 버전을 자동으로 감지하고 설치합니다.
WebDriverManager를 사용하면 Chrome 드라이버의 버전을 수동으로 관리할 필요가 없습니다. WebDriverManager가 자동으로 Chrome 브라우저의 버전과 일치하는 Chrome 드라이버의 버전을 설치하므로, Chrome 브라우저와 Chrome 드라이버의 버전이 항상 일치합니다.
만약 시스템에 이미 설치된 Chrome 드라이버의 버전이 Chrome 브라우저의 버전과 일치하지 않는 경우, WebDriverManager는 새로운 버전의 Chrome 드라이버를 다운로드하여 설치합니다. 따라서 WebDriverManager를 사용하면 Chrome 드라이버의 버전 관리가 편리해집니다.</p>
<h2 id="셀레니움-selenium">셀레니움 (Selenium)</h2>
<p>셀레니움(Selenium)은 여러 가지 프로그래밍 언어를 지원합니다. 이 중에서 가장 인기 있는 언어는 Java입니다. 그러나 Python, C#, Ruby, JavaScript 등도 셀레니움을 사용하는 데 널리 사용되는 언어들입니다.
각 언어의 성능은 다양한 요인에 따라 달라질 수 있습니다. 따라서 특정 언어가 다른 언어보다 더 좋은 성능을 보장하는 것은 아닙니다. 셀레니움을 사용할 때 중요한 것은 개발팀이 사용하는 언어와의 호환성, 개발자 커뮤니티의 지원 정도, 개발자의 경험 등이 있습니다.</p>
<h3 id="references">References</h3>
<p>(1) <a href="https://www.qafox.com/different-programming-languages-supported-by-selenium/">What are the different programming languages supported by Selenium? - QAFox</a>
(2) <a href="https://dzone.com/articles/how-to-select-programming-language-for-selenium-au">Selecting a Programming Language for Selenium Automation Testing</a>
(3) <a href="https://www.tutorsbot.com/blog/Best-Language-for-Selenium-Testing">Best Language for Selenium Testing - Tutorsbot</a>
(4) <a href="https://www.cigniti.com/blog/programing-language-to-build-selenium-based-test-automation-suite/">Selecting a Programming Language to build Selenium Test Automation Suite - Cigniti</a>
(5) <a href="https://www.browserstack.com/guide/puppeteer-vs-selenium">Puppeteer vs Selenium: Core Differences | BrowserStack</a>
(6) <a href="https://testsigma.com/blog/puppeteer-vs-selenium/">Puppeteer vs Selenium - A Comparison Between 2 Automated Testing Libraries</a>
(7) <a href="https://research.aimultiple.com/cheerio-vs-puppeteer/">Cheerio vs Puppeteer for Web Scraping in 2023: In-Depth Guide</a></p>
<p>Puppeteer와 Selenium은 모두 웹 자동화 도구로, 웹 페이지의 테스트와 크롤링 등에 사용됩니다. 하지만 이들은 몇 가지 차이점이 있습니다.
Puppeteer는 Google에서 개발한 Node.js 라이브러리로, Chrome과 Chromium 브라우저를 제어하는 데 사용됩니다. Puppeteer는 Chrome DevTools Protocol을 사용하여 브라우저를 제어하며, 기본적으로 headless 모드로 실행됩니다. 이는 화면에 브라우저 창을 띄우지 않고 백그라운드에서 실행되는 것을 의미합니다.</p>
<h2 id="puppeteer">Puppeteer</h2>
<p>Puppeteer는 스크린샷 캡처, PDF 생성, 웹 스크래핑 등 다양한 기능을 제공합니다. 하지만 Puppeteer는 Chrome과 Chromium 브라우저만 지원하며, JavaScript 언어만 사용할 수 있습니다.
반면 Selenium은 여러 가지 브라우저와 프로그래밍 언어를 지원하는 웹 자동화 도구입니다. Selenium은 Java, Python, C#, Ruby 등 다양한 언어로 테스트 스크립트를 작성할 수 있으며, Chrome, Firefox, Safari 등 다양한 브라우저에서 테스트를 실행할 수 있습니다. Selenium은 큰 커뮤니티 지원과 다양한 라이브러리 및 확장 기능을 제공합니다.
Puppeteer와 Selenium의 선택은 사용자의 요구사항과 환경에 따라 달라질 수 있습니다. Puppeteer는 Chrome 브라우저에서 빠른 성능을 제공하며, JavaScript 언어로 간단하게 사용할 수 있습니다. 반면 Selenium은 여러 가지 브라우저와 언어를 지원하며, 큰 커뮤니티 지원을 받습니다.</p>
<h2 id="selenium">Selenium</h2>
<p>Selenium은 웹 애플리케이션의 자동화 테스트를 위한 도구로, 모바일 애플리케이션의 테스트에는 직접 사용할 수 없습니다. 하지만 Appium이라는 모바일 애플리케이션 자동화 테스트 도구가 있습니다. Appium은 Selenium과 유사한 API를 제공하며, iOS와 Android 모바일 애플리케이션의 자동화 테스트를 지원합니다.</p>
<h2 id="appium">Appium</h2>
<p>Appium은 Selenium WebDriver와 호환되며, Selenium과 유사한 방식으로 사용할 수 있습니다. 따라서 Selenium을 사용해본 경험이 있다면 Appium을 쉽게 사용할 수 있습니다. Appium은 Java, Python, Ruby, JavaScript 등 다양한 언어로 테스트 스크립트를 작성할 수 있습니다.
Appium은 Dan Cuellar에 의해 2011년에 개발되었습니다. 처음에는 &quot;iOSAuto&quot;라는 이름으로 C# 프로그래밍 언어로 작성되었습니다. 2012년 8월에 Apache 2 라이선스로 오픈소스화되었고, 2013년 1월에 Sauce Labs가 Appium의 개발을 지원하면서 Node.js로 코드가 재작성되었습니다.
Appium은 모바일 애플리케이션의 자동화 테스트를 위한 오픈소스 도구로, iOS와 Android 모바일 애플리케이션의 테스트를 지원합니다. Appium은 Selenium과 유사한 API를 제공하며, Java, Python, Ruby 등 다양한 언어로 테스트 스크립트를 작성할 수 있습니다.</p>
<h3 id="references-1">References</h3>
<p>(1) <a href="https://en.wikipedia.org/wiki/Appium">Appium - Wikipedia</a>
(2) <a href="https://appium.io/history.html?lang=en">Appium: Mobile App Automation Made Awesome.</a>
(3) <a href="https://www.devopsschool.com/blog/what-is-appium-and-how-does-it-work-an-overview-and-its-use-cases/">What is Appium and How does it work? An Overview and Its Use Cases</a></p>
<h2 id="크로스플랫폼-프레임워크로-만들어진-모바일-앱의-자동화-테스트">크로스플랫폼 프레임워크로 만들어진 모바일 앱의 자동화 테스트</h2>
<p>크로스플랫폼 프레임워크로 만들어진 모바일 앱의 경우에도, 안드로이드와 iOS 각각의 테스트 스크립트를 작성해야 합니다. 이는 안드로이드와 iOS가 각각 다른 운영 체제이기 때문입니다. 따라서 Appium을 사용하여 안드로이드와 iOS 앱을 테스트할 때에는 각각의 테스트 스크립트를 작성해야 합니다. 하지만 Appium은 Selenium과 유사한 API를 제공하므로, Selenium을 사용해본 경험이 있다면 Appium을 쉽게 사용할 수 있습니다. 또한 Appium은 Page Object Model과 같은 디자인 패턴을 사용하여 테스트 코드의 재사용성을 높일 수 있습니다. 이를 통해 안드로이드와 iOS 앱의 테스트 코드를 최대한 비슷하게 작성할 수 있습니다. Appium을 사용하려면 먼저 Appium 서버를 설치해야 합니다. Appium 서버는 Node.js로 작성되었으므로 Node.js와 npm이 설치되어 있어야 합니다. Appium 서버를 설치하려면 다음 명령을 실행합니다.</p>
<pre><code class="language-sh">npm install -g appium
</code></pre>
<p>Appium 서버를 설치한 후에는 Appium 클라이언트 라이브러리를 사용하여 테스트 스크립트를 작성할 수 있습니다. Appium 클라이언트 라이브러리는 Java, Python, Ruby 등 다양한 언어로 제공됩니다. 예를 들어, Python으로 테스트 스크립트를 작성하려면 다음 명령으로 Appium의 Python 클라이언트 라이브러리를 설치할 수 있습니다.</p>
<pre><code class="language-sh">pip install Appium-Python-Client
</code></pre>
<p>Appium 클라이언트 라이브러리를 설치한 후에는 Selenium과 유사한 방식으로 테스트 스크립트를 작성할 수 있습니다. 예를 들어, 다음은 Python으로 작성된 간단한 Appium 테스트 스크립트입니다.</p>
<pre><code class="language-python">from appium import webdriver
desired_caps = {
    &quot;platformName&quot;: &quot;Android&quot;,
    &quot;platformVersion&quot;: &quot;9.0&quot;,
    &quot;deviceName&quot;: &quot;Android Emulator&quot;,
    &quot;app&quot;: &quot;/path/to/your/app.apk&quot;
}
driver = webdriver.Remote(&quot;http://localhost:4723/wd/hub&quot;, desired_caps)
# 여기에 테스트 코드를 작성합니다.
driver.quit()
</code></pre>
<p>위 코드에서 <code>desired_caps</code> 변수는 테스트할 모바일 장치와 앱의 정보를 지정합니다. <code>webdriver.Remote</code> 메서드를 사용하여 Appium 서버에 연결하고, 이후에는 Selenium과 유사한 방식으로 테스트 코드를 작성할 수 있습니다.
Appium 서버는 Node.js로 작성되었기 때문에 Appium 서버를 실행하려면 Node.js가 설치되어 있어야 합니다. 하지만 Appium 클라이언트 라이브러리는 여러 가지 언어로 제공되므로, 테스트 스크립트를 작성할 때에는 Node.js가 아닌 다른 언어를 사용할 수 있습니다.
리액트 네이티브 애플리케이션의 UI 테스트를 위해서는 Detox라는 도구를 사용할 수 있습니다. Detox는 리액트 네이티브 애플리케이션의 엔드-투-엔드 테스트를 위한 도구로, iOS와 Android 모바일 애플리케이션의 테스트를 지원합니다. Detox는 빠른 테스트 실행 속도와 안정적인 테스트 결과를 제공합니다.
Detox 테스트가 실패하는 경우에는 여러 가지 원인이 있을 수 있습니다. 먼저 Detox의 문서와 트러블슈팅 가이드를 참조하여 일반적인 문제와 해결 방법을 확인해보세요. 또한 Detox 테스트의 로그를 확인하여 실패 원인을 파악할 수 있습니다.
E2E 테스트의 규모를 줄이는 것 외에도, 다음과 같은 방법으로 테스트의 안정성을 높일 수 있습니다.</p>
<ul>
<li>테스트 전에 앱의 상태를 초기화하여 테스트가 항상 동일한 상태에서 시작하도록 합니다.</li>
<li>네트워크 지연이나 애니메이션 등으로 인한 지연을 고려하여 적절한 대기 시간을 설정합니다.</li>
<li>테스트 중 발생하는 예외 상황을 처리하는 코드를 작성합니다.
또한 Detox는 Jest와 같은 테스트 프레임워크와 함께 사용할 수 있습니다. Jest의 기능을 활용하여 테스트 코드의 구조화와 재사용성을 높일 수 있습니다.
Jest는 JavaScript 테스트 프레임워크로, Detox와 함께 사용하여 리액트 네이티브 애플리케이션의 E2E 테스트를 작성할 수 있습니다. Jest를 사용하면 테스트 코드의 구조화와 재사용성을 높일 수 있습니다.
다음은 Jest와 Detox를 함께 사용하는 간단한 예제 코드입니다.</li>
</ul>
<pre><code class="language-javascript">describe(&quot;Login&quot;, () =&gt; {
  beforeAll(async () =&gt; {
    await device.reloadReactNative();
  });
  it(&quot;should show login screen&quot;, async () =&gt; {
    await expect(element(by.id(&quot;loginScreen&quot;))).toBeVisible();
  });
  it(&quot;should login successfully&quot;, async () =&gt; {
    await element(by.id(&quot;emailInput&quot;)).typeText(&quot;user@example.com&quot;);
    await element(by.id(&quot;passwordInput&quot;)).typeText(&quot;password&quot;);
    await element(by.id(&quot;loginButton&quot;)).tap();
    await expect(element(by.id(&quot;homeScreen&quot;))).toBeVisible();
  });
});
</code></pre>
<p>위 코드에서 <code>describe</code> 함수는 Jest에서 제공하는 함수로, 관련된 테스트 케이스들을 그룹화하는 데 사용됩니다. <code>beforeAll</code> 함수는 테스트 그룹의 모든 테스트 케이스가 실행되기 전에 한 번만 실행되는 함수로, 이 예제에서는 앱의 상태를 초기화하는 데 사용됩니다. <code>it</code> 함수는 각각의 테스트 케이스를 정의하는 데 사용됩니다.
위 예제에서처럼 Jest의 기능을 활용하면 Detox 테스트 코드를 구조화하고 재사용성을 높일 수 있습니다.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="WebGL: 웹 그래픽 라이브러리(Web Graphics Library)"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/web-gl-open-gl">WebGL &amp; OpenGL</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-03-29T00:00:00.000Z" itemprop="datePublished">2023년 3월 29일</time> · <!-- -->약 20분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="webgl-웹-그래픽-라이브러리web-graphics-library">WebGL: 웹 그래픽 라이브러리(Web Graphics Library)</h2>
<p>WebGL은 웹 그래픽 라이브러리(Web Graphics Library)의 약자로, 웹 브라우저에서 상호작용 가능한 3D와 2D 그래픽을 표현하기 위한 JavaScript API입니다. WebGL은 HTML5 &lt;canvas&gt; 요소에서 사용할 수 있는, OpenGL ES 2.0을 대부분 충족하는 API를 제공합니다. WebGL은 플러그인을 사용하지 않고 웹 브라우저에서 상호작용 가능한 3D와 2D 그래픽을 표현하기 위한 JavaScript API입니다.</p>
<h3 id="references">References</h3>
<ol>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">WebGL: 2D and 3D graphics for the web - Web APIs | MDN - Mozilla</a></li>
<li><a href="https://developer.mozilla.org/ko/docs/Web/API/WebGL_API">WebGL - Web API | MDN</a></li>
<li><a href="https://en.wikipedia.org/wiki/WebGL">WebGL - Wikipedia</a></li>
</ol>
<h2 id="webgl과-opengl">WebGL과 OpenGL</h2>
<p>WebGL 1.0은 대부분의 주요 브라우저의 안정적인 릴리즈에서 데스크탑 및 모바일 플랫폼 모두에서 지원됩니다. Chrome, Firefox, Internet Explorer, Opera 및 Safari는 모두 데스크탑 및 모바일 브라우저에서 WebGL 지원이 좋은 것으로 알려져 있습니다. 그러나 사용자의 장치도 WebGL 기능을 지원해야 합니다.</p>
<p>OpenGL ES는 OpenGL for Embedded Systems의 약자로, OpenGL 컴퓨터 그래픽 렌더링 응용 프로그래밍 인터페이스(API)의 하위 집합입니다. 이 API는 비디오 게임에서 사용하는 것과 같은 2D 및 3D 컴퓨터 그래픽을 렌더링하기 위해 설계되었으며 일반적으로 그래픽 처리 장치(GPU)를 사용하여 하드웨어 가속됩니다. 스마트폰, 태블릿 컴퓨터, 비디오 게임 콘솔 및 PDA와 같은 임베디드 시스템용으로 설계되었습니다. OpenGL ES 2.0은 OpenGL ES의 버전 중 하나로, 이전 버전인 OpenGL ES 1.X와 달리 프로그래밍 가능한 셰이딩을 지원합니다. 이는 모바일 그래픽 하드웨어의 최신 세대에서 프로그래막 가능한 셰이더를 노출하는 최초의 이식 가능한 모바일 그래픽 API였습니다.</p>
<h3 id="references-1">References</h3>
<ol>
<li><a href="https://en.wikipedia.org/wiki/OpenGL_ES">OpenGL ES - Wikipedia</a></li>
<li><a href="https://www.khronos.org/opengles/">OpenGL ES Overview - The Khronos Group Inc</a></li>
<li><a href="https://registry.khronos.org/OpenGL/index_es.php">Khronos OpenGL ES Registry - The Khronos Group Inc</a></li>
</ol>
<h2 id="opengl-es-20">OpenGL ES 2.0</h2>
<p>OpenGL ES 2.0은 OpenGL ES의 버전 중 하나로, 이전 버전인 OpenGL ES 1.X와 달리 프로그래밍 가능한 셰이딩을 지원합니다. 이는 모바일 그래픽 하드웨어의 최신 세대에서 프로그래막 가능한 셰이더를 노출하는 최초의 이식 가능한 모바일 그래픽 API였습니다.
OpenGL ES 2.0 API에는 다양한 함수와 명령이 정의되어 있습니다. 이러한 함수와 명령은 프로그래머가 고품질의 그래픽 이미지, 특히 3차원 객체의 컬러 이미지를 생성하는 데 필요한 객체와 작업을 지정할 수 있도록 합니다. OpenGL ES 2.0 API에 대한 자세한 정보는 Khronos Group의 웹사이트에서 찾을 수 있습니다.</p>
<h3 id="references-2">References</h3>
<ol>
<li><a href="https://www.khronos.org/opengles/">OpenGL ES Overview - The Khronos Group Inc</a></li>
<li><a href="https://www.khronos.org/opengles/sdk/docs/reference_cards/OpenGL-ES-2_0-Reference-card.pdf">OpenGL ES 2.0 API Quick Reference Card - Khronos Group</a></li>
<li><a href="https://registry.khronos.org/OpenGL/index_es.php">Khronos OpenGL ES Registry - The Khronos Group Inc</a></li>
</ol>
<h2 id="opengl-es-20-api의-주요-함수와-명령">OpenGL ES 2.0 API의 주요 함수와 명령</h2>
<p>OpenGL ES 2.0 API에는 다양한 함수와 명령이 정의되어 있습니다. 이러한 함수와 명령은 프로그래머가 고품질의 그래픽 이미지, 특히 3차원 객체의 컬러 이미지를 생성하는 데 필요한 객체와 작업을 지정할 수 있도록 합니다. OpenGL ES 2.0 API에 대한 자세한 정보는 Khronos Group의 웹사이트에서 찾을 수 있습니다.</p>
<ul>
<li><code>glGenBuffers()</code>, <code>glBindBuffer()</code>, <code>glBufferData()</code>, <code>glBufferSubData()</code>: 버퍼 객체 생성 및 데이터 저장</li>
<li><code>glCreateShader()</code>, <code>glShaderSource()</code>, <code>glCompileShader()</code>: 셰이더 생성 및 컴파일</li>
<li><code>glCreateProgram()</code>, <code>glAttachShader()</code>, <code>glLinkProgram()</code>, <code>glUseProgram()</code>: 셰이더 프로그램 생성 및 사용</li>
<li><code>glVertexAttribPointer()</code>, <code>glEnableVertexAttribArray()</code>: 정점 속성 지정</li>
<li><code>glDrawArrays()</code>, <code>glDrawElements()</code>: 기하학적 도형 렌더링</li>
</ul>
<h2 id="셰이더-프로그램">셰이더 프로그램</h2>
<p>셰이더 프로그램은 그래픽 파이프라인의 특정 부분에서 실행되는 작은 프로그램입니다. OpenGL ES 2.0에서는 두 가지 유형의 셰이더가 지원됩니다: 버텍스 셰이더와 프래그먼트 셰이더.
버텍스 셰이더는 모든 정점에 대해 실행되며, 정점의 위치와 다른 속성을 계산하는 데 사용됩니다. 프래그먼트 셰이더는 화면에 그려지는 각 픽셀에 대해 실행되며, 픽셀의 최종 색상을 계산하는 데 사용됩니다.
셰이더 프로그램은 버텍스 셰이더와 프래그먼트 셰이더를 결합하여 생성됩니다. 먼저 <code>glCreateShader()</code> 함수를 사용하여 각 셰이더 객체를 생성한 다음, <code>glShaderSource()</code> 함수를 사용하여 셰이더 소스 코드를 지정하고 <code>glCompileShader()</code> 함수를 사용하여 셰이더를 컴파일합니다. 그런 다음 <code>glCreateProgram()</code> 함수를 사용하여 셰이더 프로그램 객체를 생성하고, <code>glAttachShader()</code> 함수를 사용하여 버텍스 셰이더와 프래그먼트 셰이더를 프로그램에 첨부한 다음, <code>glLinkProgram()</code> 함수를 사용하여 프로그램을 링크합니다. 마지막으로 <code>glUseProgram()</code> 함수를 사용하여 링크된 프로그램을 현재 렌더링 상태의 일부로 지정합니다.
셰이더 프로그램을 사용하면 개발자가 그래픽 파이프라인의 중요한 부분을 직접 제어할 수 있어 더욱 유연하고 강력한 그래픽 효과를 만들 수 있습니다.
셰이더 소스 코드는 OpenGL ES 셰이딩 언어(GLSL ES)로 작성됩니다. GLSL ES는 C 언어와 유사한 구문을 가진 고수준 프로그래밍 언어로, 그래픽 처리 장치(GPU)에서 실행되도록 설계되었습니다.
셰이더 소스 코드는 일반적으로 문자열 형태로 작성되며, <code>glShaderSource()</code> 함수를 사용하여 셰이더 객체에 전달됩니다. 각 셰이더 유형(버텍스 셰이더 또는 프래그먼트 셰이더)에 대해 다른 소스 코드가 필요합니다.
GLSL ES에는 벡터, 행렬, 텍스처 등과 같은 그래픽 처리에 유용한 데이터 형식과 함수가 포함되어 있습니다. 또한 조건문, 반복문, 함수 정의 등과 같은 일반적인 프로그래밍 구조도 지원됩니다.</p>
<h2 id="간단한-버텍스-셰이더-예제">간단한 버텍스 셰이더 예제</h2>
<pre><code class="language-glsl">attribute vec4 a_position;
uniform mat4 u_mvpMatrix;
void main() {
    gl_Position = u_mvpMatrix * a_position;
}
</code></pre>
<p>이 버텍스 셰이더는 정점 위치(<code>a_position</code>)를 모델-뷰-투영 행렬(<code>u_mvpMatrix</code>)로 변환하여 최종 정점 위치(<code>gl_Position</code>)를 계산합니다.</p>
<pre><code class="language-glsl">precision mediump float;
uniform vec4 u_color;
void main() {
    gl_FragColor = u_color;
}
</code></pre>
<p>이 프래그먼트 셰이더는 모든 픽셀의 색상을 동일한 색상(<code>u_color</code>)으로 설정합니다.</p>
<h2 id="nodejs에서-opengl을-활용하는-방법">Node.js에서 OpenGL을 활용하는 방법</h2>
<p>셰이더 소스 코드 작성에 대한 자세한 정보는 OpenGL ES 셰이딩 언어 사양서에서 찾을 수 있습니다.
Node.js에서 OpenGL을 활용할 수 있는 몇 가지 라이브러리가 있습니다. 이 중 일부는 다음과 같습니다:</p>
<ul>
<li><code>node-webgl</code>: 데스크톱 OpenGL에 대한 WebGL 바인딩</li>
<li><code>headless-gl</code>: Node.js에서 windowless WebGL을 제공하는 라 이브러리</li>
<li><code>node-glfw</code>: Node.js에서 GLFW 바인딩</li>
<li><code>node-occ</code>: OpenCascade와 NodeJS로 BREP Solids를 구축하는 3D 모델링 라이브러리</li>
</ul>
<h3 id="references-3">References</h3>
<ol>
<li><a href="https://github.com/mikeseven/node-webgl">GitHub - mikeseven/node-webgl: WebGL bindings to desktop OpenGL</a></li>
<li><a href="https://openbase.com/categories/js/best-nodejs-graphics-libraries">10 Best Node.js Graphics Libraries in 2023 | Openbase</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/web/api/webgl_api/tutorial/getting_started_with_webgl">Getting started with WebGL - Web APIs | MDN - Mozilla</a></li>
</ol>
<h2 id="webgl을-기반으로-풍부한-반응형-ui를-제공하는-라이브러리">WebGL을 기반으로 풍부한 반응형 UI를 제공하는 라이브러리</h2>
<ul>
<li><code>Three.js</code>: WebGL을 사용하여 3D 그래픽을 쉽게 생성할 수 있는 JavaScript 라이브러리</li>
<li><code>Babylon.js</code>: 강력한 3D 엔진으로, WebGL을 사용하여 3D 그래픽을 생성하는 데 사용됩니다</li>
<li><code>A-Frame</code>: 웹에서 가상 현실(VR) 경험을 쉽게 만들 수 있는 웹 프레임워크</li>
<li><code>PlayCanvas</code>: WebGL 기반의 3D 게임 엔진으로, 강력한 툴과 API를 제공합니다</li>
</ul>
<h3 id="references-4">References</h3>
<ol>
<li><a href="https://en.wikipedia.org/wiki/List_of_WebGL_frameworks">List of WebGL frameworks - Wikipedia</a></li>
<li><a href="https://openbase.com/categories/js/best-javascript-webgl-libraries">10 Best JavaScript WebGL Libraries in 2023 | Openbase</a></li>
<li><a href="https://github.com/bradtraversy/design-resources-for-developers">GitHub - bradtraversy/design-resources-for-developers: Curated list of design and UI ...</a></li>
</ol>
<h2 id="threejs">Three.js</h2>
<p>Three.js는 WebGL을 사용하여 3D 그래픽을 쉽게 생성할 수 있는 JavaScript 라이브러리입니다. 이 라이브러리는 다양한 3D 객체, 재질, 조명, 애니메이션, 카메라 등을 제공하여 개발자가 쉽게 3D 씬을 구성하고 렌더링할 수 있도록 합니다. Three.js는 다양한 형식의 3D 모델을 로드하고, 물리 엔진과 통합하며, 다양한 효과와 포스트 프로세싱 기능을 제공합니다. 이 라이브러리는 웹 브라우저에서 실행되므로, 플러그인이나 추가 설치 없이도 사용자가 쉽게 접근할 수 있습니다. Three.js는 꾸준히 업데이트되고 있으며, 활발한 커뮤니티와 많은 예제 및 문서가 제공됩니다. 이 라이브러리를 사용하면 개발자가 WebGL의 복잡한 세부 사항을 걱정하지 않고도 강력한 3D 그래픽을 쉽게 만들 수 있습니다. Three.js의 공식 웹사이트에는 다양한 예제가 제공됩니다. 이 예제들은 Three.js의 다양한 기능을 보여주며, 개발자가 이 라이브러리를 사용하는 방법을 배울 수 있도록 도와줍니다.
다음은 간단한 Three.js 예제입니다:</p>
<pre><code class="language-javascript">// 씬 생성
const scene = new THREE.Scene();
// 카메라 생성
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000,
);
// 렌더러 생성

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
// 큐브 생성

const geometry = new THREE.BoxGeometry();
const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
const cube = new THREE.Mesh(geometry, material);
scene.add(cube);
// 카메라 위치 조정
camera.position.z = 5;
// 애니메이션 루프
function animate() {
  requestAnimationFrame(animate); // 큐브 회전
  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01; // 렌더링
  renderer.render(scene, camera);
}
animate();
</code></pre>
<p>이 예제는 Three.js를 사용하여 간단한 큐브를 생성하고 회전시키는 방법을 보여줍니다. 먼저 씬, 카메라, 렌더러를 생성하고, 큐브의 기하학과 재질을 정의하여 큐브 메시를 생성합니다. 그런 다음 큐브를 씬에 추가하고, 애니메이션 루프에서 큐브를 회전시키며 렌더링합니다.
Three.js의 공식 웹사이트에서는 이보다 훨씬 더 다양하고 복잡한 예제들을 볼 수 있습니다.
Three.js를 React 또는 React Native에서 사용하기 위한 몇 가지 래퍼(wrapper) 컴포넌트가 있습니다. 이러한 래퍼 컴포넌트는 Three.js의 기능을 React 컴포넌트로 캡슐화하여 개발자가 쉽게 사용할 수 있도록 합니다.
React에서 Three.js를 사용하기 위한 래퍼 컴포넌트 중 일부는 다음과 같습니다:</p>
<ul>
<li><code>react-three-fiber</code>: Three.js의 선언적 리액트 렌더러</li>
<li><code>threejs-react-wrapper</code>: Three.js 코드를 React 컴포넌트 내에서 실행할 수 있는 간단한 래퍼</li>
</ul>
<p>React Native에서 Three.js를 사용하기 위한 래퍼 컴포넌트 중 하나는 다음과 같습니다:</p>
<ul>
<li><code>expo-three</code>: Expo와 함께 사용할 수 있는 Three.js 래퍼</li>
</ul>
<h3 id="references-5">References</h3>
<ol>
<li><a href="https://medium.com/@colesayershapiro/using-three-js-in-react-6cb71e87bdf4">Using Three.js in React - Medium</a></li>
<li><a href="https://github.com/felixturner/threejs-react-wrapper">GitHub - felixturner/threejs-react-wrapper</a></li>
<li><a href="https://medium.com/@akinncar/how-to-develop-3d-games-with-react-native-using-three-js-d01b8132758">How to develop 3D games with React Native using Three.js</a></li>
</ol>
<h2 id="expo-three-js-모듈">Expo Three JS 모듈</h2>
<p><code>expo-three</code>는 Expo와 함께 사용할 수 있는 Three.js 래퍼입니다. 이 라이브러리는 Expo 앱에서 Three.js의 기능을 쉽게 사용할 수 있도록 지원합니다.
<code>expo-three</code>를 사용하면 개발자가 Expo 앱에서 Three.js의 다양한 기능을 사용하여 3D 그래픽을 생성하고 렌더링할 수 있습니다. 이 라이브러리는 Three.js의 기본 객체와 메소드를 지원하며, 추가적으로 Expo의 기능과 통합되어 있습니다.
<code>expo-three</code>는 Expo 앱에서 Three.js를 사용하는 데 필요한 추가 설정이나 설치 없이 쉽게 사용할 수 있습니다. 이 라이브러리의 문서와 예제는 GitHub에서 찾을 수 있습니다.
<code>expo-three</code>의 GitHub 저장소에는 다양한 예제가 제공됩니다. 이 예제들은 <code>expo-three</code>의 다양한 기능을 보여주며, 개발자가 이 라이브러리를 사용하는 방법을 배울 수 있도록 도와줍니다.
다음은 간단한 <code>expo-three</code> 예제입니다:</p>
<pre><code class="language-javascript">import React from &quot;react&quot;;
import { View } from &quot;react-native&quot;;
import { GLView } from &quot;expo-gl&quot;;
import ExpoTHREE, { THREE } from &quot;expo-three&quot;;
export default function App() {
  return (
    &lt;View style={{ flex: 1 }}&gt;
           {&quot; &quot;}
      &lt;GLView
        style={{ flex: 1 }}
        onContextCreate={async (gl) =&gt; {
          const scene = new THREE.Scene();
          const camera = new THREE.PerspectiveCamera(
            75,

            gl.drawingBufferWidth / gl.drawingBufferHeight,

            0.1,

            1000,
          );
          const renderer = new ExpoTHREE.Renderer({ gl });
          renderer.setSize(gl.drawingBufferWidth, gl.drawingBufferHeight);
          const geometry = new THREE.BoxGeometry(1, 1, 1);
          const material = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
          });
          const cube = new THREE.Mesh(geometry, material);
          scene.add(cube);
          camera.position.z = 5;
          const animate = () =&gt; {
            requestAnimationFrame(animate);
            cube.rotation.x += 0.01;
            cube.rotation.y += 0.01;
            renderer.render(scene, camera);
            gl.endFrameEXP();
          };
          animate();
        }}
      /&gt;
         {&quot; &quot;}
    &lt;/View&gt;
  );
}
</code></pre>
<p>이 예제는 <code>expo-three</code>를 사용하여 간단한 큐브를 생성하고 회전시키는 방법을 보여줍니다. 먼저 씬, 카메라, 렌더러를 생성하고, 큐브의 기하학과 재질을 정의하여 큐브 메시를 생성합니다. 그런 다음 큐브를 씬에 추가하고, 애니메이션 루프에서 큐브를 회전시키며 렌더링합니다.
<code>expo-three</code>의 GitHub 저장소에서는 이보다 훨씬 더 다양하고 복잡한 예제들을 볼 수 있습니다.</p>
<h2 id="threejs의-3d-모델을-공유하는-오픈소스-커뮤니티">Three.js의 3D 모델을 공유하는 오픈소스 커뮤니티</h2>
<p>Three.js의 3D 모델을 공유하는 오픈소스 커뮤니티가 몇 가지 있습니다. 이러한 커뮤니티에서는 개발자들이 Three.js로 만든 3D 모델을 공유하고, 서로의 작업을 검토하고 피드백을 제공합니다.
Three.js의 공식 웹사이트에서는 다양한 예제와 모델이 제공됩니다. 이 예제들은 Three.js의 다양한 기능을 보여주며, 개발자가 이 라이브러리를 사용하는 방법을 배울 수 있도록 도와줍니다.
또한 GitHub에서도 Three.js로 만든 3D 모델을 찾아볼 수 있습니다. 여러 개발자들이 자신의 작업물을 GitHub 저장소에 공유하고 있으며, 이러한 저장소에서는 다양한 종류의 3D 모델을 찾아볼 수 있습니다.</p>
<h3 id="references-6">References</h3>
<ol>
<li><a href="https://threejs.org/">Three.js – JavaScript 3D Library</a></li>
<li><a href="https://github.com/mrdoob/three.js/">GitHub - mrdoob/three.js: JavaScript 3D Library.</a></li>
<li><a href="https://speckyboy.com/three-js-in-action/">10 Stunning Open-Source Examples of Three.js In Action - Speckyboy Design Magazine</a></li>
<li><a href="https://github.com/Fasani/three-js-resources">GitHub - Fasani/three-js-resources: A collection of resources for building 3D projects ...</a></li>
</ol>
<p>Three.js의 공식 웹사이트에는 다양한 예제 모델이 제공됩니다. 이 예제들은 Three.js의 다양한 기능을 보여주며, 개발자가 이 라이브러리를 사용하는 방법을 배울 수 있도록 도와줍니다. 예를 들어, Three.js의 공식 웹사이트에서는 다음과 같은 예제 모델들을 볼 수 있습니다:</p>
<ul>
<li>Interactive Cubes: 마우스로 상호작용하는 큐브 모델</li>
<li>Clipping with Cap: 클리핑 효과가 적용된 모델</li>
<li>Morph Targets: 모핑 타겟 애니메이션이 적용된 모델</li>
<li>Lines: 다양한 선 스타일이 적용된 모델</li>
</ul>
<p>Three.js의 공식 웹사이트에서는 이보다 훨씬 더 다양하고 복잡한 예제 모델들을 볼 수 있습니다. 이러한 예제들은 Three.js의 다양한 기능과 가능성을 보여주며, 개발자가 이 라이브러리를 사용하여 자신만의 3D 모델을 만드는 데 도움이 됩니다.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="Postman과 Newman 라이브러리"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/postman-and-newman">Postman과 NewMan Library의 사용방법</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-03-28T00:00:00.000Z" itemprop="datePublished">2023년 3월 28일</time> · <!-- -->약 19분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="postman과-newman-라이브러리">Postman과 Newman 라이브러리</h2>
<p>Postman은 Node.js 기반의 런타임을 포함하고 있어, Request와 Collection에 동적으로 동작을 추가할 수 있습니다. 이를 통해 동적 매개변수를 사용하거나 요청 간에 데이터를 전달하는 것이 가능합니다. 이런 동적 작업을 수행하는 다음 2가지 이벤트 흐름에 대해 자바스크립트 코드를 작성할 수 있습니다. Pre-request Script : Request 헤더에 key를 추가시키거나, URL 매개변수에 문자열을 추가하고자 할 때 사용 (요청이 서버로 가기 전에 실행) Test Script : .test 함수를 사용하고, .response, .expect 객체 등에 접근이 가능함 (요청이 서버로 간 이후 응답이 반환된 후에 실행).
Postman에서 작성한 스크립트나 API 테스트를 Node.js 프로젝트에 반영하는 방법으로는 Newman 라이브러리를 사용하는 방법이 있습니다. Newman은 Postman의 CLI 버전으로 Postman Collection을 Node.js 모듈로 실행할 수 있습니다.</p>
<h3 id="references">References</h3>
<p>(1) <a href="https://www.youtube.com/watch?v=FiOTfaJaEHk">POSTMAN - Run Postman Collection Using JavaScript Project | As Node.js module | Newman ...</a>
(2) <a href="https://learning.postman.com/docs/writing-scripts/intro-to-scripts/">Scripting in Postman | Postman Learning Center</a>
(3) <a href="https://learn.microsoft.com/ko-kr/visualstudio/javascript/tutorial-nodejs-with-react-and-jsx?view=vs-2022">Node.js 및 React 앱 만들기 - Visual Studio (Windows)</a>
(4) <a href="https://www.youtube.com/watch?v=hVFZtO5SCVk">Create API with node JS and test with postman | Node Js Tutorial | Learning Points ...</a></p>
<h2 id="newman에-대한-설명과-사용-예제">Newman에 대한 설명과 사용 예제</h2>
<p>Newman은 Postman의 CLI 버전으로 Postman Collection을 Node.js 모듈로 실행할 수 있습니다. 이를 통해 Postman에서 작성한 스크립트나 API 테스트를 Node.js 프로젝트에서 실행할 수 있습니다. Newman을 사용하려면 먼저 Node.js가 설치되어 있어야 합니다. 그 다음 npm을 통해 Newman을 전역으로 설치합니다. 그러나 Newman 자체는 Axios 리퀘스트를 보내는 기능을 제공하지 않습니다. Express와 같은 환경을 구축하지 않고 Axios 리퀘스트를 보내려면 Node.js의 내장 모듈인 http 또는 https 모듈을 사용하거나 Axios와 같은 서드파티 라이브러리를 사용해야 합니다.</p>
<pre><code class="language-sh">npm install -g newman
</code></pre>
<p>Newman을 실행하는 가장 쉬운 방법은 Collection과 함께 실행하는 것입니다. 파일 시스템에서 Collection 파일을 실행할 수 있습니다. 또한 Collection을 공유하여 URL로 전달할 수도 있습니다.</p>
<pre><code class="language-sh">newman run mycollection.json
</code></pre>
<p>Collection이 환경 변수를 사용하는 경우, Postman에서 템플릿을 내보내고 -e 플래그와 함께 실행합니다.</p>
<pre><code class="language-sh">newman run https://www.postman.com/collections/cb208e7e64056f5294e5 -e dev_environment.json
</code></pre>
<p>Newman은 라이브러리로 구축되어 다양한 방식으로 확장 및 사용할 수 있습니다. Node.js 코드에서 다음과 같이 사용할 수 있습니다.</p>
<pre><code class="language-javascript">var newman = require(&quot;newman&quot;);
// `options` 객체를 전달하고 콜백을 기다리면서 newman.run 호출
newman.run(
  {
    collection: require(&quot;./sample-collection.json&quot;),
    reporters: &quot;cli&quot;,
  },
  function (err) {
    if (err) {
      throw err;
    }
    console.log(&quot;collection run complete!&quot;);
  },
);
</code></pre>
<h3 id="references-1">References</h3>
<p>(1) <a href="https://learning.postman.com/docs/collections/using-newman-cli/installing-running-newman/">Installing and running Newman | Postman Learning Center</a>
(2) <a href="https://www.npmjs.com/package/newman">newman - npm</a>
(3) <a href="https://libguides.newman.ac.uk/">Newman University Library: Library Homepage: Home</a></p>
<h2 id="swagger-ui와-postman">Swagger UI와 Postman</h2>
<p>Swagger UI는 OpenAPI (이전에는 Swagger) 사양을 기반으로 한 오픈 소스 프로젝트로, RESTful API를 설계, 빌드, 문서화 및 사용하는 데 도움이 되는 도구 모음입니다. Swagger UI를 사용하면 API를 시각적으로 탐색하고 상호 작용할 수 있으며, API 문서를 자동으로 생성할 수 있습니다.
Postman은 API 개발 환경으로, API를 개발하고 테스트하는 데 필요한 모든 기능을 제공합니다. Postman을 사용하면 API 요청을 보내고 응답을 확인할 수 있으며, 테스트 스크립트를 작성하고 자동화된 테스트를 실행할 수 있습니다. 또한 Postman은 API 문서화, 모니터링 및 공유 기능도 제공합니다.</p>
<p>두 도구 모두 API 개발에 유용하지만, Swagger UI는 API 문서화와 시각화에 중점을 두고 있으며, Postman은 API 개발 및 테스트에 중점을 두고 있습니다.
Swagger UI와 Postman은 모두 API 개발에 유용한 도구이지만, 각각의 목적과 기능이 다릅니다. 따라서 어떤 것이 더 나은지는 사용자의 필요에 따라 달라집니다.
Swagger UI는 API 문서화와 시각화에 중점을 두고 있습니다. 따라서 API를 설계하고 문서화하는 데 중점을 두는 경우 Swagger UI가 더 유용할 수 있습니다.
Postman은 API 개발 및 테스트에 중점을 두고 있습니다. 따라서 API를 개발하고 테스트하는 데 중점을 두는 경우 Postman이 더 유용할 수 있습니다.
또한 Swagger UI와 Postman은 함께 사용할 수도 있습니다. 예를 들어 Swagger UI를 사용하여 API를 설계하고 문서화하고, Postman을 사용하여 API를 테스트하는 것이 가능합니다.
Swagger UI와 Postman은 함께 사용하여 API 개발 프로세스를 강화할 수 있습니다.
예를 들어, Swagger UI를 사용하여 API를 설계하고 문서화할 수 있습니다. Swagger UI는 OpenAPI 사양을 기반으로 하며, 이 사양을 사용하여 API의 구조와 기능을 정의할 수 있습니다. 또한 Swagger UI는 이 사양을 기반으로 자동으로 API 문서를 생성할 수 있습니다.
이렇게 생성된 API 문서는 Postman에서 가져올 수 있습니다. Postman에서는 가져온 API 문서를 기반으로 API 요청을 보내고 응답을 확인할 수 있습니다. 또한 Postman에서는 테스트 스크립트를 작성하여 자동화된 테스트를 실행할 수 있습니다.
이렇게 Swagger UI와 Postman을 함께 사용하면 API 설계 및 문서화와 API 개발 및 테스트를 원활하게 진행할 수 있습니다.</p>
<h2 id="newman과-pm은-postman">Newman과 pm은 Postman</h2>
<p>Newman은 Postman의 커맨드 라인 도구로, Postman 컬렉션을 실행하는 데 사용됩니다. Newman을 사용하면 Postman 컬렉션을 지정된 환경에서 실행하고 테스트 결과를 생성할 수 있습니다. Newman은 지속적인 통합 및 지속적인 전달 (CI/CD) 파이프라인에 통합하여 API 테스트를 자동화하는 데 유용합니다.
pm은 Postman 스크립트에서 사용할 수 있는 내장 라이브러리입니다. pm을 사용하면 요청 및 응답 데이터에 액세스하고 조작할 수 있으며, 환경 및 전역 변수를 설정하고 관리할 수 있습니다. 또한 pm을 사용하여 테스트 스크립트를 작성하고 실행할 수 있습니다.
따라서 Newman과 pm은 서로 다른 목적으로 사용되는 도구입니다. Newman은 Postman 컬렉션을 실행하는 데 사용되며, pm은 Postman 스크립트를 작성하는 데 사용됩니다.</p>
<p>Newman을 사용하여 Postman 컬렉션을 &quot;실행&quot;한다는 것은 Postman 컬렉션에 포함된 모든 요청을 순차적으로 실행하고 테스트 스크립트를 실행하는 것을 의미합니다.
Postman 컬렉션은 여러 개의 API 요청과 테스트 스크립트로 구성됩니다. Newman을 사용하여 Postman 컬렉션을 실행하면 Newman은 컬렉션에 포함된 각 요청을 순차적으로 실행하고 응답을 확인합니다. 또한 Newman은 컬렉션에 포함된 테스트 스크립트를 실행하여 API가 예상대로 작동하는지 확인합니다.
Newman은 Postman의 Publish 기능과는 다릅니다. Publish 기능은 Postman 컬렉션의 문서화된 버전을 웹에서 공유하는 데 사용됩니다. 반면 Newman은 Postman 컬렉션을 실행하는 데 사용되며, API 엔드포인트를 간편하게 리스팅하거나 관리하는 것이 아니라 API 테스트를 자동화하는 데 목적이 있습니다.</p>
<p>Newman은 백엔드와 프론트엔드 모두에게 유용한 도구입니다. Newman은 Postman 컬렉션을 실행하는 커맨드 라인 도구로, API 테스트를 자동화하는 데 사용됩니다.
백엔드 개발자는 Newman을 사용하여 API가 예상대로 작동하는지 확인할 수 있습니다. Newman을 사용하면 API 요청을 보내고 응답을 확인하며, 테스트 스크립트를 실행하여 API가 예상대로 작동하는지 확인할 수 있습니다. 또한 Newman은 지속적인 통합 및 지속적인 전달 (CI/CD) 파이프라인에 통합하여 API 테스트를 자동화할 수 있습니다.
프론트엔드 개발자도 Newman을 사용하여 API가 예상대로 작동하는지 확인할 수 있습니다. 프론트엔드 개발자는 Newman을 사용하여 백엔드 API가 예상대로 작동하는지 확인하고, 프론트엔드 코드가 백엔드 API와 올바르게 상호 작용하는지 확인할 수 있습니다. Newman은 백엔드와 프론트엔드 모두에게 유용한 도구입니다.</p>
<h2 id="postman에서-api-문서-생성하는-방법">Postman에서 API 문서 생성하는 방법</h2>
<p>Postman은 OpenAPI 사양을 기반으로 한 API 문서를 생성하는 기능을 제공합니다. Postman 컬렉션에서 API 문서를 생성하려면 다음 단계를 따르십시오.</p>
<ol>
<li>Postman에서 컬렉션을 선택하고 &quot;...&quot; 버튼을 클릭한 다음 &quot;Export&quot;를 선택합니다.</li>
<li>&quot;Collection v2.1&quot;을 선택하고 &quot;Export&quot; 버튼을 클릭합니다.</li>
<li>파일을 저장하고 Postman API Builder로 이동합니다.</li>
<li>&quot;APIs&quot; 탭에서 &quot;+&quot; 버튼을 클릭하고 &quot;Import an API&quot;를 선택합니다.</li>
<li>&quot;Choose Files&quot; 버튼을 클릭하고 앞서 저장한 파일을 선택합니다.</li>
</ol>
<p>이제 Postman API Builder에서 OpenAPI 사양을 기반으로 한 API 문서를 생성할 수 있습니다. 생성된 API 문서는 Swagger와 같은 다른 도구에서도 사용할 수 있습니다.</p>
<h2 id="swagger와-open-api-30">Swagger와 Open API 3.0</h2>
<p>또한 일부 백엔드 프레임워크 (예: Node.js의 Express)에서는 Swagger와 같은 도구를 사용하여 코드 주석을 기반으로 자동으로 API 문서를 생성하는 기능도 제공합니다. 이러한 기능을 사용하면 코드 주석에 기반하여 자동으로 API 문서를 생성할 수 있습니다. OpenAPI 2.0 (이전에는 Swagger로 알려졌음)은 OpenAPI 3.0과 몇 가지 중요한 차이점이 있습니다. OpenAPI 3.0은 2017년에 출시되었으며, 몇 가지 주요한 변경 사항이 있습니다.</p>
<ul>
<li>문서 구조가 재구성되어 API 재사용성이 증가하도록 개발되었습니다.</li>
<li>JSON 스키마 지원이 확장되었습니다.</li>
<li>새로운 콜백 및 링크 기능이 추가되었습니다.</li>
<li>서버 변수 및 다중 서버 지원이 추가되었습니다.</li>
</ul>
<p>OpenAPI 3.1은 OpenAPI 3.0의 마이너 업데이트로, JSON 스키마와의 호환성을 개선하는 데 중점을 두고 있습니다. OpenAPI 3.1은 JSON 스키마의 최신 초안과 100% 호환됩니다.
OpenAPI 2.x에서 생성된 문서는 OpenAPI 3.x와 완벽하게 호환되지 않습니다. 그러나 OpenAPI 2.x 문서를 OpenAPI 3.x로 마이그레이션하는 것은 가능합니다. 이를 위해서는 일부 변경 사항을 수동으로 적용해야 할 수도 있습니다.</p>
<h3 id="references-2">References</h3>
<p>(1) <a href="https://gruuuuu.github.io/programming/openapi/">OpenAPI 란? (feat. Swagger) - 호롤리한 하루</a>
(2) <a href="https://blog.stoplight.io/difference-between-open-v2-v3-v31">What&#x27;s the Difference Between OpenAPI Types 2.0, 3.0, and 3.1? - Stoplight</a>
(3) <a href="https://www.openapis.org/blog/2021/02/16/migrating-from-openapi-3-0-to-3-1-0">Migrating from OpenAPI 3.0 to 3.1.0 - OpenAPI Initiative</a>
(4) <a href="https://www.openapis.org/blog/2021/02/18/openapi-specification-3-1-released">OpenAPI Specification 3.1.0 Released - OpenAPI Initiative</a></p>
<h2 id="open-api의-관리-주체">Open API의 관리 주체</h2>
<p>OpenAPI 사양은 OpenAPI Initiative (OAI)이라는 비영리 조직에 의해 관리됩니다. OAI는 API 개발 및 사용을 지원하는 목적으로 설립된 커뮤니티 주도 조직으로, 여러 기업과 개인이 참여하고 있습니다.
SwaggerHub는 SmartBear라는 회사에서 개발한 서비스입니다. SmartBear는 Swagger UI를 개발한 회사로, OpenAPI Initiative의 창립 회원 중 하나입니다. SwaggerHub는 OpenAPI 사양을 지원하는 API 디자인 및 문서화 플랫폼으로, Swagger UI와 같은 도구와 함께 사용할 수 있습니다.
OpenAPI 사양을 기반으로 코드를 생성하는 도구는 다양한 백엔드 언어와 프레임워크에서 제공됩니다. 이러한 도구를 사용하면 OpenAPI 문서에서 API 엔드포인트와 데이터 모델을 자동으로 생성할 수 있습니다.
예를 들어, Swagger Codegen은 OpenAPI 사양을 기반으로 서버 스텁 및 클라이언트 SDK를 생성하는 오픈 소스 도구입니다. Swagger Codegen은 다양한 언어와 프레임워크를 지원하며, Java, Python, Ruby, Node.js, Go 등의 언어로 코드를 생성할 수 있습니다.
또한 일부 백엔드 프레임워크 (예: Node.js의 Express)에서는 Swagger와 같은 도구를 사용하여 코드 주석을 기반으로 자동으로 API 문서를 생성하는 기능도 제공합니다. 이러한 기능을 사용하면 코드 주석에 기반하여 자동으로 API 문서를 생성할 수 있습니다.
이 외에도 OpenAPI Generator, NSwag 등의 도구가 있으며, 각각의 도구는 다양한 언어와 프레임워크를 지원합니다.</p>
<h2 id="raml">RAML</h2>
<p>OpenAPI와 유사한 목적을 가진 다른 API 설명 언어로는 RAML (RESTful API Modeling Language)과 API Blueprint가 있습니다.
RAML은 YAML을 기반으로 한 API 설명 언어로, RESTful API를 모델링하는 데 사용됩니다. RAML은 API의 리소스, 메서드, 매개 변수, 응답 등을 정의할 수 있으며, API 문서를 자동으로 생성할 수 있습니다.
API Blueprint는 Markdown을 기반으로 한 API 설명 언어로, RESTful API를 문서화하는 데 사용됩니다. API Blueprint는 API의 리소스, 메서드, 매개 변수, 응답 등을 정의할 수 있으며, API 문서를 자동으로 생성할 수 있습니다. 이러한 도구들은 OpenAPI와 유사한 목적을 가지고 있지만, 각각의 도구는 고유한 문법과 기능을 가지고 있습니다. 따라서 사용자의 필요에 따라 적절한 도구를 선택하여 사용할 수 있습니다.</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/wiki/blog/tags/api">API</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/wiki/blog/tags/open-api">Open API</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/wiki/blog/tags/postman">Postman</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/wiki/blog/tags/newman">Newman</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/wiki/blog/tags/swagger">Swagger</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="What AI Can do in Cybersecurity"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/the-effect-of-ai-on-cyber-security">인공지능이 사이버 보안에 끼치는 영향</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-03-28T00:00:00.000Z" itemprop="datePublished">2023년 3월 28일</time> · <!-- -->약 27분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="what-ai-can-do-in-cybersecurity">What AI Can do in Cybersecurity</h2>
<p>인공지능은 사이버 보안에서 점점 더 중요한 역할을 하고 있습니다. 그러나 해커들도 이점을 얻을 수 있습니다. 조직은 최신 AI 기반 도구를 활용하여 위협을 더 잘 감지하고 시스템과 데이터 자원을 보호할 수 있습니다. 그러나 사이버 범죄자들도 더 정교한 공격을 할 수 있는 기술을 사용할 수 있습니다.
AI 기반 보안 제품의 글로벌 시장은 2030년까지 1338억 달러에 이를 것으로 추정되며, 작년에는 149억 달러였습니다. 해커들도 이점을 얻고 있습니다: AI가 생성한 피싱 이메일은 수동으로 작성된 피싱 이메일보다 열리는 비율이 높습니다.
AI는 사이버 보안에서 많은 이점과 응용 분야를 제공합니다. 빠르게 진화하는 사이버 공격과 빠르게 증가하는 장치들이 오늘날 발생하고 있기 때문에, AI와 머신러닝은 사이버 범죄자들과 계속해서 발전하고, 위협 감지를 자동화하며, 전통적인 소프트웨어 기반 또는 수동 기술보다 효과적으로 응답할 수 있도록 도와줍니다.
AI는 새로운 위협 감지에 사용될 수 있습니다. 전통적인 소프트웨어 시스템은 매주 생성되는 새로운 악성 코드의 양에 따라 유지하기 어렵기 때문에 AI가 정말 도움이 될 수 있는 영역입니다. 복잡한 알고리즘을 사용하여 AI 시스템은 악성 코드 감지, 패턴 인식을 실행하고, 시스템에 들어가기 전에 맬웨어나 랜섬웨어 공격의 아주 작은 행위도 감지하는데 훈련되어 있습니다.
AI는 자연어 처리를 통해 우수한 예측 지능을 제공하며 스스로 사이버 위협에 대한 기사, 뉴스 및 연구를 스크랩하여 데이터를 정리합니다. 이를 통해 새로운 이상 현상, 사이버 공격 및 예방 전략에 대한 정보를 제공할 수 있습니다.
물론 AI의 발전과 함께 보안 분야에서도 계속해서 새로운 방법들이 연구되고 개발되고 있습니다. 현재까지의 연구 결과와 의견들은 AI가 사이버 보안에서 중요한 역할을 하고 있으며 앞으로도 계속해서 중요한 역할을 할 것으로 예상됩니다.</p>
<h3 id="references">References</h3>
<p>(1) <a href="https://www.cnbc.com/2022/09/13/ai-has-bigger-role-in-cybersecurity-but-hackers-may-benefit-the-most.html">AI has bigger role in cybersecurity, but hackers may benefit the most</a>
(2) <a href="https://www.computer.org/publications/tech-news/trends/the-use-of-artificial-intelligence-in-cybersecurity/">Artificial Intelligence in Cybersecurity | IEEE CS - IEEE Computer Society</a>
(3) <a href="https://www.computer.org/publications/tech-news/trends/the-impact-of-ai-on-cybersecurity/">The Impact of AI on Cybersecurity | IEEE Computer Society</a></p>
<p>AI는 사이버 보안에서 미래에도 중요한 역할을 할 것으로 예상됩니다. AI는 조직이 공격자들이 움직일 수 있는 것보다 빠르게 응답할 뿐만 아니라 이들의 움직임을 예측하고 미리 행동할 수 있도록 지원하는 힘의 배가 될 수 있습니다.
AI 기술과 도구는 초기 단계의 채택에 있습니다. 글로벌 시장은 2021년부터 2025년 사이에 190억 달러가 증가할 것으로 예상됩니다. AI의 적응적 학습 및 새로운 패턴 감지 능력은 검출, 격리 및 응답을 가속화하여 SOC 분석가의 부담을 줄이고 더 적극적으로 행동할 수 있도록 도와줍니다. 추가로, 조직이 결국 AI 주도의 사이버 범죄의 발전에 대비할 수 있도록 도와줍니다.
AI는 사이버 보안 분야에서 계속해서 중요한 역할을 할 것으로 예상되며, 새로운 위협에 대응하고 조직의 보안을 강화하는데 도움이 될 것입니다.</p>
<h3 id="references-1">References</h3>
<p>(1) <a href="https://www2.deloitte.com/us/en/insights/focus/tech-trends/2022/future-of-cybersecurity-and-ai.html">The future of cybersecurity and AI | Deloitte Insights</a>
(2) <a href="https://www.forbes.com/sites/forbesbusinesscouncil/2021/09/23/artificial-intelligence-the-future-of-cybersecurity/">Artificial Intelligence: The Future Of Cybersecurity? - Forbes</a>
(3) <a href="https://www.devdiscourse.com/article/technology/2382673-the-role-of-artificial-intelligence-in-cybersecurity">The Role of Artificial Intelligence in Cybersecurity</a>
(4) <a href="https://www.linkedin.com/pulse/understanding-role-ai-cyber-security-current-applications-future">Understanding the role of AI in Cyber Security: current applications and future trends</a></p>
<p>패스워드는 오랫동안 불안전하다고 알려져 왔습니다. 악의적인 행위자들이 패스워드 기반의 보안 프로토콜을 자주 우회하기 때문입니다. 그러나 보안 문제만이 패스워드 기반 인증의 유일한 단점은 아닙니다. 관리하는데 비용이 많이 들고 부담스럽습니다. 사용자들은 자주 패스워드를 잊어버리기 때문에 패스워드를 재설정해야 하며, 이로 인해 UX가 나빠집니다.
MFA (Multi-Factor Authentication)와 생체 인증과 같은 새로운 기술들이 이들을 대체할 수 있습니다. 예를 들어, Microsoft는 최근에 Microsoft 계정에서 패스워드를 완전히 제거할 수 있는 기능을 출시했습니다. Microsoft Authenticator 앱, Windows Hello, 보안 키 또는 전화 또는 이메일로 전송된 인증 코드를 사용하여 Microsoft Outlook, Microsoft OneDrive, Microsoft Family Safety 등 좋아하는 앱과 서비스에 로그인할 수 있습니다.
생체 인증은 MFA의 미래입니다. 패스워드를 훔치기는 쉽습니다. 그러나 MFA에 사용되는 전화기나 다른 장치를 훔치기는 쉽지 않습니다. 스마트폰 외에도 MFA에 사용되는 장치에는 보안 키가 포함됩니다. 보안 키는 사용자가 컴퓨터의 USB 포트에 연결할 수 있는 휴대용 장치입니다.
따라서 패스워드 기반의 인증 방식이 완벽하게 사라지고 대체될 가능성이 있습니다. MFA와 생체 인증과 같은 새로운 기술들이 이들을 대체할 수 있습니다.</p>
<h3 id="references-2">References</h3>
<p>(1) <a href="https://www.juniperresearch.com/blog/june-2022/biometric-authentication-passwordless-future">Biometric Authentication: The Key to a Passwordless Future? | Blog - Juniper Research</a>
(2) <a href="https://www.microsoft.com/en-us/security/blog/2021/09/15/the-passwordless-future-is-here-for-your-microsoft-account/">The passwordless future with Microsoft - Microsoft Security Blog</a>
(3) <a href="https://rublon.com/blog/biometrics-remedy-passwords/">MFA and Biometrics as a Remedy for the Weakness of Passwords</a>
(4) <a href="https://www.phonexia.com/blog/the-future-of-multi-factor-biometric-authentication/">The Future of Multi-Factor Biometric Authentication | PHONEXIA</a></p>
<p>MFA나 보안 키, 생체 인증과 같은 기술들은 관리나 개발 비용이 만만치 않습니다. 그러나 이러한 기술들은 사용자 경험을 향상시키기 위해 계속 발전하고 있습니다.
예를 들어, Microsoft는 최근에 패스워드 없이 Microsoft 계정에 로그인할 수 있는 기능을 출시했습니다. 이를 통해 사용자는 Microsoft Authenticator 앱, Windows Hello, 보안 키 또는 전화 또는 이메일로 전송된 인증 코드를 사용하여 Microsoft Outlook, Microsoft OneDrive, Microsoft Family Safety 등 좋아하는 앱과 서비스에 로그인할 수 있습니다.
또한, 일부 시스템에서는 관리자가 패스워드 없는 인증을 구현하고 사용자에게 단일 로그인 기능을 제공할 수 있습니다.
사용자 경험을 향상시키기 위한 새로운 아이디어들이 계속 제안되고 있습니다. 예를 들어, 사용자 인증 및 액세스 관리 솔루션의 Top 10 목록에서는 MFA 옵션, 적응형 인증, 유연성, 가시성 수준, 사용자 경험 및 가격 등의 주요 기능을 비교합니다.
따라서 MFA나 보안 키, 생체 인증과 같은 기술들은 사용자 경험을 향상시키기 위해 계속 발전하고 있습니다.</p>
<h3 id="references-3">References</h3>
<p>(1) <a href="https://www.outsystems.com/blog/posts/improve-user-experience/">6 Steps to Improve User Experience: Embracing Your End-Users - OutSystems</a>
(2) <a href="https://expertinsights.com/insights/top-10-user-authentication-and-access-management-solutions/">The Top 10 User Authentication And Access Management Solutions In 2023 - Expert Insights</a>
(3) <a href="https://parksassociates.com/blog/article/authentication-and-digital-media--improving-the-user-experience">Authentication and Digital Media: Improving the User Experience - Parks Associates</a></p>
<p>사용자 경험을 향상시키기 위한 새로운 아이디어들은 계속 제안되고 있습니다. 예를 들어, OutSystems의 블로그 게시물에서는 사용자 경험을 향상시키기 위한 6가지 팁을 제공합니다.</p>
<ol>
<li>사용자 중심의 제품 개발: 제품을 인간을 위해, 특히 그 제품을 사용할 인간을 위해 개발해야 합니다.</li>
<li>사용자와의 대화: 사용자와의 대화를 통해 그들이 원하는 것이 무엇인지 파악하고 그들의 기대를 충족시키세요.</li>
<li>사용자 테스트: 사용자 테스트를 통해 제품이 얼마나 직관적인지, 사용하기 쉬운지, 그리고 사용자가 제품을 사용하여 원하는 작업을 수행하는 데 얼마나 쉬운지 확인하세요.</li>
<li>디자인: 디자인은 제품의 맛을 더하는 양념이 아니라 레시피의 시작부터 필요한 밀가루입니다.</li>
<li>성능: 성능은 사용자 경험에 중요한 요소입니다. 제품이 빠르게 로드되고 반응성이 좋아야 합니다.</li>
<li>지속적인 개선: 사용자 경험은 한 번에 완성되는 것이 아닙니다. 지속적으로 개선해야 합니다.
(2) <a href="https://www.outsystems.com/blog/posts/improve-user-experience/">6 Steps to Improve User Experience: Embracing Your End-Users - OutSystems</a>
(3) <a href="https://parksassociates.com/blog/article/authentication-and-digital-media--improving-the-user-experience">Authentication and Digital Media: Improving the User Experience - Parks Associates</a>
인공지능과 코드 생성 기능이 빠르게 성장함에 따라 프로그래밍의 미래에 대한 다양한 의견이 있습니다. 일부 사람들은 인공지능이 프로그래밍을 더 쉽게 접근할 수 있는 범용적인 기초 능력으로 만들어 줄 것이라고 생각합니다. 예를 들어, GitHub Copilot와 같은 도구는 개발자들이 코드를 자동으로 생성하고 완성하는 데 도움을 줍니다.
다른 사람들은 인공지능이 프로그래밍을 더 어렵게 만들 수도 있다고 생각합니다. 예를 들어, 인공지능이 생성한 코드는 읽기 어렵고 이해하기 어려울 수 있습니다.
그러나 인공지능과 코드 생성 기능의 발전은 프로그래밍의 미래에 큰 영향을 미칠 것으로 예상됩니다. 예를 들어, GitHub Copilot X는 채팅 및 음성 인터페이스를 지원하고 pull request를 지원하며 문서에서 질문에 답변하고 OpenAI의 GPT-4를 채택하여 개발자 경험을 개인화하는 등의 기능을 제공합니다.
따라서 인공지능과 코드 생성 기능의 발전은 프로그래밍의 미래에 큰 영향을 미칠 것으로 예상됩니다.</li>
</ol>
<h3 id="references-4">References</h3>
<p>(1) <a href="https://github.blog/2023-03-22-github-copilot-x-the-ai-powered-developer-experience/">GitHub Copilot X: The AI-powered developer experience</a>
(2) <a href="https://www.forbes.com/sites/janakirammsv/2022/03/14/5-ai-tools-that-can-generate-code-to-help-programmers/">5 AI Tools That Can Generate Code To Help Programmers - Forbes</a>
(3) <a href="https://www.linkedin.com/pulse/what-future-coding-michael-spencer-">What is the Future of Coding?</a>
(4) <a href="https://d3.harvard.edu/platform-digit/submission/github-copilot-ai-based-code-generation-and-the-future-of-software-engineering/">GitHub Copilot: AI-based Code Generation and the Future of Software Engineering ...</a></p>
<p>GitHub Copilot의   런칭 시기에, 일부 사람들은 코드가 기계학습에 이용되는 것에 대해 우려를 표했습니다. GitHub Copilot는 클라우드 기반 서비스이며 GitHub Copilot 서버와 지속적인 통신이 필요합니다. 이러한 불투명한 아키텍처는 개별 키 입력의 텔레메트리 및 데이터 마이닝에 대한 우려를 촉발했습니다.
GitHub Copilot의 개발자들은 이러한 우려에 대해 다양한 조치를 취하고 있습니다. 예를 들어, GitHub Copilot의 FAQ에서는 &quot;GitHub Copilot는 코드 합성기이며 검색 엔진이 아닙니다&quot;라고 언급하고 있습니다. 그리고 &quot;제안된 코드의 대부분은 고유하게 생성되며 이전에 본 적이 없습니다&quot;라고 언급하고 있습니다.
따라서 GitHub Copilot와 같은 프로그래밍 AI들은 사용자의 개인 정보 보호와 관련된 우려에 대해 다양한 조치를 취하고 있습니다.</p>
<h3 id="references-5">References</h3>
<p>(1) <a href="https://en.wikipedia.org/wiki/GitHub_Copilot">GitHub Copilot - Wikipedia</a>
(2) <a href="https://www.theregister.com/2021/07/06/github_copilot_autocoder_caught_spilling/">GitHub Copilot auto-coder snags emerge, from seemingly spilled secrets to bad code ...</a>
(3) <a href="https://github.com/community/community/discussions/7163">Is Github Copilot safe privacy wise? · community · Discussion #7163</a></p>
<p>코드 제너레이터는 개발자들이 제공하는 코드의 포인트, 특히 가독성이나 함의성에 대해서 많은 힌트를 받고 있습니다. 그러나 이러한 현상에 불안감과 불쾌함을 가진 사람들에게 대안적으로 제안되는 엄격한 라이센스나 robots.txt와 같은 기계에 의해 수집되는 것에 대한 명시적 동의 및 거부 수단이 있습니다.
예를 들어, GitHub Copilot의 경우 사용자가 자신의 코드를 공유하고 싶지 않다면 해당 코드를 비공개 저장소에 저장하거나 robots.txt 파일을 사용하여 검색 엔진이 해당 코드를 수집하지 못하도록 할 수 있습니다. 또한, 일부 오픈 소스 라이센스는 코드가 재사용될 때 원작자의 동의가 필요하도록 규정하고 있습니다.
오픈 소스 라이센스는 크게 두 가지로 분류됩니다: 퍼미시브 라이센스와 카피레프트 라이센스.
퍼미시브 라이센스는 MIT 라이센스와 BSD 라이센스와 같은 라이센스로, 사용자가 소스 코드를 자유롭게 사용, 수정 및 재배포할 수 있도록 허용합니다. 이러한 라이센스는 일반적으로 소스 코드의 사용에 대한 제한이 적습니다.
카피레프트 라이센스는 GNU 일반 공개 라이센스(GPL)와 같은 라이센스로, 사용자가 소스 코드를 자유롭게 사용, 수정 및 재배포할 수 있도록 허용합니다. 그러나 이러한 라이센스는 수정된 소스 코드를 재배포할 때 원본 소스 코드와 동일한 라이센스 조건을 적용해야 한다는 조건을 부과합니다.
따라서 타인이 공유한 코드를 사용한 내 코드에서 해당 코드의 라이센스를 명시하는 것만으로 완벽한 명시적인 법적 방어조치가 이뤄질 수 있습니다. 하지만 이러한 방어조치가 완벽하게 작동하려면 사용자가 해당 코드의 라이센스 조건을 준수해야 합니다.</p>
<p>코드의 표절 검사는 연구 논문의 표절 검사와 유사한 방식으로 이루어질 수 있습니다. 코드에서 사용된 텍스트나 개념의 자체적 작성 비율은 중요한 요소가 될 수 있습니다.
예를 들어, 일부 오픈 소스 라이센스는 코드가 재사용될 때 원작자의 동의가 필요하도록 규정하고 있습니다. 따라서 타인이 작성한 코드를 사용할 때는 해당 코드의 라이센스 조건을 준수해야 합니다.
그러나 코드의 표절 검사는 연구 논문의 표절 검사와는 다른 점이 있습니다. 예를 들어, 코드는 일반적으로 기능적인 목적을 가지고 있으며, 이러한 기능을 구현하는 방법은 다양할 수 있습니다. 따라서 코드의 표절 검사는 연구 논문의 표절 검사와는 다른 방식으로 이루어질 수 있습니다.
결국 중요한 것은 코드가 어떻게 작성되었는지가 아니라 코드가 어떤 기능을 수행하는지와 해당 코드가 어떤 라이센스 조건을 준수하는지입니다.
POSA와 같은 서비스들은 개발자가 자신의 프로젝트에서 사용한 의존성 패키지들의 라이센스를 체크하고 분류하여 개발자에게 알려주는 일을 합니다. 이러한 서비스들은 개발자가 자신의 프로젝트에서 사용한 의존성 패키지들이 어떤 라이센스 조건을 가지고 있는지 파악하는 데 도움을 줍니다.</p>
<p>의존성 패키지들의 라이센스 조건을 파악하는 것은 중요합니다. 일부 라이센스는 코드가 재사용될 때 원작자의 동의가 필요하도록 규정하고 있습니다. 따라서 개발자가 자신의 프로젝트에서 사용한 의존성 패키지들이 어떤 라이센스 조건을 가지고 있는지 파악하는 것은 법적 문제를 예방하는 데 중요합니다.
따라서 POSA와 같은 서비스들이 제공하는 수치들은 개발자가 자신의 프로젝트에서 사용한 의존성 패키지들이 어떤 라이센스 조건을 가지고 있는지 파악하는 데 중요한 의미를 가집니다.
POSA와 같은 서비스들이 제공하는 수치나 추상적인 엄밀함의 정도는 개발자의 결정을 제한하는 것이 아니라 개발자가 자신의 프로젝트에서 사용한 의존성 패키지들이 어떤 라이센스 조건을 가지고 있는지 파악하는 데 도움을 줍니다.
일부 라이센스는 코드가 재사용될 때 원작자의 동의가 필요하도록 규정하고 있습니다. 따라서 개발자가 타인의 코드에서 일부를 인용하거나 응용한 프로젝트를 개발할 때는 해당 코드의 라이센스 조건을 준수해야 합니다.
POSA와 같은 서비스들은 개발자가 자신의 프로젝트에서 사용한 의존성 패키지들이 어떤 라이센스 조건을 가지고 있는지 파악하는 데 도움을 줍니다. 이러한 정보는 개발자가 자신의 프로젝트에서 사용한 의존성 패키지들이 어떤 라이센스 조건을 가지고 있는지 파악하고 이에 따라 적절한 결정을 내리는 데 중요합니다.
따라서 POSA와 같은 서비스들이 제공하는 수치나 추상적인 엄밀함의 정도는 개발자의 결정을 제한하는 것이 아니라 개발자가 자신의 프로젝트에서 사용한 의존성 패키지들이 어떤 라이센스 조건을 가지고 있는지 파악하는 데 도움을 줍니다.</p>
<p>프로그래밍 코드에서 일반 연구자들이 사용하는 사이테이션과 멘션과 같은 기술적 방법으로 내가 만든 코드가 이후에 재사용되거나 설치되는 등의 백링크 추적은 구조 상 구현하기 어려울 수 있습니다.
코드는 일반적으로 기능적인 목적을 가지고 있으며, 이러한 기능을 구현하는 방법은 다양할 수 있습니다. 따라서 코드의 재사용 여부를 추적하는 것은 어려울 수 있습니다.
그러나 일부 오픈 소스 라이센스는 코드가 재사용될 때 원작자의 동의가 필요하도록 규정하고 있습니다. 따라서 개발자가 타인의 코드를 사용할 때는 해당 코드의 라이센스 조건을 준수해야 합니다.
결국 중요한 것은 코드가 어떻게 작성되었는지가 아니라 코드가 어떤 기능을 수행하는지와 해당 코드가 어떤 라이센스 조건을 준수하는지입니다.</p>
<p>코드의 재사용 여부를 추적하는 것이 어려운 이유는 다음과 같습니다:</p>
<ol>
<li>코드의 복잡성: 코드는 일반적으로 매우 복잡하며 다양한 구성 요소와 상호 작용합니다. 따라서 코드의 재사용 여부를 추적하는 것은 어려울 수 있습니다.</li>
<li>코드의 변경 가능성: 코드는 지속적으로 변경될 수 있습니다. 따라서 코드의 재사용 여부를 추적하는 것은 어려울 수 있습니다.</li>
<li>코드의 분산: 코드는 일반적으로 여러 위치에 분산되어 있습니다. 따라서 코드의 재사용 여부를 추적하는 것은 어려울 수 있습니다.</li>
<li>기술적 제약: 현재 기술 수준에서는 코드의 재사용 여부를 완벽하게 추적하는 것이 어려울 수 있습니다.</li>
</ol>
<p>코드의 재사용 여부를 추적하는 것이 중요한 이유는 다음과 같습니다:</p>
<ol>
<li>법적 문제 예방: 일부 라이센스는 코드가 재사용될 때 원작자의 동의가 필요하도록 규정하고 있습니다. 따라서 코드의 재사용 여부를 추적하는 것은 법적 문제를 예방하는 데 중요합니다.</li>
<li>코드 품질 향상: 코드의 재사용 여부를 추적하는 것은 코드 품질을 향상시키는 데 도움이 될 수 있습니다. 예를 들어, 재사용 가능한 코드는 일반적으로 높은 품질의 코드입니다.</li>
<li>개발 비용 절감: 코드의 재사용 여부를 추적하는 것은 개발 비용을 절감하는 데 도움이 될 수 있습니다. 예를 들어, 재사용 가능한 코드를 사용하면 개발 시간을 단축하고 개발 비용을 절감할 수 있습니다.</li>
</ol></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="매우 흥미로운 제안인 레코드 &amp; 튜플이 TC39\\에서 2단계에 도달했습니다."><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/records-tuples-for-react-proposal">Records &amp; Tuples for React Proposal</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-03-26T00:00:00.000Z" itemprop="datePublished">2023년 3월 26일</time> · <!-- -->약 32분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>**매우 흥미로운 제안인 <a href="https://github.com/tc39/proposal-record-tuple">레코드 &amp; 튜플</a>이 **TC39**에서 <a href="https://twitter.com/robpalmer2/status/1286040041089904640">2단계</a>에 도달했습니다.</p>
<p>레코드와 튜플은 <strong>불변 데이터 구조</strong>를 자바스크립트로 가져옵니다.</p>
<p>하지만 <strong>React</strong>에 <strong>매우</strong> 흥미로운 <strong>동등성(equality)</strong> 속성을 간과해서는 안 됩니다.</p>
<p>React 버그의 많은 범주는 <strong>불안정한 객체 아이덴티티</strong>와 관련이 있습니다:</p>
<ul>
<li><strong>성능</strong>: 피할 수 있는 재렌더링</li>
<li><strong>동작</strong>: 쓸모없는 이펙트 재실행, 무한 루프</li>
<li><strong>API 표면</strong>: 안정적인 객체 아이덴티티가 중요한 경우 표현할 수 없음</li>
</ul>
<p>레코드와 튜플의 기초를 설명하고, 이를 통해 어떻게 현실의 React 문제를 해결할 수 있는지 설명하겠습니다.</p>
<h2 id="레코드와-튜플-101">레코드와 튜플 101</h2>
<p>이 글은 React의 레코드와 튜플에 관한 글입니다. 여기서는 기본적인 내용만 다루겠습니다.</p>
<p>레코드와 튜플은 <strong>#</strong> 접두사가 붙은 일반적인 객체와 배열처럼 보입니다.</p>
<pre><code class="language-tsx">const record = #{a: 1, b: 2};
record.a;
// 1

const updatedRecord = #{...record, b: 3};
// #{a: 1, b: 3};
const tuple = #[1, 5, 2, 3, 4];
tuple[1];
// 5

const filteredTuple = tuple.filter(num =&gt; num &gt; 2)
// #[5, 3, 4];
</code></pre>
<p>They are <strong>deeply immutable</strong> by default.</p>
<pre><code class="language-tsx">const record = #{a: 1, b: 2};
record.b = 3;
// throws TypeError
</code></pre>
<p>이들은 **&quot;복합 프리미티브&quot;**로 볼 수 있으며 값으로 비교할 수 있습니다.</p>
<p><strong>매우 중요</strong>: 두 개의 완전히 동일한 레코드는 <code>===</code>와 함 께 <code>true</code>를 <strong>항상</strong> 반환합니다.</p>
<pre><code class="language-ts">const record = JSON.parseImmutable(&quot;{a: 1, b: [2, 3]}&quot;);
// #{a: 1, b: #[2, 3]}
JSON.stringify(record);
// &#x27;{a: 1, b: [2, 3]}&#x27;
</code></pre>
<p>어떻게든 레코드의 아이덴티티는 일반 JS 프리미티브와 마찬가지로 실제 값이라고 생각할 수 있습니다.</p>
<p>이 프로퍼티는 앞으로 살펴볼 것처럼 React에 <strong>심각한 영향</strong>을 미칩니다.</p>
<p>JSON과 상호 운용이 가능합니다:</p>
<pre><code class="language-ts">const record1 = #{
  a: {
    regular: &#x27;object&#x27;
  },
};
// throws TypeError, because a record can&#x27;t contain an object

const record2 = #{
  b: new Date(),
};
// throws TypeError, because a record can&#x27;t contain a Date

const record3 = #{
  c: new MyClass(),
};
// throws TypeError, because a record can&#x27;t contain a class

const record4 = #{
  d: function () {
    alert(&#x27;forbidden&#x27;);
  },
};
// throws TypeError, because a record can&#x27;t contain a function
</code></pre>
<p>다른 레코드와 튜플 또는 프리미티브 값만 포함할 수 있습니다.</p>
<p><strong>참고</strong>: 심볼을 WeakMap 키(<a href="https://github.com/tc39/proposal-symbols-as-weakmap-keys">별도 제안</a>)로 사용하고 레코드의 심볼을 <a href="https://github.com/tc39/proposal-record-tuple#could-i-box-a-pointer-to-an-object-and-put-that-in-a-record-or-tuple">참조</a>하여 레코드에 이러한 변경 가능한 값을 추가할 수 있습니다.</p>
<p>더 알고 싶으신가요? <a href="https://github.com/tc39/proposal-record-tuple">제안</a>을 직접 읽어보시거나 Axel Rauschmayer의 <a href="https://2ality.com/2020/05/records-tuples-first-look.html">기사</a>를 읽어보세요.</p>
<h2 id="react를-위한-레코드와-튜플">React를 위한 레코드와 튜플</h2>
<p>React 개발자들은 이제 **불변성(immutability)**에 익숙해졌습니다.</p>
<p>어떤 상태를   불변의 방식으로 업데이트할 때마다 <strong>새로운 객체 아이덴티티</strong>를 생성합니다.</p>
<p>안타깝게도 이 불변성 모델은 React 애플리케이션에 완전히 새로운 종류의 버그와 성능 문제를 일으켰습니다. 때로는 컴포넌트가 올바르고 성능 좋은 방식으로 작동하지만, 이는 <strong>소품이 시간이 지나도 최대한 아이덴티티를 보존한다는 가정 하에서만</strong> 가능합니다.</p>
<p>저는 레코드와 튜플을 객체 아이덴티티를 보다 &quot;안정적으로&quot;** 만드는 편리한 방법으로 생각하고 싶습니다.</p>
<p>실제 사용 사례를 통해 이 제안이 React 코드에 어떤 영향을 미치는지 살펴봅시다.</p>
<p><strong>참고</strong>: React를 실행할 수 있는 <a href="https://rickbutton.github.io/record-tuple-playground">레코드 &amp; 튜플 플레이그라운드</a>가 있습니다.</p>
<h2 id="불변성">불변성</h2>
<p>불변성을 적용하는 것은 재귀적인 <code>Object.freeze()</code> 호출로 달성할 수 있습니다.</p>
<p>하지만 실제로는 업데이트할 때마다 <code>Object.freeze()</code>를 적용하는 것이 편리하지 않기 때문에 불변성 모델을 너무 엄격하게 적용하지 않고 사용하는 경우가 많습니다. 하지만 상태를 직접 변경하는 것은 초보 React 개발자들이 흔히 저지르는 실수입니다.</p>
<p>레코드 및 튜플 제안은 <strong>불변성을 강제</strong>하고 일반적인 상태 변경 실수를 방지합니다:</p>
<pre><code class="language-tsx">const Hello = ({ profile }) =&gt; {
  // prop mutation: throws TypeError
  profile.name = &#x27;Sebastien updated&#x27;;
  return &lt;p&gt;Hello {profile.name}&lt;/p&gt;;
};
function App() {
  const [profile, setProfile] = React.useState(#{
    name: &#x27;Sebastien&#x27;,
  });
  // state mutation: throws TypeError
  profile.name = &#x27;Sebastien updated&#x27;;
  return &lt;Hello profile={profile} /&gt;;
}
</code></pre>
<h2 id="불변-업데이트">불변 업데이트</h2>
<p>React에서 불변 상태 업데이트를 수행하는 방법에는 <a href="https://dev.to/sebastienlorber/insight-3-use-immerjs-over-lodash-set-immutablejs-or-plain-js-36bl">여러 가지</a>가 있습니다: vanilla JS, Lodash set, ImmerJS, ImmutableJS...</p>
<p>레코드와 튜플은 ES6 객체와 배열에서 사용하는 것과 동일한 종류의 불변 업데이트 패턴을 지원합니다:</p>
<pre><code class="language-tsx">const initialState = #{
  user: #{
    firstName: &quot;Sebastien&quot;,
    lastName: &quot;Lorber&quot;
  }
  company: #{
    name: &quot;Lambda Scale&quot;,
  }
};
const updatedState = {
  ...initialState,
  company: {
    ...initialState.company,
    name: &#x27;Freelance&#x27;,
  },
};
</code></pre>
<p>지금까지는 중첩된 속성을 처리하는 단순성과 일반 JS 코드와의 상호 운용성 덕분에 <a href="https://github.com/immerjs/immer">ImmerJS</a>가 불변성 업데이트 전쟁에서 승리했습니다.</p>
<p>Immer가 레코드 및 튜플과 어떻게 작동할 수 있는지는 아직 명확하지 않지만, 제안서 작성자들이 연구하고 있는 부분입니다.</p>
<p>별개로 Michael Weststrate는 <a href="https://github.com/tc39/proposal-deep-path-properties-for-record">관련된 제안</a>이 [레코드 및 튜플에 ImmerJS를 **불필요하게 만들 수 있다]고 <a href="https://twitter.com/mweststrate/status/1263482177934819329">강조</a>했습니다:</p>
<pre><code class="language-tsx">const initialState = #{
  counters: #[
    #{ name: &quot;Counter 1&quot;, value: 1 },
    #{ name: &quot;Counter 2&quot;, value: 0 },
    #{ name: &quot;Counter 3&quot;, value: 123 },
  ],
  metadata: #{
    lastUpdate: 1584382969000,
  },
};
// Vanilla JS updates
// using deep-path-properties-for-record proposal
const updatedState = #{
  ...initialState,
  counters[0].value: 2,
  counters[1].value: 1,
  metadata.lastUpdate: 1584383011300,
};
</code></pre>
<h2 id="usememo">useMemo</h2>
<p><code>useMemo()</code>는 비용이 많이 드는 계산을 메모하는 것 외에도 <strong>트리의 더 깊은 곳에서 쓸모없는 계산, 재렌더링 또는 이펙트 실행을 트리거</strong>할 수 있는 <strong>새 객체 ID 생성을 피하는 데에도 유용합니다</strong>.</p>
<p>여러 필터가 있는 UI가 있고 백엔드에서 일부 데이터를 가져오고자 하는 사용 사례를 고려해 보겠습니다.</p>
<p>기존 React 코드베이스에는 다음과 같은 코드가 포함될 수 있습니다:</p>
<pre><code class="language-tsx">// Don&#x27;t change apiFilters object identity,
// unless one of the filter changes
// Not doing this is likely to trigger a new fetch
// on each render
const apiFilters = useMemo(
  () =&gt; ({ userFilter, companyFilter }),
  [userFilter, companyFilter],
);
const { apiData, loading } = useApiData(apiFilters);
</code></pre>
<p>레코드 및 튜플을 사용하면 간단히 이렇게 됩니다:</p>
<pre><code class="language-tsx">const {apiData,loading} = useApiData(#{ userFilter, companyFilter })
</code></pre>
<h3 id="useeffect">useEffect</h3>
<p>API 필터 사용 사례를 계속 살펴보겠습니다:</p>
<pre><code class="language-tsx">const apiFilters = { userFilter, companyFilter };
useEffect(() =&gt; {
  fetchApiData(apiFilters).then(setApiDataInState);
}, [apiFilters]);
</code></pre>
<p>안타깝게도 이 컴포넌트가 리렌더링할 때마다 <code>apiFilters</code> 객체의 ID가 변경되기 때문에 가져오기 효과가 <strong>재실행</strong>됩니다. <code>setApiDataInState</code>는 리렌더링을 트리거하고, 결국 무한한 불러오기/렌더링 루프가 발생하게 됩니다.</p>
<p>이 실수는 React 개발자들 사이에서 매우 흔한 실수이며, <a href="https://www.google.com/search?q=useEffect+%2B+%22infinite+loop%22">useEffect 무한 루프</a>에 대한 구글 검색 결과만 수천 개가 넘습니다.</p>
<p><a href="https://twitter.com/kentcdodds">Kent C Dodds</a>는 개발 과정에서 무 한 루프를 끊는 <a href="https://github.com/kentcdodds/stop-runaway-react-effects">도구</a>를 만들기도 했습니다.</p>
<p>매우 일반적인 해결책: 이펙트의 콜백에 직접 <code>apiFilters</code>를 생성합니다:</p>
<pre><code class="language-tsx">useEffect(() =&gt; {
  const apiFilters = { userFilter, companyFilter };
  fetchApiData(apiFilters).then(setApiDataInState);
}, [userFilter, companyFilter]);
</code></pre>
<p><a href="https://twitter.com/acutmore/status/1256533631914426369">트위터</a>에서 찾을 수 있는 또 다른 창의적인 솔루션(성능은 좋지 않음)입니다:</p>
<pre><code class="language-tsx">const apiFiltersString = JSON.stringify({
  userFilter,
  companyFilter,
});
useEffect(() =&gt; {
  fetchApiData(JSON.parse(apiFiltersString)).then(setApiDataInState);
}, [apiFiltersString]);
</code></pre>
<p>그 중 가장 제 마음에 드는 기능입니다:</p>
<pre><code class="language-tsx">// We already saw this somewhere, right? :p
const apiFilters = useMemo(
  () =&gt; ({ userFilter, companyFilter }),
  [userFilter, companyFilter],
);
useEffect(() =&gt; {
  fetchApiData(apiFilters).then(setApiDataInState);
}, [apiFilters]);
</code></pre>
<p>이 문제를 해결하는 멋진 방법이 많이 있지만 필터 수가 증가함에 따라 모두 <strong>귀찮아지는</strong> 경향이 있습니다.</p>
<p><a href="https://github.com/kentcdodds/use-deep-compare-effect">use-deep-compare-effect</a>(<a href="https://twitter.com/kentcdodds">Kent C Dodds</a>)가 덜 성가시겠지만, 리렌더링할 때마다 딥 이퀄리티를 실행하는 데는 지불하고 싶지 않은 비용이 듭니다.</p>
<p>레코드 및 튜플보다 훨씬 <strong>장황하고 관용적이지 않습니다</strong>:</p>
<pre><code class="language-tsx">const apiFilters = #{ userFilter, companyFilter };
useEffect(() =&gt; {
  fetchApiData(apiFilters).then(setApiDataInState);
}, [apiFilters]);
</code></pre>
<h3 id="props와-reactmemo">Props와 React.memo</h3>
<p>프로포즈에서 객  체 아이덴티티를 보존하는 것은 React 퍼포먼스에도 매우 유용합니다.</p>
<p>또 다른 매우 흔한 성능 실수는 렌더링에서 새로운 객체 아이덴티티를 생성하는 것입니다.</p>
<pre><code class="language-tsx">const Parent = () =&gt; {
  useRerenderEverySeconds();
  return (
    &lt;ExpensiveChild
      // someData props object is created &quot;on the fly&quot;
      someData={{ attr1: &quot;abc&quot;, attr2: &quot;def&quot; }}
    /&gt;
  );
};
const ExpensiveChild = React.memo(({ someData }) =&gt; {
  return &lt;div&gt;{expensiveRender(someData)}&lt;/div&gt;;
});
</code></pre>
<p>대부분의 경우 이것은 문제가 되지 않습니다. React는 충분히 빠르니까요.</p>
<p>하지만 때때로 앱을 최적화하려는 경우, 이 새로운 객체 생성은 <code>React.memo()</code>를 쓸모없게 만듭니다. 최악의 경우, 실제로 애플리케이션을 조금 느리게 만듭니다(항상 거짓을 반환하는 추가적인 얕은 동등성 검사를 실행해야 하기 때문입니다).</p>
<p>클라이언트 코드베이스에서 자주 볼 수 있는 또 다른 패턴입니다:</p>
<pre><code class="language-tsx">const currentUser = { name: &quot;Sebastien&quot; };
const currentCompany = { name: &quot;Lambda Scale&quot; };
const AppProvider = () =&gt; {
  useRerenderEverySeconds();
  return (
    &lt;MyAppContext.Provider
      // the value prop object is created &quot;on the fly&quot;
      value={{ currentUser, currentCompany }}
    /&gt;
  );
};
</code></pre>
<p><code>currentUser</code> 또는 <code>currentCompany</code>가 <strong>업데이트되지 않는다는</strong> 사실에도 불구하고, 이 공급자가 리렌더링할 때마다 컨텍스트 값이 변경되어 모든 컨텍스트 구독자의 리렌더링을 트리거합니다.</p>
<p>이러한 모든 문제는 메모화를 통해 해결할 수 있습니다:</p>
<pre><code class="language-tsx">const someData = useMemo(() =&gt; ({ attr1: &quot;abc&quot;, attr2: &quot;def&quot; }), []);
&lt;ExpensiveChild someData={someData} /&gt;;
</code></pre>
<pre><code class="language-tsx">const contextValue = useMemo(
  () =&gt; ({ currentUser, currentCompany }),
  [currentUser, currentCompany],
);
&lt;MyAppContext.Provider value={contextValue} /&gt;;
</code></pre>
<p>레코드 및 튜플을 사용하면 <strong>성능이 뛰어난 코드를 작성하는 것이 관용적입니다</strong>:</p>
<pre><code class="language-tsx">&lt;ExpensiveChild someData={#{ attr1: &#x27;abc&#x27;, attr2: &#x27;def&#x27; }} /&gt;;
</code></pre>
<pre><code class="language-tsx">&lt;MyAppContext.Provider value={#{ currentUser, currentCompany }} /&gt;;
</code></pre>
<h2 id="불러오기-및-다시-불러오기">불러오기 및 다시 불러오기</h2>
<p>React에서 데이터를 불러오는 방법은 여러 가지가 있습니다: <code>useEffect</code>, HOC, Render props, Redux, SWR, React-Query, Apollo, Relay, Urql, ...</p>
<p>대부분의 경우, 우리는 요청을 백엔드에 전달하고 JSON 데이터를 반환받습니다.</p>
<p>이 섹션을 설명하기 위해 제가 만든 아주 간단한 불러오기 라이브러리인 <a href="https://github.com/slorber/react-async-hook">react-async-hook</a>을 사용하겠지만, 다른 라이브러리에도 적용될 수 있습니다.</p>
<p>API 데이터를 가져오는 고전적인 비동기 함수를 고려해 봅시다:</p>
<pre><code class="language-tsx">const fetchUserAndCompany = async () =&gt; {
  const response = await fetch(`https://myBackend.com/userAndCompany`);
  return response.json();
};
</code></pre>
<p>이 앱은 데이터를 가져오고, 시간이 지나도 이 데이터가 오래된 데이터가 아닌 &#x27;최신&#x27; 상태로 유지되도록 합니다:</p>
<pre><code class="language-tsx">const App = ({ id }) =&gt; {
  const { result, refetch } = useAsync(fetchUserAndCompany, []);
  // We try very hard to not display stale data to the user!
  useInterval(refetch, 10000);
  useOnReconnect(refetch);
  useOnNavigate(refetch);
  if (!result) {
    return null;
  }
  return (
    &lt;div&gt;
      &lt;User user={result.user} /&gt;
      &lt;Company company={result.company} /&gt;
    &lt;/div&gt;
  );
};
const User = React.memo(({ user }) =&gt; {
  return &lt;div&gt;{user.name}&lt;/div&gt;;
});
const Company = React.memo(({ company }) =&gt; {
  return &lt;div&gt;{company.name}&lt;/div&gt;;
});
</code></pre>
<p>문제: 성능상의 이유로 <code>React.memo</code>를 사용했지만, 다시 불러올 때마다 가져온 데이터가 이전과 <strong>동일</strong>(완전히 동일한 페이로드)임에도 불구하고 <strong>새로운 아이덴티티</strong>를 가진 새로운 JS 객체가 생성되고 <strong>모든 것이 리렌더링</strong>됩니다.</p>
<p>이 시나리오를 상상해 봅시다:</p>
<ul>
<li>&quot;Stale-While-Revalidate&quot; 패턴(캐시된/부실 데이터를 먼저 표시한 다음 백그라운드에서 데이터를 새로 고침)을 사용합니다.</li>
<li>페이지가 복잡하고 렌더링 집약적이며 많은 백엔드 데이터가 표시됩니다.</li>
</ul>
<p>캐시된 데이터로 인해 처음 렌더링하는 데 이미 많은 비용이 드는 페이지로 이동합니다. 1초 후 새로 고쳐진 데이터가 다시 표시됩니다. 캐시된 데이터와 거의 동일함에도 불구하고 모든 것이 리렌더링됩니다. <a href="https://reactjs.org/docs/concurrent-mode-intro.html">동시성 모드</a>와 타임 슬라이싱이 없으면 일부 사용자는 수백 밀리초 동안 <strong>UI가 멈추는</strong> 현상을 경험할 수도 있습니다.</p>
<p>이제 가져오기 함수를 레코드를 반환하도록 변환해 보겠습니다:</p>
<pre><code class="language-tsx">const fetchUserAndCompany = async () =&gt; {
  const response = await fetch(`https://myBackend.com/userAndCompany`);
  return JSON.parseImmutable(await response.text());
};
</code></pre>
<p>우연히도 JSON은 레코드 및 튜플과 호환되며, <a href="https://github.com/tc39/proposal-record-tuple#jsonparseimmutable">JSON.parseImmutable</a>을 사용하여 모든 백엔드 응답을 레코드로 변환할 수 있어야 합니다.</p>
<p><strong>참고</strong>: 제안 작성자 중 한 명인 <a href="https://twitter.com/r_ricard">Robin Ricard</a>는 새로운 <code>response.immutableJson()</code> 함수를 추진하고 있습니다.</p>
<p>레코드 및 튜플을 사용하면 백엔드에서 동일한 데이터를 반환하면 <strong>아무것도 리렌더링하지</strong> 않습니다!</p>
<p>또한 응답의 한 부분만 변경된 경우에도 응답의 다른 중첩 객체는 여전히 <strong>아이덴티티를 유지</strong>합니다. 즉, <code>user.name</code>만 변경된 경우 <code>User</code> 컴포넌트는 리렌더링되지만 <code>Company</code> 컴포넌트는 렌더링되지 않습니다!</p>
<p>&quot;Stale-While-Revalidate&quot;와 같은 패턴이 점점 더 대중화되고 있고 SWR, React-Query, Apollo, Relay와 같은 라이브러리에서 기본으로 제공된다는 점을 고려할 때 이 모든 것이 성능에 미치는 영향을 상상해 보겠습니다.</p>
<h2 id="쿼리-문자열-읽기">쿼리 문자열 읽기</h2>
<p>검색 UI에서는 쿼리 문자열에 필터의 상태를 <strong>보존</strong>하는 것이 좋습니다. 그러면 사용자는 링크를 복사/붙여넣거나 페이지를 새로고침하거나 북마크할 수 있습니다.</p>
<p>필터가 1~2개라면 간단하지만, 검색 UI가 복잡해지면(필터가 10개 이상, AND/OR 로직으로 쿼리를 작성하는 기능 등) 쿼리 문자열을 관리하기 위해 좋은 추상화를 사용하는 것이 좋습니다.</p>
<p>저는 개인적으로 <a href="https://github.com/ljharb/qs">qs</a>를 좋아합니다. 중첩 객체를 제대로 처리하는 몇 안 되는 라이브러리 중 하나이기 때문입니다.</p>
<pre><code class="language-tsx">const queryStringObject = {
  filters: {
    userName: &quot;Sebastien&quot;,
  },
  displayMode: &quot;list&quot;,
};
const queryString = qs.stringify(queryStringObject);
const queryStringObject2 = qs.parse(queryString);
assert.deepEqual(queryStringObject, queryStringObject2);
assert(queryStringObject !== queryStringObject2);
</code></pre>
<p><code>queryStringObject</code>와 <code>queryStringObject2</code>는 매우 동일하지만, <code>qs.parse</code>가 새 객체를 생성하기 때문에 더 이상 동일하지 않습니다.</p>
<p>쿼리 문자열 구문 분석을 후크에 통합하고 <code>useMemo()</code> 또는 <a href="https://github.com/discord/use-memo-value">use-memo-value</a>와 같은 라이브러리를 사용하여 쿼리 문자열 객체를 &quot;안정화&quot;할 수 있습니다.</p>
<pre><code class="language-tsx">const useQueryStringObject = () =&gt; {
  // Provided by your routing library, like React-Router
  const { search } = useLocation();
  return useMemo(() =&gt; qs.parse(search), [search]);
};
</code></pre>
<p>이제 트리의 더 깊은 곳을 상상해 보세요:</p>
<pre><code class="language-tsx">const { filters } = useQueryStringObject();
useEffect(() =&gt; {
  fetchUsers(filters).then(setUsers);
}, [filters]);
</code></pre>
<p>이것은 약간 지저분하지만 같은 문제가 반복해서 발생합니다.</p>
<p><code>queryStringObject</code> 아이덴티티를 보존하기 위해 <code>useMemo()</code>를 사용했음에도 불구하고 원치 않는 <code>fetchUsers</code> 호출이 발생하게 됩니다.</p>
<p>사용자가 (다시 불러오기를 트리거하지 않고 렌더링 로직만 변경해야 하는) <code>displayMode</code>를 업데이트하면 쿼리 문자열이 변경되어 쿼리 문자열이 다시 구문 분석되고 <code>filter</code> 속성에 대한 새로운 객체 ID가 생성되어 원치 않는 <code>useEffect</code> 실행으로 이어집니다.</p>
<p>다시 말하지만, 레코드 및 튜플은 이러한 일이 발생하지 않도록 방지합니다.</p>
<pre><code class="language-tsx">// This is a non-performant, but working solution.
// Lib authors should provide a method such as qs.parseRecord(search)
const parseQueryStringAsRecord = (search) =&gt; {
  const queryStringObject = qs.parse(search);
  // Note: the Record(obj) conversion function is not recursive
  // There&#x27;s a recursive conversion method here:
  // https://tc39.es/proposal-record-tuple/cookbook/index.html
  return JSON.parseImmutable(JSON.stringify(queryStringObject));
};
const useQueryStringRecord = () =&gt; {
  const { search } = useLocation();
  return useMemo(() =&gt; parseQueryStringAsRecord(search), [search]);
};
</code></pre>
<p>이제 사용자가 <code>displayMode</code>를 업데이트하더라도 <code>filters</code> 객체는 그 아이덴티티를 유지하며 쓸모없는 리페치를 트리거하지 않습니다.</p>
<p><strong>참고</strong>: 레코드 및 튜플 제안이 받아들여지면 <code>qs</code>와 같은 라이브러리에서 <code>qs.parseRecord(search)</code> 메서드를 제공할 가능성이 높습니다.</p>
<h3 id="매우-동등한-js-변환">매우 동등한 JS 변환</h3>
<p>컴포넌트에서 다음과 같은 JS 변환을 상상해 보세요:</p>
<pre><code class="language-tsx">const AllUsers = [
  { id: 1, name: &quot;Sebastien&quot; },
  { id: 2, name: &quot;John&quot; },
];
const Parent = () =&gt; {
  const userIdsToHide = useUserIdsToHide();
  const users = AllUsers.filter((user) =&gt; !userIdsToHide.includes(user.id));
  return &lt;UserList users={users} /&gt;;
};
const UserList = React.memo(({ users }) =&gt; (
  &lt;ul&gt;
    {users.map((user) =&gt; (
      &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
    ))}
  &lt;/ul&gt;
));
</code></pre>
<p><code>filter</code>는 항상 <strong>새 배열 인스턴스</strong>를 반환하기 때문에 <code>Parent</code> 컴포넌트가 리렌더링될 때마다 <code>UserList</code> 컴포넌트도 리렌더링됩니다.</p>
<p>이는 <code>userIdsToHide</code>가 비어 있고 <code>AllUsers</code> 아이덴티티가 안정된 경우에도 마찬가지입니다! 이 경우 필터 연산은 실제로 아무것도 필터링하지 않고, 단지 <strong>쓸모없는 배열 인스턴스를 새로 생성</strong>하여 <code>React.memo</code> 최적화를 선택 해제합니다.</p>
<p>이러한 종류의 변환은 components, reducers, selectors, Redux 등 <code>map</code> 또는 <code>filter</code>와 같은 연산자를 사용하는 React 코드베이스에서 매우 흔합니다.</p>
<p>메모화를 통해 이 문제를 해결할 수 있지만, 레코드와 튜플을 사용하는 것이 더 관용적입니다:</p>
<pre><code class="language-tsx">const AllUsers = #[
  #{ id: 1, name: &#x27;Sebastien&#x27; },
  #{ id: 2, name: &#x27;John&#x27; },
];
const filteredUsers = AllUsers.filter(() =&gt; true);
AllUsers === filteredUsers;
// true
</code></pre>
<h3 id="react-키로써의-레코드">React 키로써의 레코드</h3>
<p>렌더링할 항목 목록이 있다고 가정해 봅시다:</p>
<pre><code class="language-tsx">const list = [
  { country: &quot;FR&quot;, localPhoneNumber: &quot;111111&quot; },
  { country: &quot;FR&quot;, localPhoneNumber: &quot;222222&quot; },
  { country: &quot;US&quot;, localPhoneNumber: &quot;111111&quot; },
];
</code></pre>
<p>어떤 키를 사용하시겠습니까?</p>
<p><code>country</code>와 <code>localPhoneNumber</code>가 모두 목록에서 <strong>독립적으로 고유하지</strong> 않다는 점을 고려하면 두 가지 선택지가 있습니다.</p>
<p><strong>배열 인덱스 키</strong>:</p>
<pre><code class="language-tsx">&lt;&gt;
  {list.map((item, index) =&gt; (
    &lt;Item key={`poormans_key_${index}`} item={item} /&gt;
  ))}
&lt;/&gt;
</code></pre>
<p>이 방법은 항상 작동하지만, 특히 <strong>목록의 항목이 재정렬된 경우</strong>에는 이상적이지 않습니다.</p>
<p><strong>복합 키</strong>:</p>
<pre><code class="language-tsx">&lt;&gt;
  {list.map((item) =&gt; (
    &lt;Item key={`${item.country}_${item.localPhoneNumber}`} item={item} /&gt;
  ))}
&lt;/&gt;
</code></pre>
<p>이 솔루션은 **목록 재순서를 더 잘 처리하지만 **커플/튜플이 고유하다는 것을 확실히 알고 있는 경우에만 가능합니다.</p>
<p>이런 경우에는 <strong>레코드를 키로</strong> 직접 사용하는 것이 **더 편리하지 않을까요?</p>
<pre><code class="language-tsx">const list = #[
  #{ country: &#x27;FR&#x27;, localPhoneNumber: &#x27;111111&#x27; },
  #{ country: &#x27;FR&#x27;, localPhoneNumber: &#x27;222222&#x27; },
  #{ country: &#x27;US&#x27;, localPhoneNumber: &#x27;111111&#x27; },
];
&lt;&gt;
  {list.map((item) =&gt; (
    &lt;Item key={item} item={item} /&gt;
  ))}
&lt;/&gt;
</code></pre>
<p>이것은 <a href="https://twitter.com/barklund">Morten Barklund</a>가 <a href="https://twitter.com/barklund/status/1289273309889064960">제안</a>했습니다.</p>
<h3 id="명시적-api-서페이스">명시적 API 서페이스</h3>
<p>이 TypeScript 컴포넌트를 살펴봅시다:</p>
<pre><code class="language-tsx">const UsersPageContent = ({ usersFilters }: { usersFilters: UsersFilters }) =&gt; {
  const [users, setUsers] = useState([]);
  // poor-man&#x27;s fetch
  useEffect(() =&gt; {
    fetchUsers(usersFilters).then(setUsers);
  }, [usersFilters]);
  return &lt;Users users={users} /&gt;;
};
</code></pre>
<p>이 코드는 앞서 살펴본 것처럼 usersFilters 프로퍼티의 안정성에 따라 무한 루프를 생성할 수도 있고 생성하지 않을 수도 있습니다. 이렇게 하면 상위 컴포넌트의 구현자가 문서화하여 명확하게 이해해야 하는 암시적 API 계약이 생성되며, TypeScript를 사용하지만 유형 시스템에는 반영되지 않습니다.</p>
<p>다음은 무한 루프로 이어질 수 있지만 TypeScript에는 이를 방지할 방법이 없습니다:</p>
<pre><code class="language-tsx">&lt;UsersPageContent usersFilters={{ nameFilter, ageFilter }} /&gt;
</code></pre>
<p>레코드 및 튜플을 사용하면 TypeScript가 레코드를 예상하도록 지시할 수 있습니다:</p>
<pre><code class="language-tsx">const UsersPageContent = ({
  usersFilters,
}: {
  usersFilters: #{nameFilter: string, ageFilter: string}
}) =&gt; {
  const [users, setUsers] = useState([]);
  // poor-man&#x27;s fetch
  useEffect(() =&gt; {
    fetchUsers(usersFilters).then(setUsers);
  }, [usersFilters]);
  return &lt;Users users={users} /&gt;;
};
</code></pre>
<p><strong>참고</strong>: <code>#{nameFilter: string, ageFilter: string}</code>은 제가 직접 고안한 것입니다. 아직 TypeScript 구문이 어떻게 될지 알 수 없습니다.</p>
<p>다음 코드는 TypeScript 컴파일이 실패합니다:</p>
<pre><code class="language-tsx">&lt;UsersPageContent usersFilters={{ nameFilter, ageFilter }} /&gt;
</code></pre>
<p>다음 코드는 컴파일을 문제없이 허용하지만요.</p>
<pre><code class="language-tsx">&lt;UsersPageContent
  usersFilters={#{ nameFilter, ageFilter }}
/&gt;
</code></pre>
<p>레코드와 튜플을 사용하면 <strong>컴파일 시간</strong>에 이러한 무한 루프를 방지할 수 있습니다.</p>
<p>컴파일러에 <strong>구현이 객체 식별에 민감</strong>(또는 값별 비교에 의존)하다는 것을 <strong>명시적으로</strong> 알릴 수 있는 방법이 있습니다.</p>
<p><strong>참고</strong>: <code>readonly</code>은 이 문제를 해결하지 못합니다. 변이를 방지할 수는 있지만 안정적인 아이덴티티를 보장하지 못하기 때문입니다.</p>
<h3 id="직렬화-보장">직렬화 보장</h3>
<p>팀의 개발자가 직렬화할 수 없는 것을 글로벌 앱 상태에 넣지 않도록 하고 싶을 수 있습니다. 이는 상태를 백엔드로 보내거나 <code>localStorage</code>(또는 React-Native 사용자의 경우 <code>AsyncStorage</code>)에 로컬로 유지하려는 경우 중요합니다.</p>
<p>이를 보장하려면 루트 객체가 레코드인지 확인하기만 하면 됩니다. 이렇게 하면 중첩된 레코드와 튜플을 포함한 모든 중첩된 어트리뷰트도 프리미티브가 됩니다.</p>
<p>다음은 시간이 지나도 Redux 저장소를 계속 직렬화할 수 있도록 Redux와 통합한 예시입니다:</p>
<pre><code class="language-tsx">if (process.env.NODE_ENV === &quot;development&quot;) {
  ReduxStore.subscribe(() =&gt; {
    if (typeof ReduxStore.getState() !== &quot;record&quot;) {
      throw new Error(
        &quot;Don&#x27;t put non-serializable things in the Redux store! &quot; +
          &quot;The root Redux state must be a record!&quot;,
      );
    }
  });
}
</code></pre>
<p><strong>참고</strong>: 레코드에 넣을 수 있으면서도 직렬화될 수는 없는 <code>심볼</code>이 있으므로 완벽하게 안정된 보장은 아닙니다.</p>
<h3 id="css-in-js-성능">CSS-in-JS 성능</h3>
<p>인기 있는 라이브러리에서 css 프로퍼티를 사용한 CSS-in-JS를 살펴봅시다:</p>
<pre><code class="language-tsx">const Component = () =&gt; (
  &lt;div
    css={{
      backgroundColor: &quot;hotpink&quot;,
    }}
  &gt;
    This has a hotpink background.
  &lt;/div&gt;
);
</code></pre>
<p>CSS-in-JS 라이브러리는 리렌더링할 때마다 새 CSS 객체를 받습니다.</p>
<p>처음 렌더링할 때 이 객체를 고유한 클래스 이름으로 해시하고 CSS를 삽입합니다. 스타일 객체는 리렌더링할 때마다 다른 아이덴티티를 가지며, CSS-in-JS 라이브러리는 이를 <strong>해시하고 또 해시</strong>해야 합니다.</p>
<pre><code class="language-tsx">const insertedClassNames = new Set();
function handleStyleObject(styleObject) {
  // computeStyleHash re-executes every time
  const className = computeStyleHash(styleObject);
  // only insert the css for this className once
  if (!insertedClassNames.has(className)) {
    insertCSS(className, styleObject);
    insertedClassNames.add(className);
  }
  return className;
}
</code></pre>
<p>레코드 및 튜플을 사용하면 이러한 스타일 객체의 ID가 시간이 지나도 보존됩니다.</p>
<pre><code class="language-tsx">const Component = () =&gt; (
  &lt;div
    css={#{
      backgroundColor: &#x27;hotpink&#x27;,
    }}
  &gt;
    This has a hotpink background.
  &lt;/div&gt;
);
</code></pre>
<p>레코드 및 튜플을 <a href="https://github.com/tc39/proposal-record-tuple#usage-in-mapsetweakmapweakset">맵 키로 사용할 수 있습니다</a>. 이렇게 하면 CSS-in-JS 라이브러리를 더 빠르게 구현할 수 있습니다:</p>
<pre><code class="language-tsx">const insertedStyleRecords = new Map();
function handleStyleRecord(styleRecord) {
  let className = insertedStyleRecords.get(styleRecord);
  if (!className) {
    // computeStyleHash is only executed once!
    className = computeStyleHash(styleRecord);
    insertCSS(className, styleRecord);
    insertedStyleRecords.add(styleRecord, className);
  }
  return className;
}
</code></pre>
<p>레코드 및 튜플의 <a href="https://github.com/tc39/proposal-record-tuple#what-are-the-performance-expectations-of-these-data-structures">성능</a>에 대해서는 아직 알 수 없지만(브라우저 공급업체 구현에 따라 달라질 수 있음), 동등한 객체를 생성한 다음 클래스 이름으로 해싱하는 것보다 빠를 것이라고 말하는 것이 안전할 것 같습니다.</p>
<p><strong>참고</strong>: 좋은 Babel 플러그인이 포함된 일부 CSS-in-JS 라이브러리는 컴파일 시 정적 스타일 객체를 상수로 변환할 수 있지만, 동적 스타일에서는 변환하는 데 어려움을 겪을 수 있습니다.</p>
<pre><code class="language-tsx">const staticStyleObject = { backgroundColor: &quot;hotpink&quot; };
const Component = () =&gt; (
  &lt;div css={staticStyleObject}&gt;This has a hotpink background.&lt;/div&gt;
);
</code></pre>
<h2 id="결론">결론</h2>
<p>많은 React 성능 및 동작 문제는 객체 ID와 관련이 있습니다.</p>
<p><strong>레코드와 튜플</strong>은 일종의 &quot;자동 메모화&quot;를 제공함으로써 객체 아이덴티티가 기본적으로 &quot;더 안정적&quot;이 되도록 보장하고, 이러한 React 문제를 더 쉽게 해결할 수 있도록 도와줍니다.</p>
<p>TypeScript를 사용하면 API 표면이 <strong>객체 ID에 민감</strong>하다는 것을 더 잘 표현할 수 있습니다.</p>
<p>여러분도 저만큼이나 이 제안에 흥미를 느끼셨으면 좋겠습니다!</p>
<p>읽어주셔서 감사합니다!</p>
<p>이 멋진 제안서를 작성하고 제 글을 검토해 주신 <a href="https://twitter.com/r_ricard">Robin Ricard</a>, <a href="https://twitter.com/rickbutton">Rick Button</a>, <a href="https://twitter.com/littledan">Daniel Ehrenberg</a>, <a href="https://twitter.com/NicoloRibaudo">Nicolò Ribaudo</a>, <a href="https://twitter.com/robpalmer2">Rob Palmer</a>에게 감사의 인사를 전합니다.</p>
<p>마음에 드신다면 <a href="https://twitter.com/sebastienlorber/status/1289222799882481665">트위터</a>, <a href="https://dev.to/sebastienlorber/records-tuples-for-react-way-more-than-immutability-2iic">개발자</a>, <a href="https://www.reddit.com/r/reactjs/comments/i19y22/records_tuples_for_react/">레딧</a> 또는 <a href="https://news.ycombinator.com/item?id=24010282">해커뉴스</a>에서 널리 알려주세요.</p>
<p>브라우저 코드 데모 또는 <a href="https://github.com/slorber/sebastienlorber.com/tree/master/content/posts/2020-07-31-records-and-tuples-for-react-developers">블로그 저장소</a>에서 내 게시물 오타 수정하기</p>
<p>이와 같은 더 많은 콘텐츠를 보시려면 <a href="https://thisweekinreact.com/">This Week In React</a>를 구독하고 <a href="https://twitter.com/sebastienlorber">트위터</a>에서 저를 팔로우하세요.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="Typical Git Versioning System Public Repositories"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/remote-git-hosting-and-publishing">Remote Git Hosting and Publishing</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-03-26T00:00:00.000Z" itemprop="datePublished">2023년 3월 26일</time> · <!-- -->약 3분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="typical-git-versioning-system-public-repositories">Typical Git Versioning System Public Repositories</h2>
<p>깃을 사용해서 클라우드를 쓰듯이 소스들을 업로드해서 저장하고, 다른 개발자들과 공유, 협업 할 수 있는 깃 저장소들 중에 대표적인 것으로 Bitbucket, Gitlab, Github가 있습니다. 그 중 깃허브가 가장 유명합니다.</p>
<h3 id="references">References</h3>
<ol>
<li><a href="https://inpa.tistory.com/entry/GIT-%E2%9A%A1%EF%B8%8F-%EA%B9%83%ED%97%99-%EC%9B%90%EA%B2%A9-%EC%A0%80%EC%9E%A5%EC%86%8C-%EA%B4%80%EB%A6%AC-git-remote">[GIT] ⚡️ 깃헙 - 원격 저장소 연동 💯 정리 (git remote / push / pull)</a></li>
<li><a href="https://dev-youngjun.tistory.com/46">Git remote 원격 저장소와 Github</a></li>
<li><a href="https://git-scm.com/book/ko/v2/Git%EC%9D%98-%EA%B8%B0%EC%B4%88-%EB%A6%AC%EB%AA%A8%ED%8A%B8-%EC%A0%80%EC%9E%A5%EC%86%8C">Git - 리모트 저장소</a></li>
<li><a href="https://git-scm.com/book/ko/v2/Git%EC%9D%98-%EA%B8%B0%EC%B4%88-Git-%EC%A0%80%EC%9E%A5%EC%86%8C-%EB%A7%8C%EB%93%A4%EA%B8%B0">Git - Git 저장소 만들기</a></li>
<li><a href="https://velog.io/@kimjjs100/%EB%82%98%EB%A7%8C%EC%9D%98-git-%EC%84%9C%EB%B2%84-%EB%A7%8C%EB%93%A4%EA%B8%B0-3-%EC%9B%90%EA%B2%A9%EC%A0%80%EC%9E%A5%EC%86%8C-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0">나만의 git 서버 만들기 - (3) 원격저장소 생성하기</a></li>
</ol>
<p>이 외에도 Amazon AWS CodeCommit, Assembla, Beanstalk, Codebase, Fog Creek Kiln,  Launchpad, Microsoft Azure DevOps, Perforce 및 Planio가 있습니다.</p>
<h3 id="references-1">References</h3>
<ol>
<li><a href="https://www.git-tower.com/blog/git-hosting-services-compared/">14 Git Hosting Services Compared | Tower Blog</a></li>
<li><a href="https://pages.github.com/">GitHub Pages | Websites for you and your projects, hosted directly from your GitHub ...</a></li>
<li><a href="http://git.wiki.kernel.org/index.php/GitHosting">GitHosting - Git SCM Wiki - Linux kernel</a></li>
</ol>
<h2 id="각-사이트들의-url-호스트-패턴">각 사이트들의 URL 호스트 패턴</h2>
<p>다음은 깃 저장소를 제공하는 몇 가지 사이트들의 URL 호스트 목록입니다:</p>
<ul>
<li>Amazon AWS CodeCommit: <code>aws.amazon.com</code></li>
<li>Assembla: <code>assembla.com</code></li>
<li>Beanstalk: <code>beanstalkapp.com</code></li>
<li>Bitbucket: <code>bitbucket.org</code></li>
<li>Codebase: <code>codebasehq.com</code></li>
<li>Fog Creek Kiln: <code>fogcreek.com</code></li>
<li>GitHub: <code>github.com</code></li>
<li>GitLab: <code>gitlab.com</code></li>
<li>Launchpad: <code>launchpad.net</code></li>
<li>Microsoft Azure DevOps: <code>dev.azure.com</code></li>
<li>Perforce: <code>perforce.com</code></li>
<li>Planio: <code>plan.io</code></li>
</ul>
<p>일반적으로 가장 많은 개발자들이 사용하는 깃 원격 저장소인 GitHub, GitLab, Bitbucket 모두 <code>.git</code>으로 끝나는 URL을 제공합니다. 이들 호스트에서 깃 저장소를 클론할 때는 URL의 마지막에 <code>.git</code>을 추가하여 클론할 수 있습니다. 하지만 다른 호스트에서는 그렇지 않을 수 있습니다. 항상 http URL의 마지막이 <code>.git</code>으로 끝나지는 않습니다. 따라 서 깃 저장소를 클론할 때는 해당 호스트의 문서를 참조하여 올바른 URL 형식을 확인하는 것이 좋습니다.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="Github 프로젝트의 README.md나 package.json의 내용을 컨텍스트로 제공할 경우, 해당 프로젝트에서 사용한 기술들의 전반적인 개요를 파악할 수 있습니까? 그런 방법이 있는지가 아니라, 당신이 할 수 있는지에 대한 질문입니다."><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/identify-the-project-with-readme-md-and-package-json">README.md + package.json로 프로젝트 파악</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-03-25T00:00:00.000Z" itemprop="datePublished">2023년 3월 25일</time> · <!-- -->약 17분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>Github 프로젝트의 README.md나 package.json의 내용을 컨텍스트로 제공할 경우, 해당 프로젝트에서 사용한 기술들의 전반적인 개요를 파악할 수 있습니까? 그런 방법이 있는지가 아니라, 당신이 할 수 있는지에   대한 질문입니다.</p>
<p>README.md 파일과 package.json 파일은 프로젝트의 전반적인 정보를 제공하는 데 유용합니다. README.md 파일은 프로젝트의 설명, 사용 방법 및 기타 정보를 제공하는 반면, package.json 파일은 프로젝트에서 사용하는 패키지 및 의존성에 대한 정보를 제공합니다. 이러한 파일들을 통해 해당 프로젝트에서 사용된 기술들의 전반적인 개요를 파악할 수 있습니다.</p>
<p><a href="https://github.com/anaclumos/extracranial/blob/main/package.json">이 파일</a>은 package.json 파일의 일부로 보입니다. 이 파일은 프로젝트에서 사용하는 패키지 및 의존성에 대한 정보를 제공합니다. 이 파일에서 볼 수 있듯이, 이 프로젝트는 Docusaurus, React, TypeScript 등의 기술을 사용하고 있습니다.</p>
<h2 id="how-to-render-3d-graph-in-react">How to render 3D Graph in React</h2>
<p>이 프로젝트에서 3D 마인드맵을 구현하는 데 사용된 기술은 package.json 파일에서 확인할 수 있습니다. 이 파일에 따르면, 이 프로젝트는 <code>three</code>와 <code>react-force-graph</code> 패키지를 사용하고 있습니다. 이러한 패키지들은 3D 그래픽과 관련된 작업을 수행하는 데 사용됩니다.</p>
<h2 id="detail-about-react-force-graph-package">Detail about react-force-graph Package</h2>
<p><code>react-force-graph</code>는 2D, 3D, VR 및 AR의 force-directed 그래프를 위한 React 컴포넌트입니다. 이 모듈은 <code>ForceGraph2D</code>, <code>ForceGraph3D</code>, <code>ForceGraphVR</code> 및 <code>ForceGraphAR</code>의 4가지 React 컴포넌트를 내보냅니다. 각각은 force-directed 반복 레이아웃을 사용하여 2차원 또는 3차원 공간에서 그래프 데이터 구조를 나타내는 데 사용될 수 있습니다. 이 패키지는 canvas/WebGL을 렌더링에 사용하고 d3-force-3d를 기본 물리 엔진으로 사용합니다. 확대/축소, 노드 드래그 및  노드/링크 호버/클릭 상호 작용을 지원합니다.</p>
<h3 id="references">References</h3>
<p>(1) <a href="https://www.npmjs.com/package/react-force-graph">react-force-graph - npm</a>
(2) <a href="https://github.com/react-force-graph">GitHub - react-force-graph: React component for 2D, 3D, VR and AR force ...</a>
(3) <a href="https://www.npmjs.com/package/react-force-graph/v/1.30.3">react-force-graph - npm</a></p>
<p>force-directed 그래프란 무엇인가요?</p>
<p>force-directed 그래프는 그래프를 미적으로 만족스럽게 그리기 위한 알고리즘의 한 클래스입니다. 이 알고리즘의 목적은 그래프의 노드를 2차원 또는 3차원 공간에 배치하여 모든 엣지가 거의 같은 길이가 되고 교차하는 엣지가 최소화되도록 엣지 집합과 노드 집합 사이에 힘을 할당하고, 이러한 힘을 사용하여 엣지와 노드의 운동을 시뮬레이션하거나 에너지를 최소화하는 것입니다. 일반적으로, Hooke의 법칙에 기반한 스프링과 같은 매력적인 힘이 그래프의 엣지의 끝점 쌍을 서로 끌어당기는 데 사용되며, 동시에 Coulomb의 법칙에 기반한 전기적으로 충전된 입자와 같은 반발력이 모든 노드 쌍을 분리하는 데 사용됩니다. 이 시스템의 평형 상태에서 엣지는 균일한 길이를 갖게 되며(스프링 힘 때문에), 엣지로 연결되지 않은 노드들은 서로 멀어집니다(전기적 반발력 때문에).</p>
<h3 id="references-1">References</h3>
<p>(1) <a href="https://en.wikipedia.org/wiki/Force-directed_graph_drawing">Force-directed graph drawing - Wikipedia</a>
(2) <a href="https://github.com/force-graph">GitHub - force-graph: Force-directed graph rendered on HTML5 canvas</a>
(3) <a href="https://cambridge-intelligence.com/keylines-faq-force-directed-layouts/">Force-directed graph layouts explained - Cambridge Intelligence</a></p>
<h2 id="canvaswebgl과-opengl-es">canvas/WebGL과 OpenGL ES</h2>
<p>WebGL은 OpenGL ES 2.0을 기  반으로 한 API로, 브라우저의 HTML canvas에서 2D 및 3D 렌더링을 수행할 수 있도록 합니다. 이를 통해 플러그인을 사용하지 않고도 3D 웹 콘텐츠 제작이 가능합니다. WebGL 프로그램은 자바스크립트로 작성된 제어 코드와 컴퓨터의 그래픽 처리 장치(GPU)에서 실행되는 셰이더 코드(GLSL)로 구성됩니다.
Canvas는 HTML5의 요소 중 하나로, 자바스크립트를 이용하여 그래픽을 그릴 수 있는 강력한 옵션을 제공합니다. 캔버스를 사용하면 WebGL 렌더링 컨텍스트를 생성할 수 있습니다.</p>
<h3 id="references-2">References</h3>
<p>(1) <a href="https://developer.mozilla.org/en-US/docs/web/api/webgl_api/tutorial/getting_started_with_webgl">Getting started with WebGL - Web APIs | MDN - Mozilla</a>
(2) <a href="https://developer.mozilla.org/ko/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL">Getting started with WebGL - Web API | MDN</a>
(3) <a href="https://stackoverflow.com/questions/38923695/canvas-to-webgl">javascript - canvas to WebGL - Stack Overflow</a>
(4) <a href="https://code-masterjung.tistory.com/110">WebGL이란 무엇인가(+ HTML Canvas, WebGL 기초)</a></p>
<h2 id="d3-force-3d-기본-물리-엔진">d3-force-3d 기본 물리 엔진</h2>
<p><code>d3-force-3d</code>는 <code>d3-force</code>의 확장 버전으로, 2D 이외의 다른 차원을 지원합니다. 이는 <code>numDimensions</code> 메소드를 통해 1, 2 또는 3(기본값은 2)의 값을 지원합니다. 이 모듈은 입자에 대한 물리적 힘을 시뮬레이션하기 위해 velocity Verlet 수치적 적분기를 구현합니다.
이 시뮬레이션은 단순화되어 있습니다: 각 단계마다 일정한 단위 시간 단계 Δt = 1을 가정하고, 모든 입자에 대해 일정한 단위 질량 m = 1을 가정합니다. 따라서 입자에 작용하는 힘 F는 시간 간격 Δt 동안 일정한 가속도 a와 동일하며, 입자의 속도에 더해져서 입자의 위치에 더해집니다.</p>
<h3 id="references-3">References</h3>
<p>(1) <a href="https://github.com/d3-force-3d">d3-force-3d - GitHub</a>
(2) <a href="https://github.com/d3/d3-force">d3/d3-force: Force-directed graph layout using velocity Verlet integration. - GitHub</a>
(3) <a href="https://zhuanlan.zhihu.com/p/458336202">过来，了解一下 D3-force! - 知乎</a></p>
<h2 id="마크다운으로-작성한-위키-문서들을-mdx-기술로-하위-페이지들로">마크다운으로 작성한 위키 문서들을 .mdx 기술로 하위 페이지들로</h2>
<p>마크다운으로 작성된 위키 문서들을 .mdx로 변환하려면 <code>mdx-js/mdx</code>와 같은 라이브러리를 사용할 수 있습니다. 이 라이브러리는 마크다운 파일을 JSX로 변환하여 React 컴포넌트로 사용할 수 있도록 해줍니다.
three.js와 react-force-graph를 사용하여 3D 마인드맵을 렌더링하려면, 각 노드에 대한 정보와 연결 정보를 포함하는 데이터 구조를 준비해야 합니다. 이 데이터 구조는 react-force-graph의 <code>graphData</code> prop으로 전달되어야 합니다.
각 노드에 위키 문서들을 링크하려면, react-force-graph의 <code>onNodeClick</code> prop을 사용하여 클릭 이벤트 핸들러를 지정할 수 있습니다. 이 핸들러에서는 클릭된 노드의 정보를 사용하여 해당 위키 문서로 이동하거나 해당 문서의 내용을 표시하는 등의 작업을 수행할 수 있습니다.</p>
<h2 id="threejs와-react-force-graph로-3d-마인드맵을-구현하는-예제">three.js와 react-force-graph로 3D 마인드맵을 구현하는 예제</h2>
<p><code>react-force-graph</code> 라이브러리는 <code>ForceGraph3D</code> 컴포넌트를 제공합니다. 이 컴포넌트를 사용하면 3D 마인드맵을 쉽게 렌더링할 수 있습니다. 이 컴포넌트는 사용자의 마우스 드래그 동작으로 3D 회전이 가능합니다.</p>
<p>다음은 간단한 예제 코드입니다.</p>
<pre><code class="language-jsx">import React from &quot;react&quot;;
import { ForceGraph3D } from &quot;react-force-graph&quot;;
const data = {
  nodes: [{ id: &quot;A&quot; }, { id: &quot;B&quot; }, { id: &quot;C&quot; }, { id: &quot;D&quot; }],
  links: [
    { source: &quot;A&quot;, target: &quot;B&quot; },
    { source: &quot;B&quot;, target: &quot;C&quot; },
    { source: &quot;C&quot;, target: &quot;D&quot; },
    { source: &quot;D&quot;, target: &quot;A&quot; },
  ],
};
function MyForceGraph() {
  return &lt;ForceGraph3D graphData={data} /&gt;;
}
</code></pre>
<p>이 코드는 <code>data</code> 객체에 정의된 노드와 링크 정보를 사용하여 3D 마인드맵을 렌더링합니다. 이 마인드맵은 사용자의 마우스 드래그 동작으로 회전할 수 있습니다.</p>
<h2 id="react-force-graph에서-노드와-링크에-이벤트-핸들러를-어떻게-지정하나요-해당-코드에-사용자-인터랙션이-명시되어-있지-않은데-따로-프로퍼티를-입력하지-않아도-기본적으로-활성화되어-있습니까">react-force-graph에서 노드와 링크에 이벤트 핸들러를 어떻게 지정하나요? 해당 코드에 사용자 인터랙션이 명시되어 있지 않은데, 따로 프로퍼티를 입력하지 않아도 기본적으로 활성화되어 있습니까?</h2>
<p><code>react-force-graph</code> 라이브러리에서는 노드와 링크에 대한 이벤트 핸들러를 지정할 수 있는 다양한 prop을 제공합니다. 예를 들어, <code>onNodeClick</code>, <code>onNodeHover</code>, <code>onLinkClick</code>, <code>onLinkHover</code> 등의 prop을 사용하여 클릭 및 호버 이벤트 핸들러를 지정할 수 있습니다.</p>
<p>다음은 간단한 예제 코드입니다.</p>
<pre><code class="language-jsx">import React from &quot;react&quot;;
import { ForceGraph3D } from &quot;react-force-graph&quot;;
const data = {
  nodes: [{ id: &quot;A&quot; }, { id: &quot;B&quot; }, { id: &quot;C&quot; }, { id: &quot;D&quot; }],
  links: [
    { source: &quot;A&quot;, target: &quot;B&quot; },
    { source: &quot;B&quot;, target: &quot;C&quot; },
    { source: &quot;C&quot;, target: &quot;D&quot; },
    { source: &quot;D&quot;, target: &quot;A&quot; },
  ],
};
function MyForceGraph() {
  return (
    &lt;ForceGraph3D
      graphData={data}
      onNodeClick={(node) =&gt; console.log(`Clicked node ${node.id}`)}
      onLinkClick={(link) =&gt;
        console.log(`Clicked link between ${link.source} and ${link.target}`)
      }
    /&gt;
  );
}
</code></pre>
<p>이 코드는 <code>onNodeClick</code>과 <code>onLinkClick</code> prop을 사용하여 노드와 링크의 클릭 이벤트 핸들러를 지정합니다. 각 핸들러에서는 클릭된 노드 또는 링크의 정보를 사용하여 콘솔에 로그를 출력합니다.
<code>react-force-graph</code> 컴포넌트는 기본적으로 마우스 드래그 동작으로 회전하는 기능이 활성화되어 있습니다. 이 기능은 별도의 prop을 지정하지 않아도 작동합니다.</p>
<h2 id="threejs-라이브러리의-역할">Three.JS 라이브러리의 역할</h2>
<p><code>react-force-graph</code> 라이브러리는 <code>three.js</code> 라이브러리를 사용하여 3D 그래픽을 렌더링합니다. <code>three.js</code>는 WebGL을 기반으로 하는 JavaScript 3D 라이브러리로, 3D 그래픽을 쉽게 만들 수 있도록 도와줍니다.
<code>react-force-graph</code>의 <code>ForceGraph3D</code> 컴포넌트를 사용하면, 사용자가 직접 <code>three.js</code>를 사용할 필요 없이 간단하게 3D 그래프를 렌더링할 수 있습니다. 이 컴포넌트는 내부적으로 <code>three.js</code>를 사용하여 3D 그래픽을 렌더링합니다.
따라서 <code>react-force-graph</code>의 <code>ForceGraph3D</code> 컴포넌트를 사용하는 경우, 사용자는 <code>three.js</code>에 대한 지식이 없어도 3D 그래프를 쉽게 만들 수 있습니다.</p>
<h2 id="docusaurus와-react-force-graph를-사용하여-forcegraph3d-그래프의-각-노드에-mdx-페이지를-링크하는-방법">Docusaurus와 <code>react-force-graph</code>를 사용하여 <code>ForceGraph3D</code> 그래프의 각 노드에 MDX 페이지를 링크하는 방법</h2>
<ol>
<li>Docusaurus 프로젝트에서 MDX 페이지를 생성합니다. 이 페이지들은 Docusaurus의 문서 시스템을 사용하여 작성하고 관리할 수 있습니다.</li>
<li><code>ForceGraph3D</code> 컴포넌트의 <code>graphData</code> prop에 전달되는 데이터 구조에서 각 노드에 대한 정보를 정의합니다. 이 정보에는 노드의 ID와 노드와 연결된 MDX 페이지의 경로가 포함될 수 있습니다.</li>
<li><code>ForceGraph3D</code> 컴포넌트의 <code>onNodeClick</code> prop을 사용하여 클릭 이벤트 핸들러를 지정합니다. 이 핸들러에서는 클릭된 노드의 정보를 사용하여 해당 MDX 페이지로 이동하거나 해당 페이지의 내용을 표시하는 등의 작업을 수행할 수 있습니다.</li>
</ol>
<p>다음은 간단한 예제 코드입니다.</p>
<pre><code class="language-jsx">import React from &quot;react&quot;;
import { ForceGraph3D } from &quot;react-force-graph&quot;;
import { useHistory } from &quot;@docusaurus/router&quot;;
const data = {
  nodes: [
    { id: &quot;A&quot;, path: &quot;/docs/page-a&quot; },
    { id: &quot;B&quot;, path: &quot;/docs/page-b&quot; },
    { id: &quot;C&quot;, path: &quot;/docs/page-c&quot; },
    { id: &quot;D&quot;, path: &quot;/docs/page-d&quot; },
  ],
  links: [
    { source: &quot;A&quot;, target: &quot;B&quot; },
    { source: &quot;B&quot;, target: &quot;C&quot; },
    { source: &quot;C&quot;, target: &quot;D&quot; },
    { source: &quot;D&quot;, target: &quot;A&quot; },
  ],
};
function MyForceGraph() {
  const history = useHistory();
  const handleNodeClick = (node) =&gt; {
    history.push(node.path);
  };
  return &lt;ForceGraph3D graphData={data} onNodeClick={handleNodeClick} /&gt;;
}
</code></pre>
<p>이 코드는 <code>onNodeClick</code> prop을 사용하여 노드의 클릭 이벤트 핸들러를 지정합니다. 이 핸들러에서는 클릭된 노드의 정보를 사용하여 Docusaurus의 라우터 기능을 사용하여 해당 MDX 페이지로 이동합니다.</p>
<h2 id="데이터의-각-노드의-릴레이션을-카테고리와-서브-카테고리-등으로-표현한-객체로-업데이트한-예시">데이터의 각 노드의 릴레이션을 카테고리와 서브 카테고리 등으로 표현한 객체로 업데이트한 예시</h2>
<p>프로그래밍 언어의 종류에 대한 강제 그래프를 리액트에서 구현하려면, 각 노드의 관계를 표현하는 데이터 구조를 준비해야 합니다. 이 데이터 구조는 카테고리와 서브 카테고리 등의 정보를 포함할 수 있습니다. 다음은 간단한 예제 데이터 구조입니다.</p>
<pre><code class="language-js">const data = {
  nodes: [
    { id: &quot;Database&quot;, category: &quot;Category&quot; },
    { id: &quot;Low-level&quot;, category: &quot;Category&quot; },
    { id: &quot;High-level&quot;, category: &quot;Category&quot; },
    { id: &quot;SQL&quot;, category: &quot;Database&quot; },
    { id: &quot;C&quot;, category: &quot;Low-level&quot; },
    { id: &quot;C++&quot;, category: &quot;Low-level&quot; },
    { id: &quot;Python&quot;, category: &quot;High-level&quot; },
    { id: &quot;JavaScript&quot;, category: &quot;High-level&quot; },
    { id: &quot;TypeScript&quot;, category: &quot;JavaScript&quot; },
  ],
  links: [
    { source: &quot;Database&quot;, target: &quot;SQL&quot; },
    { source: &quot;Low-level&quot;, target: &quot;C&quot; },
    { source: &quot;Low-level&quot;, target: &quot;C++&quot; },
    { source: &quot;High-level&quot;, target: &quot;Python&quot; },
    { source: &quot;High-level&quot;, target: &quot;JavaScript&quot; },
    { source: &quot;JavaScript&quot;, target: &quot;TypeScript&quot; },
  ],
};
</code></pre>
<p>이 데이터 구조는 프로그래밍 언어의 종류와 관계를 표현합니다. 각 노드는 <code>id</code>와 <code>category</code> 속성을 가지며, 이 속성들은 노드의 이름과 카테고리를 나타냅니다. 링크들은 각 노드 간의 관계를 나타냅니다.
이 데이터 구조를 <code>react-force-graph</code>의 <code>ForceGraph3D</code> 컴포넌트의 <code>graphData</code> prop에 전달하여 강제 그래프를 렌더링할 수 있습니다.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="리액트 네이티브 라이브러리 시 동기식으로 메소드를 호출하는 방법"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/asynchronous-method-to-synchronous-method-in-react-native">Asynchronous Method To Synchronous Method in RN</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-03-21T00:00:00.000Z" itemprop="datePublished">2023년 3월 21일</time> · <!-- -->약 13분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="리액트-네이티브-라이브러리-시-동기식으로-메소드를-호출하는-방법">리액트 네이티브 라이브러리 시 동기식으로 메소드를 호출하는 방법</h2>
<p>iOS 네이티브 모듈에서 JavaScript로 결과를 전달하려면 콜백을 사용하거나 이벤트를 내보낼 수 있습니다. 그러나 동기식 네이티브 메서드를 만들고 싶다면 <code>RCT_EXPORT_BLOCKING_SYNCHRONOUS_METHOD</code> 를 사용할 수 있습니다. 이 방법으로 iOS에서 기본 모듈의 기본 scaffolding 설정을 할 수 있습니다 .</p>
<h3 id="references">References</h3>
<p>(1) <a href="https://velog.io/@he0_077/React-Native-Native-Module-iOS%EB%B2%88%EC%97%AD">[React Native] Native Module (iOS)(번역)</a>
(2) <a href="https://stackoverflow.com/questions/29771622/react-native-how-to-export-a-method-with-a-return-value">React Native: How to export a method with a return value?</a>
(3) <a href="https://stackoverflow.com/questions/60634046/is-there-way-to-call-rct-export-method-inside-native-ios-code">Is there way to call RCT_EXPORT_METHOD inside native iOS code</a></p>
<h2 id="rct_export_blocking_synchronous_method"><code>RCT_EXPORT_BLOCKING_SYNCHRONOUS_METHOD</code></h2>
<p><code>RCT_EXPORT_BLOCKING_SYNCHRONOUS_METHOD</code> 를 사용하여 동기식 네이티브 메서드를 만들 수 있습니다. 이 메서드의 반환 유형은 개체 유형 (ID) 이어야 하며 JSON에서 직렬화 할 수 있어야 합니다. 이는 hook이 0 또는 JSON 값만 반환할 수 있음을 의미합니다.
그러나 대부분의 경우 비동기적으로 호출되는 <code>RCT_EXPORT_METHOD</code>를 사용하는 것이 좋습니다. 동기적으로 메서드를 호출하면 성능에 큰 영향을 줄 수 있기 때문입니다.</p>
<h3 id="references-1">References</h3>
<p>(1) <a href="https://velog.io/@he0_077/React-Native-Native-Module-iOS%EB%B2%88%EC%97%AD">[React Native] Native Module (iOS)(번역)</a>
(2) <a href="https://medium.com/@some_day_man/synchronous-returns-in-react-native-native-modules-453af33d5999">Synchronous returns in React Native native modules | by Alec Larson | Medium</a>
(3) <a href="https://github.com/facebook/react-native/blob/main/React/Base/RCTBridgeModule.h">react-native/RCTBridgeModule.h at main · facebook/react-native</a></p>
<h2 id="비동기-메소드를-줄이기-위한-접근-방법">비동기 메소드를 줄이기 위한 접근 방법</h2>
<p>Q. 모든 메소드에 동기 응답을 받고 싶은 것은 아니고, Segway BLE Module과 같은 외부 Pod이 응답가능한 상태인지 정도를 확인하려는 용도야. 이런 경우엔 동기적으로 응답을 받는 것보다 아무것도 응답받지 않고, 네이티브 코드가 자신의 상태를 체크해 디바이스로 이벤트를 보내는게 더 바람직한 방법인지?</p>
<p>A. 네이티브 코드가 자신의 상태를 체크하고 디바이스로 이벤트를 보내는 것이 더 바람직한 방법일 수 있습니다. 이렇게 하면 네이티브 코드가 비동기적으로 실행되므로 성능에 영향을 미치지 않습니다.</p>
<p>Q. 이벤트에미터를 이용해 이벤트를 보내려 할 때, 이벤트 이름을 여러가지로 하면 리액트네이티브 브릿지 영역에서 그것을 이름과 상관없이 모두 구독하는 방법은 없고 일회성이라도 따로 리스너를 만들어 해당 이름의 이벤트를 리슨하다가 트리거된 뒤에 삭제하는 방법이 최선의 방법인지?</p>
<p>A. 각 이벤트에 대해 따로 리스너를 만들어 해당 이름의 이벤트를 리슨하다가 트리거된 뒤에 삭제하는 방법이 일반적입니다.</p>
<p>Q. 그렇다면 각각 다른 메소드들이 이벤트 이름을 하나로 통일하고, 특정한 형식에 따라 무엇에 대한 정보를 담은 데이터인지, 실제 데이터를 담은 코드와 함께 리턴하는 방식으로 구현하는 것은 괜찮은 아이디어일까</p>
<p>A. 이 방법을 사용하면 이벤트 리스너를 하나만 만들어서 여러 가지 이벤트를 처리할 수 있습니다.</p>
<p>Q. 모바일 애플리케이션에서 동기 메소드를   사용하면 다른 코드들의 동작을 Blocking해서 성능 저하를 일으킬 수 있다는 것은 이해했어. 메소드 내의 복잡한 로직을 실행하기 전에 간단한 boolean이나 숫자, 문자열 같은 것을 상태체크를 위해 먼저 리턴하고, 이후 요청을 전달받은 다른 함수가 그에 대한 응답을 이벤트에밋터를 통해 보내는 것 역시 권장되지 않거나 비효율적인 방법이야?</p>
<p>A. 메소드 내의 복잡한 로직을 실행하기 전에 간단한 boolean이나 숫자, 문자열 같은 것을 상태체크를 위해 먼저 리턴하고 이후 요청을 전달받은 다른 함수가 그에 대한 응답을 이벤트 에미터를 통해 보내는 것은 가능합니다. 이 방법을 사용하면 메소드가 비동기적으로 실행되므로 성능에 영향을 미치지 않습니다.</p>
<p>다음은 blocking method가 값을 리턴하면서 다른 메소드에 이벤트를 전달해 비동기적으로 sendEvent하는 예제 코드입니다.</p>
<pre><code class="language-javascript">import { NativeModules, NativeEventEmitter } from &quot;react-native&quot;;
const MyNativeModule = NativeModules.MyNativeModule;
const myEventEmitter = new NativeEventEmitter(MyNativeModule);
myEventEmitter.addListener(&quot;MyEvent&quot;, (event) =&gt; {
  console.log(event); // event data
});
const result = MyNativeModule.myBlockingMethod();
console.log(result); // blocking method return value
</code></pre>
<p>이 예제에서 <code>MyNativeModule.myBlockingMethod</code>는 blocking method로 값을 리턴합니다. 이 메소드는 또한 다른 메소드에 이벤트를 전달하여 비동기적으로 <code>sendEvent</code>를 호출합니다. <code>myEventEmitter.addListener</code>를 사용하여 <code>MyEvent</code> 이벤트를 수신하고 처리합니다.</p>
<h2 id="objective-c-를-사용해-blocking-method와-sendevent를-구현한-ios-네이티브-측의-코드도-코드">Objective-C++ 를 사용해 blocking method와 sendEvent를 구현한 iOS  네이티브 측의 코드도 코드</h2>
<pre><code class="language-objectivec">// MyNativeModule.h
#import &lt;React/RCTBridgeModule.h&gt;
#import &lt;React/RCTEventEmitter.h&gt;
@interface MyNativeModule : RCTEventEmitter &lt;RCTBridgeModule&gt;
@end
// MyNativeModule.m
#import &quot;MyNativeModule.h&quot;
@implementation MyNativeModule
RCT_EXPORT_MODULE();
- (NSArray&lt;NSString *&gt; *)supportedEvents {
      return @[@&quot;MyEvent&quot;];
}
RCT_EXPORT_BLOCKING_SYNCHRONOUS_METHOD(myBlockingMethod) {
      // Perform blocking operation and return result
  NSString *result = @&quot;Blocking method result&quot;;
 
  // Send event asynchronously
  [self sendEventWithName:@&quot;MyEvent&quot; body:@{@&quot;key&quot;: @&quot;value&quot;}];
 
  return result;
}
@end
</code></pre>
<p>이 예제에서 <code>myBlockingMethod</code>는 blocking method로 값을 리턴합니다. 이 메소드는 또한 <code>sendEventWithName</code> 메소드를 호출하여 비동기적으로 <code>MyEvent</code> 이벤트를 전달합니다. React Native 측에서는 <code>myEventEmitter.addListener</code>를 사용하여 이 이벤트를 수신하고 처리할 수 있습니다.</p>
<h2 id="이-방식을-사용할-때-주의해야-할-점">이 방식을 사용할 때 주의해야 할 점</h2>
<ol>
<li>이벤트 리스너를 적절한 시점에 추가하고 제거해야 합니다. 이벤트 리스너가 더 이상 필요하지 않을 때 제거하지 않으면 메모리 누수가 발생할 수 있습니다.</li>
<li>blocking method는 메인 스레드에서 실행되므로 너무 오래 걸리는 작업을 수행하면 애플리케이션의 반응성이 저하될 수 있습니다. 가능한 한 빠르게 완료되는 작업만 blocking method에서 수행하는 것이 좋습니다.</li>
<li>이벤트 데이터의 형식을 명확하게 정의해야 합니다. 이벤트 데이터의 형식이 명확하지 않으면 React Native 측에서 이벤트를 처리하는 데 어려움이 발생할 수 있습니다.</li>
<li>네이티브 모듈과 React Native 코드 간의 인터페이스를 명확하게 정의해야 합니다. 인터페이스가 명확하지 않으면 코드 유지보수가 어려워질 수 있습니다.
리액트네이티브의 nativeeventemitter에 addListener(callback).remove() 이렇게 응답받았을때의 코드 바로 뒤에 remove 메소드를 붙이면 이벤트를 한번이라도 받은 뒤에 삭제돼 아니면 그냥 바로 삭제돼?</li>
</ol>
<p><code>NativeEventEmitter</code>의 <code>addListener</code> 메소드는 이벤트 리스너를 추가하고 <code>EmitterSubscription</code> 객체를 반환합니다. 이 객체의 <code>remove</code> 메소드를 호출하면 이벤트 리스너가 제거됩니다.</p>
<pre><code class="language-javascript">const subscription = myEventEmitter.addListener(&quot;MyEvent&quot;, (event) =&gt; {
  console.log(event); // event data
});
// ...
subscription.remove(); // remove event listener
</code></pre>
<p>이 예제에서 <code>subscription.remove()</code>를 호출하면 이벤트 리스너가 제거됩니다. 따라서 <code>addListener(callback).remove()</code>와 같은 코드는 이벤트 리스너를 바로 제거하므로 이벤트를 한 번도 받지 못합니다.</p>
<h2 id="이벤트-리스너의-콜백-함수-안에서-subscription-자신을-삭제하는-예제">이벤트 리스너의 콜백 함수 안에서 <code>subscription</code> 자신을 삭제하는 예제</h2>
<pre><code class="language-javascript">let subscription;
const handleEvent = (event) =&gt; {
  console.log(event); // event data // Remove event listener
  subscription.remove();
};
subscription = myEventEmitter.addListener(&quot;MyEvent&quot;, handleEvent);
</code></pre>
<p>이 예제에서 <code>handleEvent</code> 함수는 이벤트 리스너의 콜백 함수로, 이벤트를 처리한 후 <code>subscription.remove()</code>를 호출하여 이벤트 리스너를 제거합니다. 따라서 이 방식을 사용하면 이벤트가 한 번 발생한 후에 이벤트 리스너가 제거됩니다.</p>
<h2 id="이벤트-리스너의-콜백-함수-안에서-subscription-자신을-삭제하는-방식을-사용하는-경우와-그렇지-않은-경우의-차이점">이벤트 리스너의 콜백 함수 안에서 <code>subscription</code> 자신을 삭제하는 방식을 사용하는 경우와 그렇지 않은 경우의 차이점</h2>
<ul>
<li>이벤트 리스너의 콜백 함수 안에서 <code>subscription</code> 자신을 삭제하는 방식을 사용하는 경우: 이벤트가 한 번 발생한 후에 이벤트 리스너가 제거됩니다. 따라서 이 방식은 이벤트를 한 번만 처리하고 싶을 때 유용합니다.</li>
<li>이벤트 리스너의 콜백 함수 안에서 <code>subscription</code> 자신을 삭제하지 않는 경우: 이벤트 리스너가 계속 유지됩니다. 따라서 이 방식은 여러 번 발생하는 이벤트를 처리하고 싶을 때 유용합니다. 두 가지 방식 중 어느 것이 더 나은지는 애플리케이션의 요구사항과 구현 세부 사항에 따라 달라집니다. 애플리케이션의 요구사항에 맞는 방식을 선택하여 사용하는 것이 좋습니다.</li>
</ul>
<h2 id="nativeeventemitter의-래퍼-훅으로-listenonce-함수를-사용하여-일회성-이벤트-리스너를-등록하고-이벤트를-최초-한-번-받은-후에-스스로-할당을-해제하는-예제-코드"><code>NativeEventEmitter</code>의 래퍼 훅으로 <code>listenOnce</code> 함수를 사용하여 일회성 이벤트 리스너를 등록하고 이벤트를 최초 한 번 받은 후에 스스로 할당을 해제하는 예제 코드</h2>
<pre><code class="language-javascript">import { NativeEventEmitter } from &quot;react-native&quot;;
const listenOnce = (eventEmitter, eventName, callback) =&gt; {
  let subscription;
  const handleEvent = (...args) =&gt; {
    callback(...args); // Remove event listener
    subscription.remove();
  };
  subscription = eventEmitter.addListener(eventName, handleEvent);
};
// Usage example

const myEventEmitter = new NativeEventEmitter(MyNativeModule);
listenOnce(myEventEmitter, &quot;MyEvent&quot;, (event) =&gt; {
  console.log(event); // event data
});
</code></pre>
<p>이 예제에서 <code>listenOnce</code> 함수는 <code>eventEmitter</code>, <code>eventName</code>, <code>callback</code> 세 개의 인수를 받습니다. 이 함수는 일회성 이벤트 리스너를 등록하고 이벤트가 발생하면 콜백 함수를 호출한 후에 이벤트 리스너를 제거합니다. 따라서 이 방식을 사용하면 이벤트가 한 번 발생한 후에 자동으로 할당이 해제됩니다.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="이미지 생성 AI를 사용해봐야 할 이유"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/how-to-enhance-experience-of-dal-e-and-midjourney-ai-artists">How to enhance experience of Dal-E and Midjourney AI artists?</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-03-21T00:00:00.000Z" itemprop="datePublished">2023년 3월 21일</time> · <!-- -->약 7분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="이미지-생성-ai를-사용해봐야-할-이유">이미지 생성 AI를 사용해봐야 할 이유</h2>
<p>Dal-E와 미드저니는 인공지능 미술가로서 많은 사람들이 이용하고 있습니다. 이들은 다양한 스타일의 작품을 만들어내며, 사용자의 요구에 따라 맞춤형 작품을 제작할 수도 있습니다. 이러한 기술은 예술의 세계에서 새로운 가능성을 열어주고 있습니다.</p>
<p>인공지능 화가들은 일반적인 대화형 인공지능과 접근성이 비슷합니다. 인터넷 검색을 통해 다양한 인공지능 미술가들의 작품을 볼 수 있습니다. 가격은 다양하며, 작품마다 차이가 있습니다. 예를 들어 한 예술가는 미술 경연에서 AI를 통해 생성한 그림으로 300달러를 벌었습니다.</p>
<h3 id="references">References</h3>
<p>(1) <a href="https://www.itu.int/hub/2022/07/ai-art-artistic-intelligence/">An artist’s vision of AI and artistic intelligence - ITU Hub</a>
(2) <a href="https://www.bbc.com/news/technology-62788725">&quot;Art is dead Dude&quot; - the rise of the AI artists stirs debate</a>
(3) <a href="https://www.turing.ac.uk/research/interest-groups/ai-arts">AI &amp; arts | The Alan Turing Institute</a></p>
<h2 id="무료-플랜에서의-한계">무료 플랜에서의 한계</h2>
<p>Midjourney는 Discord 서버에서 사용할 수 있습니다. 무료 요금 한도 내에서 이미지를 생성하는 것이 가능합니다. 예를 들어, <code>/imagine</code> 명령어를 사용하여 이미지를 생성할 수 있습니다. 또한, 특정한 예술가의 스타일을 지정하여 이미지를 생성할 수도 있습니다. 예를 들어 <code>/imagine fisherman looking out at the ocean, standing in his boat, davinci style</code> 이라는 명령어로 다빈치 스타일의 어부 이미지를 생성할 수 있습니다.</p>
<h3 id="references-1">References</h3>
<p>(1) <a href="https://decentralizedcreator.com/use-midjourney-ai-for-free/">How to Use Midjourney AI for Free - DC</a>
(2) <a href="https://www.digitaltrends.com/computing/how-to-use-midjourney-to-generate-ai-images/">How to use Midjourney to generate AI images | Digital Trends</a>
(3) <a href="https://www.forbes.com/sites/tjmccue/2023/01/24/improve-your-midjourney-ai-image-creation-with-these-advanced-tips/">Improve Your Midjourney AI Image Creation With These Advanced Tips</a>
(4) <a href="https://www.udemy.com/course/midjourney-ai-art-generation-mastery-create-sell-ai-art/">MidJourney: AI Art Generation Mastery Create &amp; Sell AI Art</a>
(5) <a href="https://arstechnica.com/information-technology/2022/11/midjourney-turns-heads-with-quality-leap-in-new-ai-image-generator-version/">“Too easy”—Midjourney tests dramatic new version of its AI image generator</a>
(6) <a href="https://www.digitaltrends.com/computing/how-to-use-midjourney-to-generate-ai-images/">How to use Midjourney to generate AI images | Digital Trends</a></p>
<h2 id="사이버펑크과학공상물-영감을-주는-프롬프트-30년-뒤-현대인의-한끼-식사">사이버펑크/과학공상물 영감을 주는 프롬프트 (&quot;30년 뒤 현대인의 한끼 식사&quot;)</h2>
<h3 id="prompt-a-meal-for-modern-people-30-years-from-now-version-01">Prompt &quot;A meal for modern people 30 years from now&quot; version 01.</h3>
<p>&quot;In a bustling cyberpunk cityscape, a woman sits at a sleek, high-tech table in her apartment. In front of her is a plate of food that looks almost unrecognizable - an array of colorful, geometric shapes made from lab-grown ingredients and 3D-printed to perfection. She takes a bite with her smart utensils, which analyze the nutritional content and flavor profile in real-time. As she eats, holographic displays around her show the latest news and entertainment.&quot;</p>
<h3 id="prompt-a-meal-for-modern-people-30-years-from-now-version-02">Prompt &quot;A meal for modern people 30 years from now&quot; version 02.</h3>
<p>&quot;In a world ravaged by climate change and extreme weather events, food production has become increasingly difficult. A man sits alone in his small apartment, staring at the single nutrition bar that constitutes his entire meal. It&#x27;s designed to provide all the essential nutrients he needs to survive, but it&#x27;s bland and unappetizing. He takes a bite and chews slowly, remembering the days when he could enjoy a variety of flavors and textures. Outside his window, the sky is gray and polluted.&quot;</p>
<h3 id="prompt-a-meal-for-modern-people-30-years-from-now-version-03">Prompt &quot;A meal for modern people 30 years from now&quot; version 03.</h3>
<p>&quot;In a dimly lit room, a group of people sit around a table, listlessly eating their nutrition bars made from ground insects and other unidentifiable ingredients. Their expressions are blank and their movements mechanical as they chew the tasteless bars. Suddenly, a holographic display flickers to life above the table, showing an advertisement for a new line of gourmet nutrition bars - designed for foodies and boasting real flavor. The people at the table stare at the display with wide eyes and slack jaws, as if seeing something miraculous for the first time.&quot;</p>
<h3 id="prompt-a-meal-for-modern-people-30-years-from-now-version-04">Prompt &quot;A meal for modern people 30 years from now&quot; version 04.</h3>
<p>&quot;In a crowded and run-down room in a poor country, a group of teenagers huddle around an old-fashioned stand-alone digital TV. On the screen, a flashy advertisement plays for a new food product - zero-something - that promises to satisfy all cravings for sugar and fat without any negative health consequences. The teenagers watch with wide eyes and open mouths, unable to understand the words but mesmerized by the bright colors and tantalizing images of food. Their stomachs growl with hunger as they dream of tasting something so delicious.&quot;</p>
<h3 id="prompt-a-meal-for-modern-people-30-years-from-now-version-05">Prompt &quot;A meal for modern people 30 years from now&quot; version 05.</h3>
<p>&quot;In a world where climate change and overpopulation have pushed humanity to the brink, a family gathers around a small table in their cramped apartment. The meal they share is simple and unremarkable - lab-grown protein and hydroponically grown vegetables - but it&#x27;s enough to sustain them. They eat in silence, grateful for what they have but worried about the future. Outside their window, the city sprawls endlessly, a concrete jungle teeming with people and pollution.&quot;</p>
<h3 id="prompt-a-meal-for-modern-people-30-years-from-now-version-06">Prompt &quot;A meal for modern people 30 years from now&quot; version 06.</h3>
<p>&quot;In a future where advanced technology has made it possible to pack all the necessary nutrients and rich flavors into a single sheet of edible paper, a woman sits alone in her small apartment. She takes a bite of the paper and savors the taste, but there&#x27;s a sadness in her eyes. This high-tech food product, once considered a luxury, is now all she can afford as prices for animal-based products have skyrocketed beyond her reach. Outside her window, the wealthy dine on real meat and dairy while she can only dream of such extravagance.&quot;</p>
<h3 id="prompt-a-meal-for-modern-people-30-years-from-now-version-07">Prompt &quot;A meal for modern people 30 years from now&quot; version 07.</h3>
<p>&quot;In a future where climate taxes have made animal-based and inefficiently grown crops a luxury only the wealthy can afford, a man sits in a fine dining restaurant. He tears into his steak with greasy fingers and relishes every bite, knowing that this is the height of culinary indulgence. Across town, in a small apartment, a woman puts on her virtual reality headset and enters the metaverse. There she can experience the sights and smells of decadent food while in reality she eats her nutritionally complete but flavorless edible paper. Once considered cutting-edge molecular gastronomy is now all she can afford.&quot;</p>
<h3 id="prompt-a-meal-for-modern-people-30-years-from-now-version-08">Prompt &quot;A meal for modern people 30 years from now&quot; version 08.</h3>
<p>&quot;In a future where food has become more than just sustenance, a group of friends gather in a trendy restaurant. They order dishes made from ingredients that have been genetically modified to enhance their emotions and experiences. As they eat, they laugh and cry and feel more alive than ever before. Across town, in a laboratory, scientists work tirelessly to create new and more powerful food-based experiences. But as the line between nourishment and entertainment blurs, some begin to question the ethics of manipulating emotions through food.&quot;</p></div></article><nav class="pagination-nav" aria-label="블로그 게시물 목록 탐색"><a class="pagination-nav__link pagination-nav__link--prev" href="/wiki/blog/page/3"><div class="pagination-nav__label">  이전 페이지</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/wiki/blog/page/5"><div class="pagination-nav__label">다음 페이지</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">문서</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/wiki/docs/intro">튜토리얼</a></li></ul></div><div class="col footer__col"><div class="footer__title">커뮤니티</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">스택오버플로우<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">디스코드<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">트위터<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">더보기</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/wiki/blog">블로그</a></li><li class="footer__item"><a href="https://github.com/AndrewDongminYoo/wiki" target="_blank" rel="noopener noreferrer" class="footer__link-item">깃허브<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Dongmin Yu, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>