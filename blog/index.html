<!doctype html>
<html lang="ko" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.0.0">
<title data-rh="true">블로그 | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://andrewdongminyoo.github.io/wiki/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://andrewdongminyoo.github.io/wiki/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://andrewdongminyoo.github.io/wiki/blog"><meta data-rh="true" property="og:locale" content="ko"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" property="og:title" content="블로그 | My Site"><meta data-rh="true" name="description" content="블로그"><meta data-rh="true" property="og:description" content="블로그"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="icon" href="/wiki/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://andrewdongminyoo.github.io/wiki/blog"><link data-rh="true" rel="alternate" href="https://andrewdongminyoo.github.io/wiki/blog" hreflang="ko"><link data-rh="true" rel="alternate" href="https://andrewdongminyoo.github.io/wiki/blog" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://W3IYVVWLWE-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/wiki/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/wiki/blog/atom.xml" title="My Site Atom Feed">



<link rel="search" type="application/opensearchdescription+xml" title="My Site" href="/wiki/opensearch.xml"><link rel="stylesheet" href="/wiki/assets/css/styles.87524305.css">
<script src="/wiki/assets/js/runtime~main.08d7e581.js" defer="defer"></script>
<script src="/wiki/assets/js/main.7baa3f39.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="본문으로 건너뛰기"><a class="skipToContent_D8pK" href="#__docusaurus_skipToContent_fallback">본문으로 건너뛰기</a></div><nav aria-label="메인" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="네비게이션 바 토글하기" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/wiki/"><div class="navbar__logo"><img src="/wiki/img/logo.svg" alt="내 사이트 로고" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/wiki/img/logo.svg" alt="내 사이트 로고" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">내 사이트</b></a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>한국어</a><ul class="dropdown__menu"><li><a href="/wiki/blog" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="ko">한국어</a></li></ul></div><a class="navbar__item navbar__link" href="/wiki/docs/intro">튜토리얼</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/wiki/blog">블로그</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/AndrewDongminYoo/wiki" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">깃허브<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="검색"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">검색</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="최근 블로그 문서 둘러보기"><div class="sidebarItemTitle_pO2u margin-bottom--md">최신글</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/blog/front-backend-developer-roadmap">프론트+백엔드 개발자 로드맵</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/blog/static-property-in-java-class">Static Property in Java Class</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/blog/four-mainstream-d-bs-and-features">  가장 많이 사용되는 주류 DB 4가지와 특징</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/blog/generate-unicode-emoji-regular-expression">Generate Unicode emoji regular expression</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/wiki/blog/redirection-of-the-website">웹사이트의 리다이렉팅 방식</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="https://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="개발자로 한국에서 취직을 하려면 로드맵을 어떻게 정하는게 좋을지 궁금하신 것 같습니다. 웹 개발자는 크게 프론트엔드와 백엔드로 나뉘는데요, 프론트엔드는 웹사이트나 웹앱의 사용자 인터페이스를 담당하는 파트이고, 백엔드는 서버와 데이터베이스를 다루는 파트입니다."><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/front-backend-developer-roadmap">프론트+백엔드 개발자 로드맵</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-06-20T00:00:00.000Z" itemprop="datePublished">2023년 6월 20일</time> · <!-- -->약 6분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>개발자로 한국에서 취직을 하려면 로드맵을 어떻게 정하는게 좋을지 궁금하신 것 같습니다. 웹 개발자는 크게 프론트엔드와 백엔드로 나뉘는데요, 프론트엔드는 웹사이트나 웹앱의 사용자 인터페이스를 담당하는 파트이고, 백엔드는 서버와 데이터베이스를 다루는 파트입니다.
프론트엔드 개발자가 되고 싶으시다면 JavaScript부터 공부하셔야 합니다. JavaScript는 웹사이트나 웹앱에 동적인 기능과 상호작용을 추가할 수 있는 언어입니다.
프론트엔드 개발자 로드맵에 따르면, HTML/CSS와 JavaScript의 기본기를 다지신 후에는 다음과 같은 주제들을 공부하시면 좋습니다.</p>
<ul>
<li>웹 브라우저의 동작 방식과 성능 최적화</li>
<li>반응형 디자인과 CSS 프레임워크</li>
<li>자바스크립트 라이브러리와 프레임워크 (예: React, Vue, Angular)</li>
<li>API와 HTTP 통신</li>
<li>버전 관리 시스템 (예: Git)</li>
<li>테스트 및 디버깅 도구</li>
<li>타입스크립트와 GraphQL과 같은 심화 주제</li>
</ul>
<p>만약 백엔드 개발자가 되고 싶으시다면, HTML/CSS와 JavaScript 외에도 서버 사이드 언어 (예: Python, Java, Node.js)와 데이터베이스 (예: MySQL, MongoDB)를 배우셔야 합니다.
백엔드 개발자 로드맵에 따르면, 서버 사이드 언어와 데이터베이스의 기본기를 다지신 후에는 다음과 같은 주제들을 공부하시면 좋습니다.</p>
<ul>
<li>RESTful API 설계와 구현</li>
<li>인증과 보안</li>
<li>캐싱과 로깅</li>
<li>클라우드 서비스 (예: AWS, Azure)</li>
<li>배포 및 운영 방법</li>
<li>마이크로서비스와 컨테이너화</li>
</ul>
<p>위의 주제들은 모두 중요하고 유용하지만, 모든 것을 한 번에 배울 수 없습니다. 그러므로 자신의 목표와 관심 분야에 맞춰  서 우선순위를 정하고 차근차근 공부해 나가시기 바랍니다.
비전공자로서 단기간에 개발자로 취직을 하려면 많은 시간과 노력이 필요할 것입니다. 하지만 포기하지 마시고 꾸준히 학습하시면 분명 성장할 수 있습니다. 저도 여러분의 성공을 응원합니다!</p>
<p>덧붙여서 직접 만든 작품들을 포트폴리오로 정리해 두시면 취직에 도움이 됩니다. 포트폴리오를 만들 때 참고할 수 있는 것은 여러 가지가 있습니다. 예를 들어,</p>
<ul>
<li>무료 템플릿을 이용해서 깔끔하고 전문적인 포트폴리오를 만들 수 있는 웹사이트</li>
<li>개발자의 포트폴리오와 이력서 작성법에 대한 블로그 글</li>
<li>스타트업 취업이 되는 개발자 포트폴리오 만드는 법에 대한 커뮤니티 게시글</li>
</ul>
<p>등이 있습니다.
포트폴리오를 만들 때는 자신의 작업물을 잘 보여줄 수 있는 디자인과 내용을 선택하고, 자신이 한 부분과 역할을 명확하게 설명해주시면 좋습니다. 또한 포트폴리오의 주제와 분야가 자신이 지원하는 회사나 직무와 관련이 있도록 하시면 더욱 효과적입니다.</p>
<ol>
<li><a href="https://gmlwjd9405.github.io/2018/05/04/how-to-write-a-resume-for-a-developer.html">[포트폴리오・이력서] 개발자의 포트폴리오・이력서 작성법 ...</a></li>
<li><a href="https://okky.kr/articles/1412554">OKKY - 스타트업 취업이 무조건 되는 개발자 포트폴리오 만들기</a></li>
<li><a href="https://www.canva.com/ko_kr/create/portfolios/">포트폴리오 만들기. 무료 템플릿으로 만드는 깔끔한 포트폴리오 ...</a></li>
<li><a href="https://www.codeit.kr/tutorials/38/frontend-2023">2023 프론트엔드 개발자 로드맵 ㅣ공부순서 총정리 (한글 ver ...</a></li>
<li><a href="https://academy.dream-coding.com/pages/roadmap">로드맵 (공부순서) - 드림코딩 아카데미 | Dream Coding Academy</a></li>
<li><a href="https://zero-base.co.kr/event/media_BE_school_roadmap">2023 백엔드 개발자 로드맵 feat. 현직 백엔드 개발자 | zero-base</a></li>
</ol></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="자바 파일은 크게 필드 \+ 생성자\+ 메서드로 구성되어 있고 그중 필드 부분에서 선언한 전역변수 와 정적 멤버변수 이 두가지는 static 영역에 데이터를 저장하고 사용한다. 이 영역에서 데이터는 프로그램의 시작부터 종료될 때까지 메모리에 남아 있다."><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/static-property-in-java-class">Static Property in Java Class</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-06-10T00:00:00.000Z" itemprop="datePublished">2023년 6월 10일</time> · <!-- -->약 4분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>자바 파일은 크게 필드 + 생성자+ 메서드로 구성되어 있고 그중 필드 부분에서 선언한 전역변수 와 정적 멤버변수 이 두가지는 static 영역에 데이터를 저장하고 사용한다. 이 영역에서 데이터는 프로그램의 시작부터 종료될 때까지 메모리에 남아 있다.</p>
<blockquote>
<p>전역변수를 무분별하게 사용하면 메모리가 부족할 우려가 있으니 필요한 변수만 사용하기!</p>
</blockquote>
<ul>
<li>패키지나 클래스 정보가 호출되는 시점에 즉시 메소드 영역에 올라간다</li>
<li>static 이 붙은 클래스 멤버 필드, 멤버메서드 역시 포함이다</li>
<li>JVM 종료 시점까지 사라지지 않고 유지된다</li>
<li>클래스, 메소드 영역이라고 불린다.</li>
</ul>
<ol>
<li>클래스 변수<!-- -->
<ul>
<li>static 키워드를 가지고 필드에 선언하는 변수 = 정적 필드 (메모리의 static 영역 사용)</li>
<li>프로그램 시작시 생성, 프로그램 종료시 소멸</li>
</ul>
</li>
<li>멤버 변수(인스턴스 변수)<!-- -->
<ul>
<li>static 키워드 없이 필드에 선언하는 변수 (메모리의 heap영역 사용)</li>
<li>인스턴스 생성 시 생성, 참조하지 않을시 소멸(가비지 컬렉터가 소멸시킴)</li>
</ul>
</li>
<li>지역 변수<!-- -->
<ul>
<li>메소드, 생성자, 초기화 블록 내부에서 선언하는 변수</li>
<li>메소드 호출 시 생성, 메소드 종료시 소멸</li>
<li>JVM은 자바 프로그램을 실행하기 위한 가상 머신, 자바 바이트코드를 실행하고 메모리 관리와 가비지 컬렉션(GC) 등의 작업을 수행.</li>
<li>프로세스는 운영체제에서 실행 중인 프로그램을 의미. 각 프로세스는 독립된 메모리 공간을 할당받아 사용, 다른 프로세스와 데이터를 공유하려면 특별한 방법(IPC)이 필요.</li>
<li>스레드는 프로세스 내에서 실행되는 작업의 단위. 하나의 프로세스에 여러 개의 스레드가 존재할 수 있으며 이들은 같은 메모리 공간을 공유하면서 동시에 작업을 수행 가능.</li>
<li>JVM과 프로세스와 스레드는 서로 다른 개념이지만 관계 있음. 자바 프로그램이 실행되면 JVM이 시작되고 이 JVM은 하나의 프로세스. 이 JVM 프로세스 내부에서 여러 개의 스레드가 생성되어 작업을 수행.</li>
</ul>
</li>
</ol></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="Summary"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/four-mainstream-d-bs-and-features">가장 많이 사용되는 주류 DB 4가지와 특징</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-05-25T00:00:00.000Z" itemprop="datePublished">2023년 5월 25일</time> · <!-- -->약 3분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="summary">Summary</h2>
<p>RDBMS에서 가장 많이 사용되는 데이터베이스 각각의 특징과 장단점</p>
<ol>
<li>
<p>Oracle: Oracle Corporation에서 개발되었으며 현재 가장 널리 사용되는 RDBMS입니다.
사용자 정의 유형, 상속 및 다형성과 같은 객체 지향 기능을 구현하는 RDBMS를 객체 관계형 데이터베이스 관리 시스템 (ORDBMS)이라고 합니다.
Oracle Database는 관계형 모델을 객체 관계형 모델로 확장하여 복잡한 비즈니스 모델을 관계형 데이터베이스에 저장할 수 있습니다.</p>
</li>
<li>
<p>MySQL: MySQL은 오픈 소스이며 무료이고 세계에서 가장 인기있는 DB입니다.</p>
<p>MySQL은 관계형 데이터베이스입니다.
MySQL소프트웨어는 오픈소스입니다.
MySQL데이터베이스 서버는 매우 빠르고 안정적이며 확장 가능하며 사용하기 쉽습니다.
MySQL서버는 클라이언트 / 서버 또는 임베디드 시스템에서 작동합니다.</p>
</li>
<li>
<p>SQL Server: Microsoft에서 개발한 SQL Server는 세계에서 가장 널리 사용되는 데이터베이스 중 하나입니다. C, C++로 작성되어 있고 SQL Server는 Microsoft Azure Cloud의 일부입니다.</p>
</li>
<li>
<p>PostgreSQL: PostgreSQL은 복잡한 데이터 워크로드를 안전하게 저장하며 SQL 언어를 사용하고 확장하는 오픈 소스 객체 관계형 데이터베이스 시스템입니다. PostgreSQL은 아키텍처, 안정성과 데이터 무결성, 강력한 기능 세트, 확장성 및 소프트웨어 뒤의 오픈소스 커뮤니티의 헌신으로 성능과 혁신적인 솔루션을 지속적으로 제공하는 것으로 유명합니다.</p>
</li>
</ol>
<h3 id="references">References</h3>
<p>(1) <a href="https://sw-ko.tistory.com/189">[데이터베이스] RDBMS 종류와 특성 - 차근차근</a>
(2) <a href="https://lifelong-education-dr-kim.tistory.com/entry/%EA%B4%80%EA%B3%84%ED%98%95%EA%B3%BC-%EB%B9%84%EA%B4%80%EA%B3%84%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%ED%8A%B9%EC%A7%95">관계형과 비관계형 데이터 베이스의 종류와 특징</a></p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="Question"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/generate-unicode-emoji-regular-expression">Generate Unicode emoji regular expression</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-05-19T00:00:00.000Z" itemprop="datePublished">2023년 5월 19일</time> · <!-- -->약 2분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="question">Question</h2>
<pre><code class="language-plaintext">⚙ &lt;fe0f&gt; gear Unicode: `U+2699` `U+FE0F`, `UTF-8: E2 9A 99 EF B8 8F`
</code></pre>
<p>Write a regular expression that matches all Unicode emojis of this type.</p>
<h2 id="answer">Answer</h2>
<p>Sure, I can help you with that! Here&#x27;s a regular expression that matches all Unicode emojis of this type:</p>
<pre><code class="language-RegExp">\u2699[\uFE0E\uFE0F]
</code></pre>
<p>This regular expression matches the gear Unicode character (<code>U+2699</code>) followed by either the text presentation selector (<code>U+FE0E</code>) or the emoji presentation
selector (<code>U+FE0F</code>). The &quot;g&quot; at the end of the regular expression means that it will match all occurrences of this pattern in a given string.</p>
<p>I hope this helps! Let me know if you have any other questions.</p>
<h2 id="question-1">Question</h2>
<p>Write a regular expression that matches all Unicode emojis of this type.</p>
<h2 id="answer-1">Answer</h2>
<p>Sure, I can help you with that! Here&#x27;s a regular expression that matches all Unicode emojis of this type:</p>
<pre><code class="language-RegExp">[\u{1f600}-\u{1f64f}]
</code></pre>
<p>This regular expression uses the Unicode code point range for emoticons, which is U+1F600 to U+1F64F. The <code>/u</code> flag at the end of the expression enables
Unicode mode in JavaScript, which allows the matching of Unicode characters beyond the BMP (Basic Multilingual Plane).</p>
<p>This regular expression will match all emojis of this type, including smileys, people, animals, and other objects.</p>
<h2 id="question-2">Question</h2>
<p>Write a regular expression that matches all Unicode emoji characters of this type. not only people emojis but all of them</p>
<h2 id="answer-2">Answer</h2>
<p>Sure, I can help you with that! Here&#x27;s a regular expression that matches all Unicode emoji characters:</p>
<pre><code class="language-RegExp">[\u{1F000}-\u{1F6FF}\u{1F900}-\u{1F9FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F1E0}-\u{1F1FF}]
</code></pre>
<p>This regular expression uses Unicode character ranges to match all the different types of emoji characters. The ranges include:</p>
<ul>
<li><code>\u{1F000}-\u{1F6FF}</code>: 기타 기호 및 그림, 이모티콘, 교통 및 지도 기호 등.</li>
<li><code>\u{1F900}-\u{1F9FF}</code>: 보조 기호 및 픽토그램.</li>
<li><code>\u{2600}-\u{26FF}</code>: 기타 기호, 딩벳 등.</li>
<li><code>\u{2700}-\u{27BF}</code>: 딩벳, 보조 화살표-C 등.</li>
<li><code>\u{1F300}-\u{1F5FF}</code>: 날씨, 시간 등을 포함한 기타 기호 및 픽토그램.</li>
<li><code>\u{1F680}-\u{1F6FF}</code>: 자동차, 자전거, 비행기 등을 포함한 교통수단 및 지도 기호.</li>
<li><code>\u{1F1E0}-\u{1F1FF}</code>: 국가 국기를 나타내는 데 사용되는 지역 표시 기호.</li>
</ul>
<p>I hope this helps! Let me know if you have any other questions.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="일반적으로 스마트폰을 이용해 웹사이트에 접속하면 모바일용 사이트로 리다이렉팅하는 경우가 많습니다. 이러한 리다이렉팅은 서버 측 리다이렉트 방식을 사용하여 구현할 수 있습니다. 서버 측 리다이렉트 방식은 HTTP 상태 코드 301 또는 302를 사용하여 클라이언트에게 새로운 URL로 이동하도록 지시합니다. 이 방식은 빠르게 작동하며, 검색엔진 최적화(SEO)에도 유리합니다."><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/redirection-of-the-website">웹사이트의 리다이렉팅 방식</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-05-16T00:00:00.000Z" itemprop="datePublished">2023년 5월 16일</time> · <!-- -->약 6분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>일반적으로 스마트폰을 이용해 웹사이트에 접속하면 모바일용 사이트로 리다이렉팅하는 경우가 많습니다. 이러한 리다이렉팅은 서버 측 리다이렉트 방식을 사용하여 구현할 수 있습니다. 서버 측 리다이렉트 방식은 HTTP 상태 코드 301 또는 302를 사용하여 클라이언트에게 새로운 URL로 이동하도록 지시합니다. 이 방식은 빠르게 작동하며, 검색엔진 최적화(SEO)에도 유리합니다.
하지만, 깃허브 페이지에서는 서버 측 리다이렉트를 직접 설정할 수 없습니다. 하지만, 깃허브 페이지의 정적 사이트에서 메타 리프레시 태그를 사용하여 리다이렉트를 구현할 수 있습니다. 메타 리프레시 태그는 <code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=https://new-website.com&quot;&gt;</code>와 같은 형태로 사용할 수 있습니다. 이 태그는 <code>content</code> 속성의 첫 번째 값으로 지정된 시간(초) 후에 <code>url</code>로 지정된 페이지로 이동합니다. 이 방식은 자바스크립트 리다이렉트 방식보다 빠르게 작동하며, 검색엔진 최적화(SEO)에도 더 유리합니다.
메타 리프레시 태그는 웹 페이지를 다른 URL로 자동으로 리다이렉트하는 데 사용됩니다. 이 방식의 장점은 다음과 같습니다.</p>
<ol>
<li>쉽게 구현할 수 있습니다. 메타 리프레시 태그는 HTML 코드에 추가하기만 하면 됩니다.</li>
<li>자바스크립트가 비활성화되어 있어도 작동합니다. 메타 리프레시 태그는 HTML 코드에 포함되므로, 자바스크립트가 비활성화되어 있어도 작동합니다.
하지만, 메타 리프레시 태그에도 몇 가지 단점이 있습니다.</li>
<li>검색엔진 최적화(SEO)에 불리할 수 있습니다. 메타 리프레시 태그는 검색엔진이 인식하기 어려울 수 있으며, 검색엔진 최적화(SEO)에 불리할 수 있습니다.</li>
<li>사용자 경험을 저해할 수 있습니다. 메타 리프레시 태그로 인해 페이지가 자동으로 이동하면, 사용자가 원하지 않는 페이지로 이동될 수 있습니다. 이로 인해 사용자 경험이 저해될 수 있습니다.
메타 리프레시 태그를 사용할 때는 이러한 장단점을 고려하여 적절하게 사용하는 것이 좋습니다.</li>
</ol>
<p>  깃허브 페이지의 정적 사이트에서 자바스크립트 리다이렉트 메소드로 유저를 이동시키는 경우, 1초 정도의 지연이 발생할 수 있습니다.</p>
<p>한 페이지에서 메타 태그 리다이렉트와 자바스크립트 리다이렉트를 병행하여 사용하는 경우, 다음과 같은 문제가 발생할 수 있습니다.</p>
<ol>
<li>사용자가 원하지 않는 페이지로 이동될 수 있습니다. 메타 태그 리다이렉트와 자바스크립트 리다이렉트가 서로 다른 URL로 이동하도록 설정된 경우, 사용자가 원하지 않는 페이지로 이동될 수 있습니다.</li>
<li>검색엔진 최적화(SEO)에 불리할 수 있습니다. 검색엔진은 한 페이지에서 여러 가지 리다이렉팅 방식이 사용되는 경우, 해당 페이지의 콘텐츠를 정확하게 인식하기 어려울 수 있습니다. 이로 인해 검색엔진 최적화(SEO)에 불리할 수 있습니다.
따라서, 한 페이지에서는 하나의 리다이렉팅 방식만 사용하는 것이 좋습니다. 리다이렉팅 방식을 선택할 때는 상황에 따라 적절한 방식을 선택하는 것이 중요합니다.</li>
</ol></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="다음은 NativeBatteryProvider라는 이름의 컴포넌트를 만드는 예시 코드입니다. 이 컴포넌트는 기기의 배터리 잔량을 정기적으로 쿼리하여 State 형태로 하위 컴포넌트들에게 전달합니다."><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/native-battery-provider-react-context-provider-pattern">NativeBatteryProvider - React Context Provider Pattern</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-05-11T00:00:00.000Z" itemprop="datePublished">2023년 5월 11일</time> · <!-- -->약 14분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>다음은 <code>NativeBatteryProvider</code>라는 이름의 컴포넌트를 만드는 예시 코드입니다. 이 컴포넌트는 기기의 배터리 잔량을 정기적으로 쿼리하여 <code>State&lt;number&gt;</code> 형태로 하위 컴포넌트들에게 전달합니다.</p>
<pre><code class="language-jsx">import React, { createContext, useState, useEffect } from &quot;react&quot;;
import { NativeModules } from &quot;react-native&quot;;
const BatteryContext = createContext();
const NativeBatteryProvider = ({ children }) =&gt; {
  const [batteryLevel, setBatteryLevel] = useState(null);
  useEffect(() =&gt; {
    const interval = setInterval(() =&gt; {
      NativeModules.BatteryStatus.getBatteryStatus((level) =&gt; {
        setBatteryLevel(level);
      });
    }, 1000);
    return () =&gt; clearInterval(interval);
  }, []);
  return (
    &lt;BatteryContext.Provider value={batteryLevel}&gt;
            {children}
    &lt;/BatteryContext.Provider&gt;
  );
};
export { BatteryContext, NativeBatteryProvider };
</code></pre>
<p>이 예제에서는 <code>NativeModules.BatteryStatus.getBatteryStatus</code> 메소드를 사용하여 배터리 잔량을 가져옵니다. 이 메소드는 네이티브 모듈에서 구현해야 합니다. 또한 <code>setInterval</code> 함수를 사용하여 1초마다 배터리 잔량을 쿼리합니다.
이제 다른 컴포넌트에서 <code>useContext</code> Hook을 사용하여 <code>BatteryContext</code>의 값을 가져올 수 있습니다.</p>
<pre><code class="language-jsx">import React, { useContext } from &quot;react&quot;;
import { Text } from &quot;react-native&quot;;
import { BatteryContext } from &quot;./NativeBatteryProvider&quot;;
const BatteryLevel = () =&gt; {
  const batteryLevel = useContext(BatteryContext);
  return &lt;Text&gt;Battery Level: {batteryLevel}&lt;/Text&gt;;
};
</code></pre>
<p>이 예제에서는 <code>useContext</code> Hook을 사용하여 <code>BatteryContext</code>의 값을 가져와서 화면에 표시합니다.</p>
<p>특정 무선 이어폰을 위한 네이티브 블루투스 모듈을 사용하여 여러가지 동작을 실행하고 이벤트 응답을 받으려면 다음과 같은 단계를 따르십시오:</p>
<ol>
<li>네이티브 모듈에서 블루투스 이벤트를 구독하고 이벤트가 발생할 때마다 React Native로 전달합니다. 이를 위해 <code>NativeEventEmitter</code> 클래스를 사용할 수 있습니다.</li>
<li>React Native에서 <code>NativeEventEmitter</code> 인스턴스를 생성하고 <code>addListener</code> 메소드를 사용하여 이벤트를 구독합니다.</li>
<li>이벤트가 발생할 때마다 상태를 업데이트하고 하위 컴포넌트들에게 전달합니다. 이를 위해 <code>Context.Provider</code>와 <code>useContext</code> Hook을 사용할 수 있습니다.
다음은 이러한 기능을 구현하는 예시 코드입니다.</li>
</ol>
<pre><code class="language-jsx">import React, { createContext, useState, useEffect } from &quot;react&quot;;
import { NativeModules, NativeEventEmitter } from &quot;react-native&quot;;
const BluetoothContext = createContext();
const BluetoothProvider = ({ children }) =&gt; {
  const [batteryLevel, setBatteryLevel] = useState(null);
  useEffect(() =&gt; {
    const eventEmitter = new NativeEventEmitter(NativeModules.BluetoothModule);
    const subscription = eventEmitter.addListener(
      &quot;BatteryLevelChanged&quot;,

      (level) =&gt; {
        setBatteryLevel(level);
      },
    );
    return () =&gt; subscription.remove();
  }, []);
  return (
    &lt;BluetoothContext.Provider value={{ batteryLevel }}&gt;
            {children}
    &lt;/BluetoothContext.Provider&gt;
  );
};
export { BluetoothContext, BluetoothProvider };
</code></pre>
<p>이 예제에서는 <code>NativeEventEmitter</code> 클래스를 사용하여 네이티브 모듈에서 발생하는 <code>BatteryLevelChanged</code> 이벤트를 구독합니다. 이벤트가 발생할 때마다 상태를 업데이트하고 하위 컴포넌트들에게 전달합니다.
이제 다른 컴포넌트에서 <code>useContext</code> Hook을 사용하여 <code>BluetoothContext</code>의 값을 가져올 수 있습니다.</p>
<pre><code class="language-jsx">import React, { useContext } from &quot;react&quot;;
import { Text } from &quot;react-native&quot;;
import { BluetoothContext } from &quot;./BluetoothProvider&quot;;
const BatteryLevel = () =&gt; {
  const { batteryLevel } = useContext(BluetoothContext);
  return &lt;Text&gt;Battery Level: {batteryLevel}&lt;/Text&gt;;
};
</code></pre>
<p>이 예제에서는 <code>useContext</code> Hook을 사용하여 <code>BluetoothContext</code>의 값을 가져와서 화면에 표시합니다.
음악 재생 출력 변경 등의 메소드를 실행하려면 네이티브 모듈에서 해당 기능을 구현하고 React Native에서 해당 메소드를 호출해야 합니다.</p>
<p>커스텀 훅이나 컨텍스트 프로바이더를 만드는 것에 대한 아키텍쳐 가이드는 다양한 방법이 있습니다. 일반적으로는 앱의 상태를 전역적으로 관리하고 하위 컴포넌트들에게 전달하는 데 사용됩니다.
다음은 <code>NativeModules.BluetoothModule.changePlayback</code> 메소드를 호출하고 <code>changePlaybackResult</code> 이벤트를 리턴받아 상태를 업데이트하는 예시 코드입니다.</p>
<pre><code class="language-jsx">import React, { createContext, useState, useEffect } from &quot;react&quot;;
import { NativeModules, NativeEventEmitter } from &quot;react-native&quot;;
const BluetoothContext = createContext();
const BluetoothProvider = ({ children }) =&gt; {
  const [playbackDevice, setPlaybackDevice] = useState(null);
  useEffect(() =&gt; {
    const eventEmitter = new NativeEventEmitter(NativeModules.BluetoothModule);
    const subscription = eventEmitter.addListener(
      &quot;changePlaybackResult&quot;,

      (device) =&gt; {
        setPlaybackDevice(device);
      },
    );
    return () =&gt; subscription.remove();
  }, []);
  const changePlayback = () =&gt; {
    NativeModules.BluetoothModule.changePlayback();
  };
  return (
    &lt;BluetoothContext.Provider value={{ playbackDevice, changePlayback }}&gt;
            {children}
    &lt;/BluetoothContext.Provider&gt;
  );
};
export { BluetoothContext, BluetoothProvider };
</code></pre>
<p>이 예제에서는 <code>NativeEventEmitter</code> 클래스를 사용하여 네이티브 모듈에서 발생하는 <code>changePlaybackResult</code> 이벤트를 구독합니다. 이벤트가 발생할 때마다 상태를 업데이트하고 하위 컴포넌트들에게 전달합니다. 또한 <code>changePlayback</code> 함수를 정의하여 <code>NativeModules.BluetoothModule.changePlayback</code> 메소드를 호출합니다.
이제 다른 컴포넌트에서 <code>useContext</code> Hook을 사용하여 <code>BluetoothContext</code>의 값을 가져올 수 있습니다.</p>
<pre><code class="language-jsx">import React, { useContext } from &quot;react&quot;;
import { Text, Button } from &quot;react-native&quot;;
import { BluetoothContext } from &quot;./BluetoothProvider&quot;;
const PlaybackDevice = () =&gt; {
  const { playbackDevice, changePlayback } = useContext(BluetoothContext);
  return (
    &lt;&gt;
            &lt;Text&gt;Playback Device: {playbackDevice}&lt;/Text&gt;
            &lt;Button onPress={changePlayback} title=&quot;Change Playback&quot; /&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>이 예제에서는 <code>useContext</code> Hook을 사용하여 <code>BluetoothContext</code>의 값을 가져와서 화면에 표시합니다. 또한 <code>Button</code> 컴포넌트의 <code>onPress</code> prop에 <code>changePlayback</code> 함수를 전달하여 버튼을 클릭하면 <code>NativeModules.BluetoothModule.changePlayback</code> 메소드가 호출되도록 합니다.</p>
<p><code>Context.Provider</code>의 <code>value</code> prop에 전달하는 객체에는 프로바이더에서 관리하는 모든 상태와 메소드를 포함하는 것이 일반적입니다. 이렇게 하면 하위 컴포넌트들이 <code>useContext</code> Hook을 사용하여 상태와 메소드를 가져올 수 있습니다.
예를 들어, 다음과 같은 코드에서는 <code>BluetoothContext.Provider</code>의 <code>value</code> prop에 전달하는 객체에 <code>playbackDevice</code> 상태와 <code>changePlayback</code> 메소드가 포함되어 있습니다.</p>
<pre><code class="language-jsx">const BluetoothProvider = ({ children }) =&gt; {
  const [playbackDevice, setPlaybackDevice] = useState(null);
  const changePlayback = () =&gt; {
    console.log(&quot;changed...!&quot;);
  };
  return (
    &lt;BluetoothContext.Provider value={{ playbackDevice, changePlayback }}&gt;
            {children}
    &lt;/BluetoothContext.Provider&gt;
  );
};
</code></pre>
<p>이제 다른 컴포넌트에서 <code>useContext</code> Hook을 사용하여 <code>BluetoothContext</code>의 값을 가져올 수 있습니다.</p>
<pre><code class="language-jsx">const PlaybackDevice = () =&gt; {
  const { playbackDevice, changePlayback } = useContext(BluetoothContext);
};
</code></pre>
<p>이 예제에서는 <code>useContext</code> Hook을 사용하여 <code>BluetoothContext</code>의 값을 가져와서 <code>playbackDevice</code> 상태와 <code>changePlayback</code> 메소드를 사용할 수 있습니다.</p>
<p><code>useContext</code> Hook과 <code>Context.Provider</code>를 사용하지 않는 다른 접근 방법도 있습니다. 예를 들어, Redux와 같은 상태관리 라이브러리를 사용하여 앱의 상태를 전역적으로 관리할 수 있습니다.
Redux는 전역 상태 저장소를 제공하고 액션을 사용하여 상태를 업데이트합니다. 이를 통해 앱의 모든 컴포넌트에서 상태를 가져오고 업데이트할 수 있습니다.
다음은 Redux를 사용하여 앱의 상태를 관리하는 예시 코드입니다.</p>
<pre><code class="language-jsx">import { createStore } from &quot;redux&quot;;
// 리듀서 함수 정의

const reducer = (state = { playbackDevice: null }, action) =&gt; {
  switch (action.type) {
    case &quot;SET_PLAYBACK_DEVICE&quot;:
      return { ...state, playbackDevice: action.device };
    default:
      return state;
  }
};
// 스토어 생성

const store = createStore(reducer);
// 스토어 구독

store.subscribe(() =&gt; {
  console.log(store.getState());
});
// 액션 디스패치

store.dispatch({ type: &quot;SET_PLAYBACK_DEVICE&quot;, device: &quot;Speaker&quot; });
</code></pre>
<p>이 예제에서는 <code>createStore</code> 함수를 사용하여 Redux 스토어를 생성합니다. 또한 <code>reducer</code> 함수를 정의하여 상태를 업데이트하는 방법을 지정합니다. 이후 <code>store.subscribe</code> 메소드를 사용하여 스토어의 변경 사항을 구독하고 <code>store.dispatch</code> 메소드를 사용하여 액션을 디스패치합니다.
이 방법 외에도 MobX와 같은 다른 상태관리 라이브러리를 사용할 수도 있습니다. 이러한 라이브러리는 각각 고유한 방식으로 상태관리를 제공합니다.</p>
<p><code>useContext</code> Hook과 <code>Context.Provider</code>를 사용하는 방법은 외부 라이브러리를 사용하지 않고 전역 상태를 관리하는 일반적인 방법 중 하나입니다. 그러나 이것이 유일한 방법은 아닙니다.
예를 들어, React의 <code>props</code>를 사용하여 상위 컴포넌트에서 하위 컴포넌트로 상태와 메소드를 전달할 수 있습니다. 이 방법은 컴포넌트 계층이 깊지 않은 경우에 적합합니다.
다음은 <code>props</code>를 사용하여 상위 컴포넌트에서 하위 컴포넌트로 상태와 메소드를 전달하는 예시 코드입니다.</p>
<pre><code class="language-jsx">import React, { useState } from &quot;react&quot;;
import { Text, Button } from &quot;react-native&quot;;
const Parent = () =&gt; {
  const [playbackDevice, setPlaybackDevice] = useState(null);
  const changePlayback = () =&gt; {
    console.log(&quot;changed...!&quot;);
  };
  return (
    &lt;Child playbackDevice={playbackDevice} changePlayback={changePlayback} /&gt;
  );
};
const Child = ({ playbackDevice, changePlayback }) =&gt; {
  return (
    &lt;&gt;
            &lt;Text&gt;Playback Device: {playbackDevice}&lt;/Text&gt;
            &lt;Button onPress={changePlayback} title=&quot;Change Playback&quot; /&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>이 예제에서는 <code>Parent</code> 컴포넌트에서 <code>useState</code> Hook을 사용하여 상태를 정의하고 <code>Child</code> 컴포넌트의 <code>props</code>로 전달합니다. 또한 <code>changePlayback</code> 함수를 정의하고 <code>Child</code> 컴포넌트의 <code>props</code>로 전달합니다.
이 방법은 간단한 경우에 적합하지만 컴포넌트 계층이 깊어지면 복잡해질 수 있습니다. 이 경우에는 <code>useContext</code> Hook과 <code>Context.Provider</code>를 사용하는 것이 더 적합할 수 있습니다.</p>
<p><code>RefObject</code>와 <code>useRef</code> Hook은 컴포넌트의 인스턴스 또는 DOM 요소에 대한 참조를 저장하는 데 사용됩니다. 이러한 기능은 상태관리와는 직접적으로 관련이 없습니다.
그러나 <code>useRef</code> Hook을 사용하여 컴포넌트 간에 데이터를 전달하는 데 사용할 수 있습니다. 예를 들어, <code>forwardRef</code> 함수를 사용하여 하위 컴포넌트의 메소드를 상위 컴포넌트에서 호출할 수 있습니다.
다음은 <code>useRef</code> Hook과 <code>forwardRef</code> 함수를 사용하여 하위 컴포넌트의 메소드를 상위 컴포넌트에서 호출하는 예시 코드입니다.</p>
<pre><code class="language-jsx">import React, { useRef, forwardRef } from &quot;react&quot;;
import { Button } from &quot;react-native&quot;;
const Parent = () =&gt; {
  const childRef = useRef();
  const handleClick = () =&gt; {
    childRef.current.changePlayback();
  };
  return (
    &lt;&gt;
            &lt;Child ref={childRef} /&gt;
            &lt;Button onPress={handleClick} title=&quot;Change Playback&quot; /&gt;
    &lt;/&gt;
  );
};
const Child = forwardRef((props, ref) =&gt; {
  const changePlayback = () =&gt; {
    console.log(&quot;changed...!&quot;);
  }; // ref 객체에 메소드 할당
  ref.current = { changePlayback };
  return null;
});
</code></pre>
<p>이 예  제에서는 <code>Parent</code> 컴포넌트에서 <code>useRef</code> Hook을 사용하여 <code>childRef</code> 객체를 생성합니다. 이 객체는 <code>Child</code> 컴포넌트의 인스턴스에 대한 참조를 저장합니다. 또한 <code>Button</code> 컴포넌트의 <code>onPress</code> prop에 <code>handleClick</code> 함수를 전달하여 버튼을 클릭하면 <code>Child</code> 컴포넌트의 <code>changePlayback</code> 메소드가 호출되도록 합니다.
<code>Child</code> 컴포넌트에서는 <code>forwardRef</code> 함수를 사용하여 <code>ref</code> prop을 전달받습니다. 이 prop은 상위 컴포넌트에서 생성한 <code>childRef</code> 객체와 동일합니다. 이제 이 객체의 <code>current</code> 속성에 <code>changePlayback</code> 메소드를 할당하여 상위 컴포넌트에서 호출할 수 있도록 합니다.
이 방법은 특정 경우에 유용할 수 있지만 일반적으로는 상태관리에 사용되지 않습니다. 상태관리에는 일반적으로 <code>useContext</code> Hook과 <code>Context.Provider</code>, 또는 외부 상태관리 라이브러리가 사용됩니다.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="What is MONAD and How Can we Implement it"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/monad-pattern">Monad Pattern</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-05-05T00:00:00.000Z" itemprop="datePublished">2023년 5월 5일</time> · <!-- -->약 22분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="what-is-monad-and-how-can-we-implement-it">What is MONAD and How Can we Implement it</h2>
<p>프로그래밍에서 모나드는 함수형 프로그래밍에서 사용되는 디자인 패턴 중 하나입니다. 모나드는 값을 캡슐화하고, 그 값을 변환하는 함수를 체이닝하는 방식으로 작동합니다. 이를 통해 코드의 가독성을 높이고, 부수 효과를 제어할 수 있습니다. Haskell 언어에서 모나드는 매우 중요한 개념으로 사용됩니다.
스칼라에서 모나드는 트레이트(trait)로 구현됩니다. 모나드는 <code>flatMap</code>과 <code>unit</code>이라는 두 가지 메소드를 가지고 있습니다. 다음은 스칼라에서 <code>Option</code> 모나드의 예제입니다.</p>
<pre><code class="language-scala">val opt1: Option[Int] = Some(3)
val opt2: Option[Int] = Some(5)
val opt3: Option[Int] = None
val result = for {
  x &lt;- opt1
  y &lt;- opt2
} yield x + y
println(result) // Some(8)
val result2 = for {
  x &lt;- opt1
  y &lt;- opt3
} yield x + y
println(result2) // None
</code></pre>
<p>위의 예제에서 <code>for</code> 구문은 <code>flatMap</code>과 <code>map</code>을 사용하여 변환됩니다. <code>Option</code> 모나드는 값이 있을 수도 있고 없을 수도 있는 상황에서 안전한 연산을 가능하게 합니다.
<code>flatMap</code>과 <code>unit</code>은 모나드의 두 가지 기본 연산입니다. <code>flatMap</code>은 모나드 값을 받아서 다른 모나드 값을 반환하는 함수를 적용하는 연산입니다. 이를 통해 모나드 값을 변환하고 체이닝할 수 있습니다. <code>unit</code>은 일반 값을 모나드 값으로 변환하는 연산입니다.
다음은 스칼라에서 <code>List</code> 모나드의 <code>flatMap</code>과 <code>unit</code> 예제입니다.</p>
<pre><code class="language-scala">val list1 = List(1, 2, 3)
val list2 = List(4, 5, 6)
val result = list1.flatMap(x =&gt; list2.map(y =&gt; x + y))
println(result) // List(5, 6, 7, 6, 7, 8, 7, 8, 9)
val unitResult = List.unit(3)
println(unitResult) // List(3)
</code></pre>
<p>위의 예제에서 <code>flatMap</code>은 <code>list1</code>의 각 요소에 대해 함수를 적용하여 새로운 리스트를 생성하고 이를 하나의 리스트로 합칩니다. <code>unit</code>은 일반 값을 리스트로 변환합니다.
자바스크립트는 함수형 프로그래밍을 지원하는 언어이기 때문에 모나드 패턴을 사용할 수 있습니다. 다음은 자바스크립트에서 <code>Maybe</code> 모나드의 예제입니다.</p>
<pre><code class="language-javascript">class Maybe {
  constructor(value) {
    this.value = value;
  }
  static of(value) {
    return new Maybe(value);
  }
  isNothing() {
    return this.value === null || this.value === undefined;
  }
  map(fn) {
    return this.isNothing() ? Maybe.of(null) : Maybe.of(fn(this.value));
  }
  flatMap(fn) {
    return this.map(fn).join();
  }
  join() {
    return this.isNothing() ? Maybe.of(null) : this.value;
  }
}
const maybe1 = Maybe.of(3);
const maybe2 = Maybe.of(null);
const result = maybe1.flatMap((x) =&gt; Maybe.of(x + 2));
console.log(result); // Maybe { value: 5 }
const result2 = maybe2.flatMap((x) =&gt; Maybe.of(x + 2));
console.log(result2); // Maybe { value: null }
</code></pre>
<p>위의 예제에서 <code>Maybe</code> 모나드는 값이 있을 수도 있고 없을 수도 있는 상황에서 안전한 연산을 가능하게 합니다. <code>flatMap</code>은 <code>Maybe</code> 값을 받아서 다른 <code>Maybe</code> 값을 반환하는 함수를 적용하는 연산입니다.
다음은 자  바스크립트에서 <code>Promise</code> 모나드의 예제입니다.</p>
<pre><code class="language-javascript">const promise1 = Promise.resolve(3);
const promise2 = Promise.reject(new Error(&quot;An error occurred&quot;));
const result = promise1.then((x) =&gt; x + 2);
result.then(console.log); // 5
const result2 = promise2.then((x) =&gt; x + 2);
result2.catch(console.log); // Error: An error occurred
</code></pre>
<p>위의 예제에서 <code>Promise</code>는 비동기 연산의 결과를 캡슐화하는 모나드입니다. <code>then</code> 메소드는 <code>Promise</code> 값을 받아서 다른 <code>Promise</code> 값을 반환하는 함수를 적용하는 연산입니다. 이를 통해 비동기 연산을 체이닝하고 에러 처리를 할 수 있습니다.</p>
<h2 id="모나드-패턴의-장점">모나드 패턴의 장점</h2>
<ol>
<li>코드의 가독성 향상: 모나드를 사용하면 코드의 가독성이 높아집니다. 모나드는 값을 캡슐화하고, 그 값을 변환하는 함수를 체이닝하는 방식으로 작동하기 때문에 코드가 간결해집니다.</li>
<li>부수 효과 제어: 모나드를 사용하면 부수 효과를 제어할 수 있습니다. 예를 들어 <code>Maybe</code> 모나드는 값이 있을 수도 있고 없을 수도 있는 상황에서 안전한 연산을 가능하게 합니다. <code>Promise</code> 모나드는 비동기 연산의 결과를 캡슐화하여 에러 처리를 할 수 있게 합니다.</li>
<li>추상화: 모나드는 추상화 수준을 높여줍니다. 예를 들어 <code>List</code> 모나드는 리스트에 대한 연산을 추상화하여 코드의 재사용성을 높여줍니다.</li>
<li>함수형 프로그래밍 지원: 모나드는 함수형 프로그래밍 패러다임을 지원합니다. 함수형 프로그래밍은 순수 함수와 불변성을 강조하여 코드의 예측 가능성과 안정성을 높여줍니다.</li>
</ol>
<h2 id="타입스크립트에서-모나드를-구현할-때-주로-사용되는-키워드와-패  턴">타입스크립트에서 모나드를 구현할 때 주로 사용되는 키워드와 패턴</h2>
<ol>
<li>
<p>인터페이스와 제네릭: 타입스크립트에서 모나드는 인터페이스와 제네릭을 사용하여 구현됩니다. 인터페이스를 사용하면 모나드가 가져야 할 메소드를 정의할 수 있습니다. 제네릭을 사용하면 모나드가 다양한 타입의 값을 캡슐화할 수 있습니다.</p>
<pre><code class="language-typescript">interface Monad&lt;T&gt; {
  flatMap&lt;U&gt;(fn: (value: T) =&gt; Monad&lt;U&gt;): Monad&lt;U&gt;;
  unit(value: T): Monad&lt;T&gt;;
}
</code></pre>
</li>
<li>
<p>클래스와 메소드: 타입스크립트에서 모나드는 클래스로 구현됩니다. 클래스를 사용하면 모나드의 인스턴스를 생성하고 메소드를 정의할 수 있습니다.</p>
<pre><code class="language-typescript">class Maybe&lt;T&gt; implements Monad&lt;T&gt; {
  constructor(private value: T | null) {}
  static of&lt;T&gt;(value: T | null) {
    return new Maybe(value);
  }
  flatMap&lt;U&gt;(fn: (value: T) =&gt; Maybe&lt;U&gt;): Maybe&lt;U&gt; {
    return this.value === null ? Maybe.of(null) : fn(this.value);
  }
  unit(value: T): Maybe&lt;T&gt; {
    return Maybe.of(value);
  }
}
</code></pre>
</li>
<li>
<p>함수 체이닝: 타입스크립트에서 모나드는 함수 체이닝 패턴을 사용하여 작동합니다. <code>flatMap</code> 메소드를 사용하면 모나드 값을 변환하고 체이닝할 수 있습니다.</p>
<pre><code class="language-typescript">const maybe1 = Maybe.of(3);
const maybe2 = Maybe.of(null);
const result = maybe1.flatMap((x) =&gt; Maybe.of(x + 2));
console.log(result); // Maybe { value: 5 }
const result2 = maybe2.flatMap((x) =&gt; Maybe.of(x + 2));
console.log(result2); // Maybe { value: null }
</code></pre>
</li>
</ol>
<p>다음은 타입스크립트에서 <code>Either</code> 모나드의 예제입니다.</p>
<pre><code class="language-typescript">type Either&lt;L, R&gt; = Left&lt;L, R&gt; | Right&lt;L, R&gt;;
class Left&lt;L, R&gt; {
  constructor(readonly value: L) {}
  static of&lt;L, R&gt;(value: L) {
    return new Left&lt;L, R&gt;(value);
  }
  flatMap&lt;U&gt;(fn: (value: R) =&gt; Either&lt;L, U&gt;): Either&lt;L, U&gt; {
    return this as Either&lt;L, U&gt;;
  }
  unit(value: R): Either&lt;L, R&gt; {
    return Right.of(value);
  }
}
class Right&lt;L, R&gt; {
  constructor(readonly value: R) {}
  static of&lt;L, R&gt;(value: R) {
    return new Right&lt;L, R&gt;(value);
  }
  flatMap&lt;U&gt;(fn: (value: R) =&gt; Either&lt;L, U&gt;): Either&lt;L, U&gt; {
    return fn(this.value);
  }
  unit(value: R): Either&lt;L, R&gt; {
    return Right.of(value);
  }
}
const either1: Either&lt;string, number&gt; = Right.of(3);
const either2: Either&lt;string, number&gt; = Left.of(&quot;An error occurred&quot;);
const result = either1.flatMap((x) =&gt; Right.of(x + 2));
console.log(result); // Right { value: 5 }
const result2 = either2.flatMap((x) =&gt; Right.of(x + 2));
console.log(result2); // Left { value: &#x27;An error occurred&#x27; }
</code></pre>
<p>위의 예제에서 <code>Either</code> 모나드는 값을 캡슐화하고 에러 처리를 가능하게 합니다. <code>flatMap</code> 메소드는 <code>Either</code> 값을 받아서 다른 <code>Either</code> 값을 반환하는 함수를 적용하는 연산입니다. 이를 통해 연산을 체이닝하고 에러 처리를 할 수 있습니다.
<code>infer</code> 키워드는 타입스크립트에서 조건부 타입을 정의할 때 사용되는 키워드입니다. <code>infer</code> 키워드를 사용하면 타입을 추론할 수 있습니다. <code>infer</code> 키워드는 모나드와 직접적인 관련이 없지만, 모나드를 구현할 때 유용하게 사용될 수 있습니다.
다음은 <code>infer</code> 키워드를 사용하여 <code>Unwrap</code> 타입을 정의하는 예제입니다.</p>
<pre><code class="language-typescript">type Unwrap&lt;T&gt; = T extends Monad&lt;infer U&gt; ? U : never;
interface Monad&lt;T&gt; {
  flatMap&lt;U&gt;(fn: (value: T) =&gt; Monad&lt;U&gt;): Monad&lt;U&gt;;
  unit(value: T): Monad&lt;T&gt;;
}
class Maybe&lt;T&gt; implements Monad&lt;T&gt; {
  constructor(private value: T | null) {}
  static of&lt;T&gt;(value: T | null) {
    return new Maybe(value);
  }
  flatMap&lt;U&gt;(fn: (value: T) =&gt; Maybe&lt;U&gt;): Maybe&lt;U&gt; {
    return this.value === null ? Maybe.of(null) : fn(this.value);
  }
  unit(value: T): Maybe&lt;T&gt; {
    return Maybe.of(value);
  }
}
const maybe1 = Maybe.of(3);
type Result = Unwrap&lt;typeof maybe1&gt;; // number
</code></pre>
<p>위의 예제에서 <code>Unwrap</code> 타입은 <code>Monad</code> 타입의 값을 추론하여 그 내부의 값을 반환하는 타입입니다. 이를 통해 모나드의 내부 값을 추론할 수 있습니다.
다음은 타입스크립트에서 <code>IO</code> 모나드의 예제입니다.</p>
<pre><code class="language-typescript">class IO&lt;T&gt; {
  constructor(private effect: () =&gt; T) {}
  static of&lt;T&gt;(value: T) {
    return new IO(() =&gt; value);
  }
  static from&lt;T&gt;(effect: () =&gt; T) {
    return new IO(effect);
  }
  flatMap&lt;U&gt;(fn: (value: T) =&gt; IO&lt;U&gt;): IO&lt;U&gt; {
    return new IO(() =&gt; fn(this.effect()).run());
  }
  unit(value: T): IO&lt;T&gt; {
    return IO.of(value);
  }
  run() {
    return this.effect();
  }
}
const io1 = IO.from(() =&gt; {
  console.log(&quot;Hello&quot;);
  return &quot;Hello&quot;;
});
const io2 = io1.flatMap((x) =&gt; IO.from(() =&gt; x + &quot; World&quot;));
io2.run(); // Hello World
</code></pre>
<p>위의 예제에서 <code>IO</code> 모나드는 부수 효과를 캡슐화하는 모나드입니다. <code>flatMap</code> 메소드는 <code>IO</code> 값을 받아서 다른 <code>IO</code> 값을 반환하는 함수를 적용하는 연산입니다. 이를 통해 부수 효과를 체이닝하고 제어할 수 있습니다.
다음은 타입스크립트에서 <code>IO</code> 모나드를 사용하여 부수 효과를 제어하는 예제입니다.</p>
<pre><code class="language-typescript">class IO&lt;T&gt; {
  constructor(private effect: () =&gt; T) {}
  static of&lt;T&gt;(value: T) {
    return new IO(() =&gt; value);
  }
  static from&lt;T&gt;(effect: () =&gt; T) {
    return new IO(effect);
  }
  flatMap&lt;U&gt;(fn: (value: T) =&gt; IO&lt;U&gt;): IO&lt;U&gt; {
    return new IO(() =&gt; fn(this.effect()).run());
  }
  unit(value: T): IO&lt;T&gt; {
    return IO.of(value);
  }
  run() {
    return this.effect();
  }
}
const io1 = IO.from(() =&gt; {
  console.log(&quot;First effect&quot;);
  return &quot;First&quot;;
});
const io2 = io1.flatMap((x) =&gt;
  IO.from(() =&gt; {
    console.log(&quot;Second effect&quot;);
    return x + &quot; Second&quot;;
  }),
);
const io3 = io2.flatMap((x) =&gt;
  IO.from(() =&gt; {
    console.log(&quot;Third effect&quot;);
    return x + &quot; Third&quot;;
  }),
);
io3.run(); // First effect Second effect Third effect
</code></pre>
<p>위의 예제에서 <code>IO</code> 모나드는 부수 효과를 캡슐화하고 체이닝합니다. <code>flatMap</code> 메소드를 사용하면 부수 효과를 순차적으로 실행할 수 있습니다. 이를 통해 부수 효과의 실행 순서를 제어할 수 있습니다.
<code>flatMap</code> 메소드는 모나드 값을 받아서 다른 모나드 값을 반환하는 함수를 적용하는 연산입니다. 이를 통해 모나드 값을 변환하고 체이닝할 수 있습니다.
<code>map</code> 메소드는 이터러블 객체의 각 요소에 대해 함수를 적용하여 새로운 이터러블 객체를 생성하는 연산입니다. <code>forEach</code> 메소드는 이터러블 객체의 각 요소에 대해 함수를 적용하지만 새로운 이터러블 객체를 생성하지 않습니다.</p>
<h2 id="flatmap-메소드와-map-foreach-메소드의-차이점"><code>flatMap</code> 메소드와 <code>map</code>, <code>forEach</code> 메소드의 차이점</h2>
<ol>
<li>적용 대상: <code>flatMap</code> 메소드는 모나드 값에 적용되는 반면, <code>map</code>, <code>forEach</code> 메소드는 이터러블 객체에 적용됩니다.</li>
<li>반환 값: <code>flatMap</code> 메소드는 모나드 값을 반환하는 반면, <code>map</code> 메소드는 이터러블 객체를 반환하고 <code>forEach</code> 메소드는 반환값이 없습니다.</li>
<li>체이닝: <code>flatMap</code> 메소드는 모나드 값을 체이닝하는 데 사용됩니다. <code>map</code>, <code>forEach</code> 메소드는 이터러블 객체의 각 요소에 대해 함수를 적용하는 데 사용됩니다.</li>
</ol>
<p>모나드는 타입스크립트에서 기본적으로 정의된 타입이 아닙니다. 모나드는 함수형 프로그래밍에서 사용되는 디자인 패턴으로, 개발자가 직접 구현해야 합니다. 모나드는 <code>flatMap</code>과 <code>unit</code>이라는 두 가지 메소드를 가지고 있어야 하며, 이러한 메소드를 사용하여   값을 변환하고 체이닝하는 방식으로 작동합니다. 따라서 모나드는 사용하기로 약속된 규범이라고 볼 수 있습니다. 모나드라는 용어가 코드에 사용되면 다른 개발자들은 해당 타입이 <code>flatMap</code>과 <code>unit</code> 메소드를 가지고 있을 것이라고 예상할 수 있습니다. 이는 모나드가 함수형 프로그래밍에서 널리 사용되는 디자인 패턴이기 때문입니다.</p>
<p>모나드의 인터페이스나 추상 클래스를 제공하는 타입 라이브러리는 존재하지 않습니다. 하지만 타입스크립트에서는 인터페이스를 사용하여 모나드가 가져야 할 메소드를 정의할 수 있습니다. 또한, 모나드를 구현한 모듈을 작성하여 임포트해서 사용할 수도 있습니다.</p>
<pre><code class="language-typescript">interface Monad&lt;T&gt; {
  flatMap&lt;U&gt;(fn: (value: T) =&gt; Monad&lt;U&gt;): Monad&lt;U&gt;;
  unit(value: T): Monad&lt;T&gt;;
}
class Maybe&lt;T&gt; implements Monad&lt;T&gt; {
  constructor(private value: T | null) {}
  static of&lt;T&gt;(value: T | null) {
    return new Maybe(value);
  }
  flatMap&lt;U&gt;(fn: (value: T) =&gt; Maybe&lt;U&gt;): Maybe&lt;U&gt; {
    return this.value === null ? Maybe.of(null) : fn(this.value);
  }
  unit(value: T): Maybe&lt;T&gt; {
    return Maybe.of(value);
  }
}
</code></pre>
<p>위의 예제에서 <code>Monad</code> 인터페이스는 모나드가 가져야 할 메소드를 정의합니다. <code>Maybe</code> 클래스는 <code>Monad</code> 인터페이스를 구현하여 <code>flatMap</code>과 <code>unit</code> 메소드를 정의합니다.</p>
<p>타입스크립트의 미리 정의된 유틸리티 타입 중에는 모나드의 구현체가 없습니다. 모나드는 함수형 프로그래밍에서 사용되는 디자인 패턴으로, 개발자가 직접 구현해야 합니다. 타입스크립트에서는 인터페이스와 제네릭을 사용하여 모나드를 구현할 수 있습니다.</p>
<p>자바스  크립트의 객체는 불변성을 가지고 있지 않습니다. 이는 객체의 속성이 변경될 수 있다는 것을 의미합니다. 이러한 특성은 모나드의 구현에 문제를 일으킬 수 있습니다. 모나드는 함수형 프로그래밍에서 사용되는 디자인 패턴으로, 순수 함수와 불변성을 강조합니다. 따라서 모나드를 사용할 때는 객체의 불변성을 유지하는 것이 중요합니다. 자바스크립트에서는 <code>Object.freeze</code> 메소드를 사용하여 객체의 불변성을 유지할 수 있습니다.</p>
<pre><code class="language-javascript">const obj = { x: 3 };
Object.freeze(obj);
obj.x = 4; // TypeError: Cannot assign to read only property &#x27;x&#x27; of object &#x27;#&lt;Object&gt;&#x27;
</code></pre>
<p>위의 예제에서 <code>Object.freeze</code> 메소드를 사용하여 객체의 속성을 변경할 수 없도록 합니다. 이를 통해 객체의 불변성을 유지할 수 있습니다.
다음은 자바스크립트에서 <code>Object.freeze</code> 메소드를 사용하는 예제입니다.</p>
<pre><code class="language-javascript">const obj = { x: 3, y: { z: 5 } };
Object.freeze(obj);
obj.x = 4; // TypeError: Cannot assign to read only property &#x27;x&#x27; of object &#x27;#&lt;Object&gt;&#x27;
obj.y.z = 6; // No error
console.log(obj); // { x: 3, y: { z: 6 } }
</code></pre>
<p>위의 예제에서 <code>Object.freeze</code> 메소드를 사용하여 객체의 속성을 변경할 수 없도록 합니다. 하지만 <code>Object.freeze</code> 메소드는 얕은 동결(shallow freeze)만 수행하기 때문에 중첩된 객체의 속성은 변경할 수 있습니다.</p>
<pre><code class="language-javascript">const obj = { x: 3, y: { z: 5 } };
Object.freeze(obj);
Object.freeze(obj.y);
obj.x = 4; // TypeError: Cannot assign to read only property &#x27;x&#x27; of object &#x27;#&lt;Object&gt;&#x27;
obj.y.z = 6; // TypeError: Cannot assign to read only property &#x27;z&#x27; of object &#x27;#&lt;Object&gt;&#x27;
console.log(obj); // { x: 3, y: { z: 5 } }
</code></pre>
<p>위의 예제에서 <code>Object.freeze</code> 메소드를 사용하여 중첩된 객체의 속성도 변경할 수 없도록 합니다. 이를 통해 객체의 불변성을 유지할 수 있습니다.
<code>Object.freeze</code> 메소드를 사용하여 <code>enum</code>과 유사한 기능을 하는 객체를 생성할 수 있습니다. <code>Object.freeze</code> 메소드를 사용하면 객체의 속성을 변경할 수 없도록 할 수 있기 때문입니다.</p>
<pre><code class="language-javascript">const Color = Object.freeze({
  RED: &quot;red&quot;,
  GREEN: &quot;green&quot;,
  BLUE: &quot;blue&quot;,
});
console.log(Color.RED); // red
Color.RED = &quot;yellow&quot;; // TypeError: Cannot assign to read only property &#x27;RED&#x27; of object &#x27;#&lt;Object&gt;&#x27;
</code></pre>
<p>위의 예제에서 <code>Object.freeze</code> 메소드를 사용하여 <code>Color</code> 객체의 속성을 변경할 수 없도록 합니다. 이를 통해 <code>enum</code>과 유사한 기능을 하는 객체를 생성할 수 있습니다.
<code>immer.js</code>와 <code>lodash.js</code>는 모나드의 구현과 직접적인 관련이 없습니다. 하지만 이러한 라이브러리를 사용하면 모나드를 사용하는 코드의 가독성과 사용성을 높일 수 있습니다.</p>
<pre><code class="language-javascript">import produce from &quot;immer&quot;;
const baseState = [
  { task: &quot;Learn typescript&quot;, done: true },
  { task: &quot;Try immer&quot;, done: false },
];
const nextState = produce(baseState, (draftState) =&gt; {
  draftState.push({ task: &quot;Tweet about it&quot; });
  draftState[1].done = true;
});
console.log(baseState); // [{ task: &#x27;Learn typescript&#x27;, done: true }, { task: &#x27;Try immer&#x27;, done: false }]
console.log(nextState); // [{ task: &#x27;Learn typescript&#x27;, done: true }, { task: &#x27;Try immer&#x27;, done: true }, { task: &#x27;Tweet about it&#x27; }]
</code></pre>
<p><code>immer.js</code>는 불변성 을 유지하는 데이터 구조를 제공하는 라이브러리입니다. <code>immer.js</code>를 사용하면 모나드를 사용하는 코드에서 불변성을 쉽게 유지할 수 있습니다. 위의 예제에서 <code>produce</code> 함수를 사용하여 <code>baseState</code> 객체의 불변성을 유지하면서 새로운 상태를 생성합니다.</p>
<pre><code class="language-javascript">import _ from &quot;lodash&quot;;
const users = [
  { user: &quot;barney&quot;, age: 36, active: true },
  { user: &quot;fred&quot;, age: 40, active: false },
  { user: &quot;pebbles&quot;, age: 1, active: true },
];
const result = _.filter(users, (o) =&gt; !o.active);
console.log(result); // [{ user: &#x27;fred&#x27;, age: 40, active: false }]
</code></pre>
<p><code>lodash.js</code>는 유틸리티 함수를 제공하는 라이브러리입니다. <code>lodash.js</code>를 사용하면 모나드를 사용하는 코드에서 데이터 변환을 쉽게 할 수 있습니다. 위의 예제에서 <code>filter</code> 함수를 사용하여 <code>users</code> 배열에서 <code>active</code> 속성이 <code>false</code>인 요소만 추출합니다.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="노코드/로우코드 프로토타이핑/와이어프레이밍 예시"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/comparison-of-the-no-coding-prototype-wireframe-tool">노코딩 프로토타입 와이어프레임 툴 비교</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-05-01T00:00:00.000Z" itemprop="datePublished">2023년 5월 1일</time> · <!-- -->약 7분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 id="노코드로우코드-프로토타이핑와이어프레이밍-예시">노코드/로우코드 프로토타이핑/와이어프레이밍 예시</h2>
<p>웹이나 모바일 앱의 컴포넌트들을 구성하고 배치해 볼 수 있는 프로토타이핑/와이어프레이밍 툴로는 웹플로우(Webflow)가 있습니다. <a href="https://www.inflearn.com/course/%EC%9B%B9%ED%94%8C%EB%A1%9C%EC%9A%B0-%EB%85%B8%EC%BD%94%EB%93%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9D%B4%ED%95%91">웹플로우는 코딩 없이 자유도 높은 프로토타입을 만들 수 있는 노코드 웹 빌더입니다</a>. 다른 노코드 툴들도 있습니다. 예를 들어 <a href="https://tkim.co/2020/04/19/no-code/">Glide와 Adalo는 모바일 앱을 만들 수 있는 노코드 툴입니다</a>. 이 외에도 다양한 노코드 툴들이 있습니다.</p>
<h3 id="references">References</h3>
<ol>
<li><a href="https://www.inflearn.com/course/%EC%9B%B9%ED%94%8C%EB%A1%9C%EC%9A%B0-%EB%85%B8%EC%BD%94%EB%93%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9D%B4%ED%95%91">inflearn.com</a></li>
<li><a href="https://tkim.co/2020/04/19/no-code/">tkim.co</a></li>
<li><a href="https://www.inflearn.com/course/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%95%B1%EA%B0%9C%EB%B0%9C-%EA%B8%B0%EC%88%A0%EB%85%B8%ED%8A%B8">inflearn.com</a></li>
</ol>
<h2 id="framer-protopie-bubble-retool">Framer, ProtoPie, Bubble, Retool</h2>
<p>Framer와 ProtoPie는 프로토타이핑 툴입니다. Bubble과 Retool은 노코드 툴로 웹 애플리케이션을 만들 수 있습니다. Bubble은 코딩 없이 웹 애플리케이션을 만들 수 있고, Retool은 데이터베이스와 API를 연결하여 내부 비즈니스 앱을 빠르게 만들 수 있는 툴입니다<a href="https://rosettadigital.com/bubble-vs-retool/">Bubble vs Retool</a>.</p>
<h3 id="references-1">References</h3>
<ol>
<li><a href="https://rosettadigital.com/bubble-vs-retool/">rosettadigital.com</a></li>
<li><a href="https://sourceforge.net/software/compare/Bubble-vs-ProtoPie-vs-Retool-vs-WaveMaker-Platform/">sourceforge.net</a></li>
<li><a href="https://sourceforge.net/software/compare/Bubble-vs-Forms-On-Fire-Mobile-vs-ProtoPie-vs-Retool/">sourceforge.net</a>+1</li>
</ol>
<h2 id="framer와-protopie의-차이점">Framer와 ProtoPie의 차이점</h2>
<p>Framer와 ProtoPie는 모두 프로토타이핑 툴입니다. ProtoPie는 완전히 코딩 없는 프로토타입 툴로 디자이너들이 쉽게 사용할 수 있습니다. 다양한 기능과 통합 기능을 제공하며 고급 협업 기능을 갖추고 있습니다. Framer는 코딩을 알고 있는 디자인 팀에게 훌륭합니다. 그러나 Framer는 다른 프로토타이핑 툴에 비해 학습 곡선이 높으며 기술적 배경이 부족한 디자이너들에게 이상적이지 않습니다<a href="https://www.protopie.io/blog/protopie-vs-framer"></a>.</p>
<h3 id="references-2">References</h3>
<ol>
<li><a href="https://www.protopie.io/blog/protopie-vs-framer">protopie.io</a></li>
<li><a href="https://www.g2.com/compare/framer-framer-vs-protopie">g2.com</a></li>
<li><a href="https://stackshare.io/stackups/framer-vs-protopie">stackshare.io</a></li>
</ol>
<h2 id="framer의-장점">Framer의 장점</h2>
<p>Framer는 디자인과 코드를 모두 사용하여 모바일 및 웹 인터페이스의 고품질 프로토타입을 만들 수 있습니다. <a href="https://www.framer.com/">새로운 프로젝트를 시작할 때 Photoshop에서 자산을 생성하고 스프링 물리학과 베지어 곡선 덕분에 3D   공간에서 레이어를 애니메이션화하며 CSS 변환을 기반으로 하드웨어 가속을 사용하여 높은 프레임 속도를 달성할 수 있습니다</a>.</p>
<h3 id="references-3">References</h3>
<ol>
<li><a href="https://www.framer.com/">framer.com</a></li>
<li><a href="https://webruden.tistory.com/225">webruden.tistory.com</a></li>
<li><a href="https://blog.naver.com/PostView.nhn?blogId=tangunsoft&amp;logNo=222288124155">blog.naver.com</a>+1</li>
</ol>
<h2 id="protopie의-장점">ProtoPie의 장점</h2>
<p>ProtoPie는 디자이너들이 상호작용 디자인 아이디어를 현실적인 프로토타입으로 쉽게 만들 수 있는 도구입니다. 스마트폰과 데스크탑부터 TV와 자동차 대시보드 화면까지 실제 디스플레이에서 내일의 디지털 경험을 만들고 테스트할 수 있습니다. ProtoPie를 사용하면 마이크로 상호작용부터 복잡한 다중 화면 애니메이션까지 모든 상호작용을 탐색할 수 있습니다<a href="https://www.protopie.io/"></a>.</p>
<h3 id="references-4">References</h3>
<ol>
<li><a href="https://www.protopie.io/">protopie.io</a></li>
<li><a href="https://www.protopie.io/learn/docs/introducing-protopie/getting-started">protopie.io</a></li>
<li><a href="https://www.protopie.io/figma">protopie.io</a></li>
</ol>
<h2 id="protopie의-단점">ProtoPie의 단점</h2>
<p>ProtoPie는 매우 강력한 프로토타이핑 툴이지만 모든 툴과 마찬가지로 몇 가지 단점이 있을 수 있습니다. ProtoPie의 단점 중 하나는 다른 프로토타이핑 툴에 비해 학습 곡선이 높을 수 있다는 것입니다. 또한 ProtoPie는 다른 디자인 툴과의 통합이 제한적일 수 있습니다. 하지만 이러한 단점들은 개인적인 선호도와 작업 스타일에 따라 다를 수 있습니다.</p>
<h2 id="framer의-단점">Framer의 단점</h2>
<p>Framer는 매우 강력한 프로토타이핑 툴이지만 모든 툴과 마찬가지로 몇 가지 단점이 있을 수 있습니다. Framer 의 단점 중 하나는 다른 프로토타이핑 툴에 비해 학습 곡선이 높을 수 있다는 것입니다. 또한 Framer는 코딩 지식이 없는 디자이너들에게 이상적이지 않을 수 있습니다. 하지만 이러한 단점들은 개인적인 선호도와 작업 스타일에 따라 다를 수 있습니다.</p>
<p>리액트네이티브 개발자가 개발하려는 앱의 프로토타이핑을 하려 할 때, 두 도구를 모두 사용해 본 적이 없다면 어떤 것을 사용하는 것이 더 개발자 경험과 결과물의 퀄리티 측면에서 좋습니까?</p>
<p>Framer와 ProtoPie 모두 리액트 네이티브 개발자가 개발하려는 앱의 프로토타이핑을 위해 사용할 수 있는 강력한 툴입니다. Framer는 코딩 지식이 있는 디자인 팀에게 훌륭합니다. 그러나 Framer는 다른 프로토타이핑 툴에 비해 학습 곡선이 높으며 기술적 배경이 부족한 디자이너들에게 이상적이지 않을 수 있습니다. 반면 ProtoPie는 완전히 코딩 없는 프로토타입 툴로 디자이너들이 쉽게 사용할 수 있습니다. 따라서 리액트 네이티브 개발자가 개발하려는 앱의 프로토타이핑을 위해 어떤 툴을 사용할지 결정하기 전에 개인적인 선호도와 작업 스타일을 고려해야 합니다.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="[] (c) 2003 The FreeBSD Documentation Project."><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/general-commands-manual-builtin">General Commands Manual BUILTIN</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-05-01T00:00:00.000Z" itemprop="datePublished">2023년 5월 1일</time> · <!-- -->약 7분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>[] (c) 2003 The FreeBSD Documentation Project.</p>
<p>[] The FreeBSD Documentation Project is a member of the FreeBSD Foundation.</p>
<h2 id="name">NAME</h2>
<pre><code class="language-sh">builtin, !, %, ., :, @, \[, {, }, alias, alloc, bg, bind, bindkey, break, breaksw, builtins, case, cd, chdir, command, complete,
continue, default, dirs, do, done, echo, echotc, elif, else, end, endif, endsw, esac, eval, exec, exit, export, false, fc, fg,
filetest, fi, for, foreach, getopts, glob, goto, hash, hashstat, history, hup, if, jobid, jobs, kill, limit, local, log, login,
logout, ls-F, nice, nohup, notify, onintr, popd, printenv, printf, pushd, pwd, read, readonly, rehash, repeat, return, sched, set,
setenv, settc, setty, setvar, shift, source, stop, suspend, switch, telltc, test, then, time, times, trap, true, type, ulimit,
umask, unalias, uncomplete, unhash, unlimit, unset, unsetenv, until, wait, where, which, while – shell built-in commands
</code></pre>
<h2 id="synopsis">SYNOPSIS</h2>
<p>See the built-in command description in the appropriate shell manual page.</p>
<h2 id="description">DESCRIPTION</h2>
<p>Shell builtin commands are commands that can be executed within the running shell&#x27;s process. Note that, in the case of csh(1)
builtin commands, the command is executed in a subshell if it occurs as any component of a pipeline except the last.</p>
<p>If a command specified to the shell contains a slash <code>/</code>, the shell will not execute a builtin command, even if the last component.
of the specified command matches the name of a builtin command. Thus, while specifying “echo” causes a builtin command to be
executed under shells that support the echo builtin command, specifying “/bin/echo” or “./echo” does not.</p>
<p>While some builtin commands may exist in more than one shell, their operation may be different under each shell which supports
them. Below is a table which lists shell builtin commands, the standard shells that support them and whether they exist as
standalone utilities.</p>
<p>Only builtin commands for the csh(1) and sh(1) shells are listed here. Consult a shell&#x27;s manual page for details on the operation
of its builtin commands. Beware that the sh(1) manual page, at least, calls some of these commands “built-in commands” and some
of them “reserved words”. Users of other shells may need to consult an info(1) page or other sources of documentation.</p>
<p>Commands marked “No**” under External do exist externally, but are implemented as scripts using a builtin command of the same name.</p>
<table><thead><tr><th style="text-align:center">command</th><th>external</th><th>csh</th><th>sh</th></tr></thead><tbody><tr><td style="text-align:center">!</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">%</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">.</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">:</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">@</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">[</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">{</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">}</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">alias</td><td>No**</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">alloc</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">bg</td><td>No**</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">bind</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">bindkey</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">break</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">breaksw</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">builtin</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">builtins</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">case</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">cd</td><td>No**</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">chdir</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">command</td><td>No**</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">complete</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">continue</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">default</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">dirs</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">do</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">done</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">echo</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">echotc</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">elif</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">else</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">end</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">endif</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">endsw</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">esac</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">eval</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">exec</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">exit</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">export</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">false</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">fc</td><td>No**</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">fg</td><td>No**</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">filetest</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">fi</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">for</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">foreach</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">getopts</td><td>No**</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">glob</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">goto</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">hash</td><td>No**</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">hashstat</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">history</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">hup</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">if</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">jobid</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">jobs</td><td>No**</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">kill</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">limit</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">local</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">log</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">login</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">logout</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">ls-F</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">popd</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">printenv</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">printf</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">pushd</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">pwd</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">read</td><td>No**</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">readonly</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">rehash</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">repeat</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">return</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">sched</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">set</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">setenv</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">settc</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">setty</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">setvar</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">shift</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">source</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">stop</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">suspend</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">switch</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">telltc</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">test</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">then</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">time</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">times</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">trap</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">true</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">type</td><td>No**</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">ulimit</td><td>No**</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">umask</td><td>No**</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">unalias</td><td>No**</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">uncomplete</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">unhash</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">unlimit</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">unset</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">unsetenv</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">until</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td style="text-align:center">wait</td><td>No**</td><td>Yes</td><td>Yes</td></tr><tr><td style="text-align:center">where</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">which</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td style="text-align:center">while</td><td>No</td><td>Yes</td><td>Yes</td></tr></tbody></table>
<h2 id="see-also">SEE ALSO</h2>
<p>csh(1), dash(1), echo(1), false(1), info(1), kill(1), login(1), nice(1), nohup(1), printenv(1), printf(1), pwd(1), sh(1), test(1),
time(1), true(1), which(1), zsh(1)</p>
<h2 id="history">HISTORY</h2>
<p>The builtin manual page first appeared in FreeBSD 3.4.</p>
<h2 id="authors">AUTHORS</h2>
<p>This manual page was written by <a href="sheldonh@FreeBSD.org">Sheldon Hearn</a>.</p>
<pre><code class="language-spec"> macOS 13.3 December 21, 2010 m
</code></pre></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="Git 자격 증명에 로그인하려면 다음 단계를 따르세요:"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/wiki/blog/how-to-signin-git-credential">How to SignIn Git Credential</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-05-01T00:00:00.000Z" itemprop="datePublished">2023년 5월 1일</time> · <!-- -->약 2분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/82999715?v=4" alt="Dongmin Yu" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://gravatar.com/donminzzi" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Dongmin Yu</span></a></div><small class="avatar__subtitle" itemprop="description">Cross Platform Developer Android, iOS, macOS.</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>Git 자격 증명에 로그인하려면 다음 단계를 따르세요:</p>
<ol>
<li>컴퓨터에서 (Git) Bash 또는 명령 프롬프트를 엽니다.</li>
<li><code>git config --global credential.helper store</code>를 입력하고 Enter를 누릅니다. 로그인 자격 증명을 저장하도록 GIT가 구성됩니다.</li>
<li><code>git config --global user.name</code>를 입력하고 Enter를 누릅니다. GIT 사용자 이름으로 교체하십시오.</li>
<li><code>git config --global user.email</code>를 입력하고 Enter를 누릅니다. GIT 계정과 관련된 이메일 주소로 교체하십시오.</li>
<li><code>git config --global credential.username</code>를 입력하고 Enter를 누릅니다. 이렇게하면 GIT 사용자 이름을 GIT 자격 증명의 기본 사용자 이름으로 설정합니다.</li>
<li><code>git config --global credential.helper &#x27;cache --timeout=3600&#x27;</code>를 입력하고 Enter를 누릅니다. 이로 인해 GIT 자격 증명에 대한 시간 초과 1 시간이 설정됩니다.</li>
</ol>
<p>이 단계를 완료하면 Git 사용자 이름과 비밀번호를 사용하여 Git 자격 증명에 로그인할 수 있습니다.</p></div></article><nav class="pagination-nav" aria-label="블로그 게시물 목록 탐색"><a class="pagination-nav__link pagination-nav__link--next" href="/wiki/blog/page/2"><div class="pagination-nav__label">다음 페이지</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">문서</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/wiki/docs/intro">튜토리얼</a></li></ul></div><div class="col footer__col"><div class="footer__title">커뮤니티</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">스택오버플로우<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">디스코드<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">트위터<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">더보기</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/wiki/blog">블로그</a></li><li class="footer__item"><a href="https://github.com/AndrewDongminYoo/wiki" target="_blank" rel="noopener noreferrer" class="footer__link-item">깃허브<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Dongmin Yu, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>